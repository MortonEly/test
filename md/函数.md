指针

概述

指针是“指向（point to）”另外一种类型的复合类型。复合类型是指基于其它类型定义的类型。

理解指针，先从内存说起：内存是一个很大的，线性的字节数组。每一个字节都是固定的大小，由8个二进制位组成。最关键的是，每一个字节都有一个唯一的编号,编号从0开始，一直到最后一个字节。

程序加载到内存中后，在程序中使用的变量、常量、函数等数据，都有自己唯一的一个编号，这个编号就是这个数据的地址。

指针的值实质是内存单元（即字节）的编号，所以指针单独从数值上看，也是整数，他们一般用16进制表示。指针的值（虚拟地址值）使用一个机器字的大小来存储,也就是说,对于一个机器字为w位的电脑而言,它的虚拟地址空间是0~[2的w次幂] - 1,程序最多能访问2的w次幂个字节。这就是为什么xp这种32位系统最大支持4GB内存的原因了。



因此可以理解为：**指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。**

# 2、变量在内存中的存储

举一个最简单的例子 int a = 1，假设计算机使用[大端](https://blog.csdn.net/weixin_39640298/article/details/84573546)方式存储：



内存数据有几点规律：

1. **计算机中的所有数据都是以二进制存储的**
2. **数据类型决定了占用内存的大小**
3. **占据内存的地址就是地址值最小的那个字节的地址**。

现在就可以理解 a 在内存中为什么占4个字节，而且首地址为0028FF40了。

# 3、指针对象（变量）

用来保存指针的对象，就是指针对象。如果指针变量p1保存了变量 a 的地址，则就说：p1指向了变量a，也可以说p1指向了a所在的内存块 ，这种指向关系，在图中一般用 箭头表示:





指针对象p1，也有自己的内存空间，32位机器占4个字节，64位机器占8个字节。所以会有指针的指针。

## 定义指针对象

定义指针变量时，在变量名前写一个 * 星号，这个变量就变成了对应变量类型的指针变量。必要时要加( ) 来避免优先级的问题：

```
int* p_int; 		//指向int类型变量的指针         

double* p_double; 	//指向double类型变量的指针  
   
Student* p_struct; 	//类或结构体类型的指针

int** p_pointer; 	//指向 一个整形变量指针的指针

int(*p_arr)[3]; 	//指向含有3个int元素的数组的指针 
 
int(*p_func)(int,int); 	//指向返回类型为int，有2个int形参的函数的指针
```

## 获取对象地址

指针用于存放某个对象的地址，要想获取该地址，虚使用**取地址符（&）**，如下：

### 获取对象的地址 （取址运算符 &）

指针存放某个对象的地址，需要用取地址符（操作符 &）获取地址。

**符号 & 的作用根据上下文而不同：**

- 作为一元运算符的取址运算符：表达式 &x  （）
- 作为二元运算符的按位与运算符：表达式 x & y
- 用于声明引用的分隔符：声明 int &ref;

```
// 正确示例
double dval;
double *pd = &dval;
double *pd2 = pd;

// 错误示例
int *pi = pd; // 错误：指针pi的类型和pd的类型不匹配
pi = &dval; // 错误：试图把double型对象的地址赋给int型指针

// 说明不同类型的指针之间不能赋值 
```



1. **数组名的值就是这个数组的第一个元素的地址**。
2. **函数名的值就是这个函数的地址**。
3. **字符串字面值常量作为右值时，就是这个字符串对应的字符数组的名称,也就是这个字符串在内存中的地址**。

### 指针值

指针的值（即地址）有4种状态：

- （1）指向一个对象
- （2）指向紧邻对象所占空间的下一个位置
- （3）空指针，意味着指针没有指向任何对象
- （4）无效指针



### 利用指针访问对象 (解引用运算符 *）

如果指针指向了一个对象，则允许使用解引用符（操作符 *）来访问对象。

对指针解引用会得到所指的对象，如果给解引用的结果赋值，就是给指针所指的对象赋值。

**解引用运算符 （\*）的操作数所指的也可以不是对象，而是函数。**

**符号 \* 根据上下文有以下作用：**

- 作为一元运算符的解引用运算符：表达式 *p
- 作为二元运算符的乘法运算符：表达式 x * y
- 用来声明指针的分隔符：声明 int *p;



```awk
int ival = 42;
int *p = &ival;  // p存放着ival的地址 或者说 p是指向变量ival的指针
cout << *p;  // *p得到指针p指向的对象，输出42
/* 给解引用的结果赋值 */
*p = 0; // 由符号 * 得到指针p所指的对象，即可经由p为变量ival赋值
cout << *p; // 输出
```

```
#include <iostream>
#include <typeinfo>

using namespace  std;

int main() {
	// 对象和地址
	int n;
	double x;
	cout << "n的地址：" << &n << endl;
	cout << "x的地址：" << &x << endl;
	// 对象占用的内存空间大小
	cout << "n的内存空间大小：" << sizeof (n) << endl;
	cout << "x的内存空间大小：" << sizeof (x) << endl;
	// 对象的类型
	cout << "n的类型名：" << typeid(n).name() << endl;
	cout << "x的类型名：" << typeid(x).name() << endl;
	// 指针的基础
	int num = 35;
	int *p = 0;

	cout << "num:" << num << endl;
	cout << "地址 &num:" << &num << endl;
	cout << "解引用 *p:" << *p << endl;
	cout << "取地址 &p:" << &p << endl;
	cout << "p:" << p << endl;

	// 指针的类型
	int *p1, *p2;
	double dp, *dp2;

	cout << "p1的类型名：" << typeid(p1).name() << endl;
	cout << "p2的类型名：" << typeid(p2).name() << endl;
	cout << "dp的类型名：" << typeid(dp).name() << endl;
	cout << "dp2的类型名：" << typeid(dp2).name() << endl;
	// 指针的大小
	cout << "p1的内存空间大小：" << sizeof(p1) << endl;
	cout << "dp2的内存空间大小：" << sizeof(dp2) << endl;
	cout << "int* 的大小：" << sizeof(int*) << endl;

	return 0;
}

```

### 空指针

空指针不指向任何对象，在试图使用一个指针前可以先检查指针是否为空。

得到空指针最直接的办法就是用字面值nullptr来初始化指针。

直接把int变量赋值给指针是错误的操作，即使int变量的值恰好等于0也不行。

```cpp
// 空指针的创建方法
int *p1 = nullptr;
int *p2 = 0;
// 需要导入 #include cstdlib
#include <cstdlib>
int *p3 = NULL; // 等价于 int *p3 = 0;
// 不能直接将int变量赋值给指针
int zero = 0;
pi = zero; //错误：不能直接赋值！
```

### 赋值和指针

指针和引用都能提供对其他对象的间接访问。

一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值？

- 记住赋值永远改变的是等号左侧的对象

```awk
int i = 42;
int *pi = 0;
int *pi2 = &i;
int *pi3; 
pi3 = pi2; // pi3和pi2指向同一个对象i
pi2 = 0;  // 指针赋值为0表示指针变为空指针

// 如何判别是改变了指针，还是指针所指的对象
pi = &ival; // 指针pi被改变，指向ival的地址
*pi = 0; // *pi表示解引用 改变的是pi所指对象的值
```

```sqf
// 赋值语句
    int test2 = 521;
    int *num2 = 0;
    cout << "num2初始化为空指针：" << num2 << endl;
    cout << "test2 : " << test2 << endl;
    num2 = &test2;
    cout << "num2赋值test2 : " << num2 << endl;
    cout << "test2 : " << test2 << endl;
    *num2 = 0;
    cout << "num2指向的对象赋值为0：" << num2 << endl;
    cout << "test2 : " << test2 << endl;
```

### 将指针用在条件表达式中

- 类似采用算术值作为条件遵循的规则：如果指针的值是0，条件取false；任何非0指针对应的条件值都是true
- 两个类型相同的合法指针，可以用相等操作符（==）或者不相等操作符（!=）进行比较，比较结果是布尔类型的。如果两个指针存放的地址值相同，则其相等；反之，不相等。指针相等的三种可能：（1）都为空 （2）都指向同一对象 （3）都指向了同一对象的下一地址。 
- 需要注意可能存在的情况：一个指针指向某对象，同时另一指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。



## 解析地址对象

如果指针指向了一个对象，则允许使用**解引用符（\*）来访问该对象**，如下：

```
int 	age = 19;
int*	p_age = &age;
*p_age  = 20;  			//通过指针修改指向的内存数据

printf("age = %d\n",*p_age);   	//通过指针读取指向的内存数据
printf("age = %d\n",age);
```

对于结构体和类，两者的差别很小，所以几乎可以等同，则使用->符号访问内部成员：

```
struct Student
{
    char name[31];
    int age;
    float score;
};

int main(void)
{
    Student stu = {"Bob" , 19, 98.0};
    Student*	p_s = &stu;

    p_s->age = 20;
    p_s->score = 99.0;
    printf("name:%s age:%d\n",p_s->name,p_s->age);
    return 0;
}
```

指针值的状态

指针的值（即地址）总会是下列四种状态之一：

    指向一个对象的地址
    指向紧邻对象所占空间的下一个位置
    空指针，意味着指针没有指向任何对象
    无效指针（野指针），上述情况之外的其他值

第一种状态很好理解就不说明了，第二种状态主要用于迭代器和指针的计算，后面介绍指针的计算，迭代器等整理模板的时候在介绍。

空指针：在C语言中，我们让指针变量赋值为NULL表示一个空指针，而C语言中，NULL实质是 ((void*)0) ， 在C++中，NULL实质是0。C++中也可以使用C11标准中的nullpte字面值赋值，意思是一样的。
任何程序数据都不会存储在地址为0的内存块中，它是被操作系统预留的内存块。

无效指针：指针变量的值是NULL，或者未知的地址值，或者是当前应用程序不可访问的地址值，这样的指针就是无效指针，不能对他们做解指针操作，否则程序会出现运行时错误，导致程序意外终止。

任何一个指针变量在做解地址操作前，都必须保证它指向的是有效的，可用的内存块，否则就会出错。坏指针是造成C语言Bug的最频繁的原因之一。

未经初始化的指针就是个无效指针，所以在定义指针变量的时候一定要进行初始化。如果实在是不知道指针的指向，则使用nullptr或NULL进行赋值。

指针之间的赋值

指针赋值和int变量赋值一样，就是将地址的值拷贝给另外一个。指针之间的赋值是一种浅拷贝，是在多个编程单元之间共享内存数据的高效的方法。

```
int* p1  = &a;
int* p2 = p1;
```

## 函数

### **函数的定义和使用**

```
在 C++ 中，函数是一组给定名称的语句。每个 C++ 程序都必须有一个主函数 main()，它是程序执行的起点。一个 C++ 程序由一个主函数和若干子函数组成。
```

### 函数的定义

C++ 中的函数分为 C++ 标准[库函数](https://so.csdn.net/so/search?q=库函数&spm=1001.2101.3001.7020)和自定义函数。使用标准库函数需要包含特定的头文件，比如使用 vector 功能时，需包含头文件 #include。而自定义函数是用户自定义命名和声明的一组语句，其基本结构为：.

```cpp
type name(parameter list){
    code
}
```

其中 type 为函数的返回值类型；name 为函数的名称，也是调用函数所使用的标识符；parameter list 为传递给函数的参数列表；code 为函数的主体，存放函数需要执行的语句。例如我们定义一个 add 函数：

```cpp
返回值类型 函数名 （参数列表）
{

       函数体语句

       return表达式

}
```

```cpp
int add(int a,int b){
    return a + b;
}
```

add 函数的功能是利用 return 关键字返回 a 加 b 的和。

函数的定义一般主要有5个步骤：

1、返回值类型 ：一个函数可以返回一个值。在函数定义中

2、函数名：给函数起个名称

3、参数列表：使用该函数时，传入的数据

4、函数体语句：花括号内的代码，函数内需要执行的语句

5、return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据

### 函数的声明和调用

#### 函数的声明

如果希望在定义函数前调用函数，则需要在调用函数前声明函数，其结构为：

    type name(parameter list);

其中 type 为函数的返回值类型；name 为函数的名称；parameter list 为传递给函数的参数列表。例如上例的 add 函数，如果要在定义 add 函数前调用 add 函数，则需要在调用此函数前，对函数进行声明：

    int add(int a,int b); //函数声明。
    int main(){
    调用 add 函数 //在未定义函数前调用函数。
    }
    int add(int a,int b){
    return a + b;
    } //定义函数
函数的调用

调用函数时，需暂停主调函数的执行，转入执行被调函数，当被调函数执行至 return 语句或函数末尾时，被调函数执行完毕，转回执行主调函数。可按如下格式调用函数：

    函数名(实参列表)

参数传递

一般有引用传递和值传递两种方式。
值传递复制一个形式参数，引用则传递其地址。
默认参数
可以在参数列表中可以直接确定参数的值。

```
#include<iostream>
using namespace std;

int add(int a,int b = 5){//变量 b 的值默认为 5。
    return a + b;
}

int main()
{
    int a,b;
    cout<<"input a b："<<endl;
    cin>>a>>b;
    cout<<"a + b(default) = "<<add(a)<<endl; //此时调用的 add 函数将 b 的值缺省，使之为默认参数。
    cout<<"a + b = "<<add(a,b)<<endl;
    return 0;
}
```

#### 函数声明与定义使用区别

```
//声明可以多次
int max(int a, int b);
int max(int a, int b);

//定义只能一次
int max(int a, int b)
{
	return a > b ? a : b;
}

int main() {

	int a = 100;
	int b = 200;

	cout << max(a, b) << endl;

	system("pause");

	return 0;
}
```



函数的声明可以多次，但是函数的定义只能有一次

为什么 C++ 允许多次声明呢？

比如一些函数已经包含在头文件了，但是依然可以在开头再次声明一些实际用到的函数。
这样有以下好处：

1、可以防止某些头文件中漏掉一些函数的声明；

2、这种方式使源代码更加清晰，特别是在庞大的工程中，更加有利于源代码的阅读。

3、有利于组内多人实时调整接口，等待模块写好之后，再将需要开放的接口一并写入头文件，方便各模块之间的开发，编译不依赖其他模

#### 五、分文件开发



1、后缀名为 .h 的头文件写函数的声明

2、后缀名为 .cpp 的源文件写函数的定义

```
//xxxx.h文件
#include<iostream>
using namespace std;

//写函数的声明
void xxxx(int a, int b);


//xxxx.cpp文件
#include "swap.h"

//写函数的定义
void xxxx(int a, int b)
{
	int temp = a;
	a = b;
	b = temp;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
}


//main函数文件，include 后即可直接使用 xxxx 函数
#include "xxxx.h"
int main() {

	int a = 100;
	int b = 200;
	xxxx(a, b);

	system("pause");

	return 0;
}

```

### 函数参数传递机制

一、 函数参数传递机制的基本理论

　　函数参数传递机制问题在本质上是调用函数（过程）和被调用函数（过程）在调用发生时进行通信的方法问题。基本的参数传递机制有两种：值传递和引用传递。以下讨论称调用其他函数的函数为主调函数，被调用的函数为被调函数。

　　值传递（passl-by-value）过程中，被调函数的形式参数作为被调函数的局部变量处理，即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。

　　引用传递(pass-by-reference)过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

二、 C语言中的函数参数传递机制

　　在C语言中，值传递是唯一可用的参数传递机制。但是据笔者所知，由于受指针变量作为函数参数的影响，有许多朋友还认为这种情况是引用传递。这是错误的。请看下面的代码：

```
#include<iostream>
using namespace std;
int swap(int *x, int *y)
{	
	int temp;	
	temp = *x; *x = *y; *y = temp;	
	return temp;	
}
int main()
{
	
	int a = 1, b = 2;	
	int *p1 = &a;	
	int *p2 = &b;
	swap(p1, p2);
	return 0;	
}
```

函数swap以两个指针变量作为参数，当main()调用swap时，是以值传递的方式将指针变量p1、p2的值（也就是变量a、b的地址）放在了swap在堆栈中为形式参数x、y开辟的内存单元中。

　**这里我们可以得到以下几点：**

　　1． 进程的堆栈存储区是主调函数和被调函数进行通信的主要区域。

　　2． C语言中参数是从右向左进栈的。

　　3． 被调函数使用的堆栈区域结构为：

　　　　局部变量（如temp）

　　　　返回地址

　　　　函数参数

　　　　低地址

　　　　高地址

　　4． 由主调函数在调用后清理堆栈。

　　5． 函数的返回值一般是放在寄存器中的。

　　**这里尚需补充说明几点：一是参数进栈的方式。**对于内部类型，由于编译器知道各类型变量使用的内存大小故直接使用push指令；对于自定义的类型（如structure），采用从源地址向目的（堆栈区）地址进行字节传送的方式入栈。**二是函数返回值为什么一般放在寄存器中**，这主要是为了支持中断；如果放在堆栈中有可能因为中断而被覆盖。**三是函数的返回值如果很大**，则从堆栈向存放返回值的地址单元（由主调函数在调用前将此地址压栈提供给被调函数）进行字节传送，以达到返回的目的。对于第二和第三点，《Thinking in C++》一书在第10章有比较好的阐述。四是一个显而易见的结论，如果在被调函数中返回局部变量的地址是毫无意义的；因为局部变量存于堆栈中，调用结束后堆栈将被清理，这些地址就变得无效了。

**三、 \**C++\**语言中的函数参数传递机制**

  众所周知，在c＋＋中调用函数时有三种参数传递方式：

 （1）传值调用；

 （2）传址调用（传指针）；

 （3）引用传递；

  实际上，还有一种参数传递方式，就是全局变量传递方式。这里的“全局”变量并不见得就是真正的全局的，所有代码都可以直接访问的，只要这个变量的作用域足够这两个函数访问就可以了，比如一个类中的两个成员函数可以使用一个成员变量实现参数传递，或者使用static关键字定义，或者使用namespace进行限制等，而这里的成员变量在这种意义上就可以称作是“全局”变量（暂时还没有其它比“全局”更好的词来描述）。当然，可以使用一个类外的真正的全局变量来实现参数传递，但有时并没有必要，从工程上讲，作用域越小越好。这种方式有什么优点呢？

 效率高！

 的确，这种效率是所有参数传递方式中效率最高的，比前面三种方式都要高，无论在什么情况下。但这种方式有一个致命的弱点，那就是对多线程的支持不好，如果两个进程同时调用同一个函数，而通过全局变量进行传递参数，该函数就不能够总是得到想要的结果。

 

### 内联函数

#### **什么是内联函数**

 

​     内联函数是C++的增强特性之一，用来降低程序的运行时间。当内联函数收到编译器的指示时，即可发生内联：编译器将使用函数的定义体来替代函数调用语句，这种替代行为发生在编译阶段而非程序运行阶段。

​     值得注意的是，内联函数仅仅是对编译器的内联建议，编译器是否觉得采取你的建议取决于函数是否符合内联的有利条件。如何函数体非常大，那么编译器将忽略函数的内联声明，而将内联函数作为普通函数处理。

```
Class A
{
 Public:
    inline int add(int a, int b)
    {
       return (a + b);
    };
}
Class A
{
 Public:
    int add(int a, int b);
};
inline int A::add(int a, int b)
{
   return (a + b);
}
```



#### **inline函数的优缺点分析**

 

   通过下面这些优缺点总结你大概会更理解为什么要使用inline函数：

优点：

1. 它通过避免函数调用所带来的开销来提高你程序的运行速度。
2. 当函数调用发生时，它节省了变量弹栈、压栈的开销。
3. 它避免了一个函数执行完返回原现场的开销。
4. 通过将函数声明为内联，你可以把函数定义放在头文件内。

缺点：

1. 因为代码的扩展，内联函数增大了可执行程序的体积。
2. C++内联函数的展开是中编译阶段，这就意味着如果你的内联函数发生了改动，那么就需要重新编译代码。
3. 当你把内联函数放在头文件中时，它将会使你的头文件信息变多，不过头文件的使用者不用在意这些。
4. 有时候内联函数并不受到青睐，比如在嵌入式系统中，嵌入式系统的存储约束可能不允许体积很大的可执行程序。



#### **什么时候该使用内联函数**

 

当程序设计需要时，每个函数都可以声明为inline。下面列举一些有用的建议：

1. 当对程序执行性能有要求时，那么就使用内联函数吧。
2. 当你想宏定义一个函数时，那就果断使用内联函数吧。
3. 在类内部定义的函数会默认声明为inline函数，这有利于 类实现细节的隐藏。

 

关键点

1.  内联声明只是一种对编译器的建议，编译器是否采用内联措施由编译器自己来决定。甚至在汇编阶段或链接阶段，一些没有inline声明的函数编译器也会将它内联展开。
2. 编译器的内联看起来就像是代码的复制与粘贴，这与预处理宏是很不同的：宏是强制的内联展开，可能将会污染所有的命名空间与代码，将为程序的调试带来困难。
3. 所有中类中定义的函数都默认声明为inline函数，所有我们不用显示地去声明inline。
4. 虚函数不允许内联。
5. 虽然说模板函数放中头文件中，但它们不一定是内联的。（不是说定义在头文件中的函数都是内联函数）。



# 面向对象

## 面向对象方法概述

### 主要特点

1. 抽象

   将一组同类对象的共同特征抽象出来，从而形成类的概念。类是对象的抽象，而对象是类的具体实例。

2. 封装

       对一个对象进行封装处理，就是把它的一部分属性和功能向外界屏蔽。也就是说把对象的内部实现和外部行为分隔开来。
       
       封装性是面向对象程序设计的一个重要特点，封装在此具有两个含义：
       
       把有关的数据和函数封装在一个对象里，形成程序中的一个基本单位，各个对象之间互不干扰。
       
       把对象中的某些部分对外屏蔽，只留下与外界联系的接口接收外界消息称之为信息屏

3. 继承

   简单来说就是在之前建立的类的基础上增加新函数功能，从而变成一个新的类。

4. 多态

在C++中的多态性是指，由继承产生的新类，它的对象对同一个消息会作出不同的响应。例子就是一个可执行文本点击执行就是执行文件中的程序，如果这个可执行文本改成文本文件，则会启动一个编辑器来打开它。

# 三、类和对象的作用

类是C++的灵魂，它是实现面向对象程序设计的基础。

C++支持面向过程的程序设计，也支持基于对象和面向对象的程序设计。

基于对象就是基于类，基于对象的程序就是以类和对象为基础的，程序的操作是围绕对象进行的，再利用继承机制和多态性就成为了面向对象的程序设计。

把一组数据和函数放在一起，这就是面向对象程序设计中的对象。

程序=数据结构+算法

面向过程的程序设计是以数据结构为基础的算法设计。面向对象程序设计就是把一个算法和一组数据结构封装在一个对象中。

对象=数据结构+算法

程序=（对象+对象+...+对象）+消息，消息的作用就是对对象进行控制，以及确定向对象发出的命令，让对象完成相应的任务

## 软件开发

    面向对象分析
    
    面向对象的分析就是从客观事物和事物之间的关系归纳出有关对象以及对象之间的联系，并将具有相同属性和行为的对象用一个类来表示。
    
    面向对象的设计
    
    依照需求首先进行类的设计，然后以这些类为基础提出程序设计的思路和方法。
    
    面向对象编程
    
    C++、Dephi、VB、Java
    
    面向对象的测试
    
    就是以类为测试的基本单元用面向对象的方法实施测试。
    
    面向对象维护
    
    就是维护而已，因为类对其他子类的影响小，所以方便。
# 第二节 类的声明和对象的定义

### 类和对象的关系

- 类（class）是对象的抽象，不占用内存空间。对象是类的具体事例，占用内存空间。类是对象的类型。

### 声明类类型

- 类是要用户自己定义的类型，声明一个类类型与声明一个结构体类型相似。

### 声明访问限定符



> public：
>
> > 修饰的成员在类外可以被直接访问；
>
> private：
>
> > 修饰的成员在类外不能被直接访问；
>
> protected：
>
> > 修饰的成员在类外不能被直接访问；
> >  （此处的 private 和 protected 是类似的）

- public：可以被该类中的函数、子类的函数、友元函数访问，也可以由该类的对象访问；
- protected：可以被该类中的函数、子类的函数、友元函数访问，但不可以由该类的对象访问；
- private：可以被该类中的函数、友元函数访问，但不可以由子类的函数、该类的对象、访问。

说明：

        访问权限的作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止；
        class 的默认访问权限是：private；
        struct 的默认访问权限是：public（因为 struct 要兼容C）；

注意：

    访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别。

### 定义对象方法

**(1)** **先声明类类型，然后再定义对象**

```
//定义student类;

class student //以class 开头

{

public:

//定义成员变量

    char name[32]; //姓名

    char addr[32]; //家庭地址

    long long number; //电话号码

public:

//定义成员函数

    void print()    //输出成员的信息

    {

        cout << "name = " << name << endl;

        cout << "addr = " << addr << endl;

        cout << "number = " << number << endl;

    }

};

student stud1, stud2;   //定义了两个student类的对象stud1和stud2
```

在声明类类型的同时定义对象

```
在定义class类的时候，在定义类的末尾，定义类对象。

//定义student类;

class student //以class 开头

{

public: //定义成员变量

    char name[32]; //姓名

    char addr[32]; //家庭地址

    long long number; //电话号码

public: //定义成员函数

    void print()    //输出成员的信息

    {

        cout << "name = " << name << endl;

        cout << "addr = " << addr << endl;

        cout << "number = " << number << endl;

    }

} stud1, stud2; //定义了两个student类的对象stud1和stud2

       可以看到，在定义student类的末尾，定义了stud1和stud2对象。这种方式，C语言的struct类型也支持。
```

**定义匿名类，不出现类名，直接定义对象**

```
class      //没有类名

{

public: //定义成员变量

    char name[32]; //姓名

    char addr[32]; //家庭地址

    long long number; //电话号码

public: //定义成员函数

    void print()    //输出成员的信息

    {

        cout << "name = " << name << endl;

        cout << "addr = " << addr << endl;

        cout << "number = " << number << endl;

    }

} stud1, stud2; //定义了两个类的对象stud1和stud2
```

此时，定义一个匿名类。就是没有类名的类。定义匿名类的同时，定义匿名类对象。

       定义匿名类，在C++中是合法的，允许的，但却很少用，也不提倡用。因为在面向对象程序设计和C++程序中，类的声明和类的使用是分开的，类并不只为一个程序服务，人们常把一些常用的功能封装成类，并放在类库中。因此，在实际的程序开发中，一般都采用上面3种方法中的第一种方法。在小型程序中或所声明的类只用于本程序时，也可以用第二种方法。
    
       在定义一个对象的时候，编译系统会为这个对象分配存储空间，用来存放对象中的成员。
## 类的成员函数

定义

```
函数的定义一般在类外面，也可以直接在类内部定义。
   前者与普通函数不同的是，实现成员函数时要指明类的名称，具体形式为：
```

- 返回值类型 类名::函数成员名(参数表){函数体};
- 而后者一般为一些短小的函数（5行以内），也就是内联函数。

各类函数中：构造函数、[析构函数](https://so.csdn.net/so/search?q=析构函数&spm=1001.2101.3001.7020)、拷贝初始化构造函数等是类的成员函数。

```cpp
class A　
{　
public:
　void B();

private:

　int C();
protected:

　bool D(int i);　
};　
//那么，B(),C(),D(int)都是A的成员函数

```

类的大小

```
成员函数不会影响类的结构体大小，类的大小只计算类内部的成员变量。
    空类的字节大小为一个字节，因为类本身需要也需要一个字节来保证这个类能被声明和调用。
```



成员函数的作用域

```
类的成员函数想要定义在类的外部时，可以使用 ”函数的类型 类名 ：：函数名“  的方式
  来进行类的外部定义。
  注意，类的成员函数要定义在类的外部时，需要在类的内部声明这个函数才可以在外部定义。
```

```cpp
//示例：
class A
{
private:
	int a;
public:
	int Add(int b);
}

int A:: Add(int b)
{
	return a + b;
}
```



内联成员函数(inline)

```
内联函数推荐写在头文件中。
```



内联函数的重写原则：内联函数在声明时未使用 inline关键词，但是在定义时使用了 inline 关键词这个函数还是会被定义为内联函数。



```cpp
class B
{
private:
   int a;
public:
	int Add(int b);
}

inline int B::Add(int b)
{
	return a + b;
}
```

> const 对象

```
 const 修饰的对象不能修改其成员变量的值。const对象只能调用 const修饰过的成员函数。
```

> const 原则

```
 const对象不能以任何方式改变，这是const的原则，在这个基本的原则下，产生了一系列效应，比如 const对象只能调用const成员函数；

  另外一个我们不注意的变化是，在const成员函数中，this指针也变成了const指针。
```



const 类型转换

```cpp
//语法：
const_cast<类型>(变量);
Role user;
const_cast<Role*>(puser);
```



# 类的成员函数：

1. 类的成员函数的声明和定义与普通函数基本一样。
    函数声明的一般形式为：

   ```cpp
   函数类型 函数名(参数表);
   ```

```
#include <iostream>
using namespace std;

class Time // 声明类类型
{
private: // 声明私有部分
	int hour;
	int minute;
	int sec;

public: // 声明公用部分
	void set_time(void) // 类体内定义成员函数
	{
		cin >> hour;
		cin >> minute;
		cin >> sec;
	}

	void show_time(void) // 类体内定义成员函数
	{
		cout << hour << ":" << minute << ":" << sec << endl;
	}

};

Time t; // 定义Time类的对象t

int main()
{
	t.set_time(); // 调用对象t的成员函数set_time，向t的数据成员输入数据
	t.show_time(); // 调用对象t的成员函数show_time，输出t的数据成员的值
	system("pause");
	return 0;
}
```

在类体内定义函数时，不需要在函数名前面加上类名；但成员函数在类外定义时，必须在函数名前面加上类名，予以限定。
 比如：



```cpp
void Time::show_time(void)
{
	cout << hour << ":" << minute << ":" << sec << endl;
}
```

在 Time 类外定义成员函数 show_time ，需要在前面加上 Time:: 来限定属于哪个类。

    类的成员函数必须先在类体内声明原型。
    
    在类体内声明成员函数，在类外定义成员函数，是程序设计的一种良好习惯。
    
    如果在类体中定义的成员函数不包括循环等控制结构，C++系统会自动地对它们作为内置(inline)函数来处理。在类体内定义的函数，一般都省略inline。
    
    在类体内直接定义函数时，不需要在函数名前面加上类名；如果在类外定义函数，必须在函数名前面加上类名，限定函数所属的类。
    
    在类外成员函数引用本对象的数据成员时，只需写数据成员名，不需要加类名限定。 
内置成员函数

在类中定义的函数一般规模较小，而系统调用函数的过程所花费的时间开销相对是比较大的。调用一个函数的时间远远大于小规模函数体中的全部语句的执行时间。

为了减少时间开销，如果在**类体**中定义的成员函数不包括**循环等控制结构**，C++系统就会把它们作为内置函数处理。

- 对于一般的函数，需要显式使用`inline`关键字声明，但对于类内定义的成员函数，可以省略`inline`，因为这些成员函数已被隐含地指定为内置函数。



```cpp
class Student {
public:
    void display() {
        cout << age << " " << num << " " << name << endl;
    }
private:
    int num;
    int age;
    string name;
};
```

两段代码对`display`函数的定义等效。

```cpp
class Student {
public:
    inline void display() {
        cout << age << " " << num << " " << name << endl;
    }
};
```

```cpp

```

- 对于类体外定义的成员函数
   系统不会把它默认为内置函数，调用这些成员函数和调用一般函数一样。可以使用`inline`显示声明这些成员函数为内置函数。

```cpp
class Student {
public:
    void display();
private:
    int num;
    int age;
    string name;
};

inline void Student::display() {
    cout << num << age << name << endl;
}
```



成员函数存储方式



用类去定义对象时，系统会为每一个对象分配存储空间。如果一个类包括了数据和函数，要分别为数据和函数的代码分配存储空间。按理说，如果用同一个类定义了10个对象，那么就需要分别为10个对象的数据和函数代码分配存储单元，如下图所示。



显然，这样做会大大节约存储空间。C++编译系统正是这样做的，**因此每个对象所占用的存储空间只是该对象的数据部分（虚函数指针和虚基类指针也属于数据部分）所占用的存储空间，而不包括函数代码所占用的存储空间**。

​    看如下测试代码：



```{  
public:  
    void printA()  
    {  
        cout<<"printA"<<endl;  
    }  
    virtual void printB()  
    {  
        cout<<"printB"<<endl;  
    }  
};  
int main(void)
{
	D *d=NULL;
	d->printA();
	d->printB();
}
```



C++程序的内存格局通常分为四个区：全局数据区(data area)，代码区(code area)，栈区(stack area)，堆区(heap area)(即自由存储区)。全局数据区存放全局变量，静态数据和常量；所有类成员函数和非成员函数代码存放在代码区；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区。根据这个解释，我们可以得知在类的定义时，类成员函数是被放在代码区，而类的静态成员变量在类定义时就已经在全局数据区分配了内存，因而它是属于类的。对于非静态成员变量，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是属于对象的。

        应当说明，常说的“某某对象的成员函数”，是从逻辑的角度而言的，而成员函数的存储方式，是从物理的角度而言的，二者是不矛盾的。
    
        下面我们再来讨论下类的静态成员函数和非静态成员函数的区别：静态成员函数和非静态成员函数都是在类的定义时放在内存的代码区的，因而可以说它们都是属于类的，但是类为什么只能直接调用静态类成员函数，而非静态类成员函数(即使函数没有参数)只有类对象才能调用呢？原因是类的非静态类成员函数其实都内含了一个指向类对象的指针型参数(即this指针)，因而只有类对象才能调用(此时this指针有实值)。

























# C++访问对象成员

1. **通过对象名和成员运算符访问对象中的成员；**

   ```
   #include <iostream>
   using namespace std;
   class Tclass {
   
   	public:
   		int x, y;
   
   		void Print() {
   			cout << "x=" << x << '\t'
   			     << "y=" << y << endl;
   		}
   };
   
   int main()
   
   {
   	Tclass test;
   	test.x = 100;
   	test.y = 10;
   	test.Print();
   	return 0;
   }
   ```

   

2. **通过指向对象的指针访问对象中的成员；**

   ```
   #include <iostream>
   using namespace std;
   class Tclass {
   
   	public:
   		int x, y;
   
   		void Print() {
   			cout << "x=" << x << '\t'
   			     << "y=" << y << endl;
   		}
   };
   int adds(Tclass * ptf) {
   	return (ptf->x + ptf->y);
   }
   int main()
   
   {
   	Tclass test, *pt = new Tclass();
   	pt->x = 10;
   	pt->y = 100;
   	test.x = 100;
   	test.y = 10;
   	test.Print();
   	cout <<"x+y=" << adds(&test);
   	return 0;
   }
   ```

   

3. **通过对象的引用变量访问对象中的成员。**

4. **公有成员是提供给外部的接口**

5. **类外用"."****和"->"****运算符访问对象成员**



























c++封装

## 公用接口与私有实现的分离

   通过前面的学习，我们知道C++通过类来实现封装性，把数据和与这些数据有关的操作封装在一个类中。在面向对象编程中，在声明类时，一般都是把所有的数据指定为私有的，使它们与外界隔离。把需要让外界调用的成员函数指定为公用的，外界通过公用的函数来实现对数据的操作。外界与对象唯一的联系渠道就是调用公用的成员函数。这样就使类与外界的联系减少到最低限度。如下是一个测试例子

```
#include <iostream>
using namespace std;

class Time {

	public:
		void set_time();
		void show_time();
	private:
		int hour, minute, sec;
};

void Time::set_time() {
	cin >> hour >> minute >> sec;
}

void Time::show_time() {
	cout << hour << ":" << minute << ":" << sec << endl;
}
int main() {

	Time t1, t2;
	t1.set_time();
	t1.show_time();
	t2.set_time();
	t2.show_time();
	return 0;

}
```




# 如何使函数内联

定义函数时，在函数的最前面以关键字“inline”声明函数，即可使函数称为内联声明函数。

例如：

### **带默认形参值的函数**

```
#include<iostream>

int sum(int a, int b)
{
	return a + b;
}
int main()
{
	int a = 10;
	int b = 20;
	int ret = sum(a, b);
	std::cout << "ret:" << ret << std::endl;
	return 0;
}
```

sum函数的定义可以有以下几种：



    int sum(int a=10,int b=20);
    sum();
    
    int sum(int a,int b=20);
    sum(a);

**但是int sum(int a,int b=20)** ;不可以编译通过，原因是函数压栈是从右向左入栈，给默认值的时候从右向左给。



int sum(int a=10, int b=10)
{
	return a + b;
}
int main()
{
	int a = 10;
	int b = 20;
	int ret = sum(a,b);
	
	//mov eax,dword ptr[ebp-8]
	//push eax
	//mov ecx,dword ptr[ebp-4]
	//push ecx
	//call sum
	
	std::cout << "ret:" << ret << std::endl;
	
	//push 14H
	//mov ecx,dword ptr[ebp-4]
	//push ecx
	//call sum
	
	ret = sum(a);
	
	//push 14H
	//push 0Ah
	//call sum
	return 0;
}总结:
形参带默认值的函数
1，给默认值时，自右向左给；
2，调用形参带默认值的函数与普通函数的效率有提升，但个别情况效率会和原来一样，但效率不会降低；
3，定义处和声明处都可以给形参默认值；
4，形参给默认值时，不管是定义出给，还是声明处给，形参默认值只能出现一次，就算默认值相同也不可以。

### **带缺省形参值的函数**

### **函数重载**

C++允许功能相近的函数在相同的[作用域](https://so.csdn.net/so/search?q=作用域&spm=1001.2101.3001.7020)内以相同函数名声明，从而形成重载。方便使用，便于记忆。

例：

> 1. 形参类型不同
> 2. 形参个数不同
> 3. 形参顺序不同

指的是函数同名的情况，这种情况下我们往往通过函数参数的个数形式来区分。

```
#include<iostream>
using namespace std;

int add(int a,int b){ //定义整型函数 add。
    int c;
    c = a - b;
    return c;
}

double add(double a,double b){ //定义双精度型函数 add。
    double c;
    c = a + b;
    return c;
}

int main()
{//函数重载。
    cout<<"a + b = "<<add(3,4)<<endl;//调用整型函数 add。
    cout<<"a + b = "<<add(3.111,4.222)<<endl;//调用双精度型函数 add。
}

```

## 类和对象

### 类的引入

在C语言阶段,struct关键字用来构造用户自定义数据类型,只能用来定义变量,C++把struct升级成了类,既能定义变量,又能定义函数,同时兼容C语言struct结构体的所有用法,类由两部分组成,一部分是成员变量(属性),另一部分是成员函数(用来对成员变量进行操作)

C++中struct和class都能定义类,它们的区别是什么呢?

C++的struct是兼容C语言的,所以C++的struct可以当作结构体去使用,另外struct还可以用来定义类,和class定义类是一样的,区别是struct定义类默认访问权限是公有的,class定义类默认访问权限是私有的

```
typedef int STDataType;
struct Stack
{
	// 定义成员函数
	void StackInit(int initcapacity = 4)
	{
		_a = (int*)malloc(sizeof(int) * initcapacity);
		_size = 0;
		_capacity = initcapacity;
	}
	void StackPush(STDataType x)
	{
		_a[_size++] = x;
	}
	// 定义成员变量
	STDataType* _a; // 成员变量在这里是声明
	int _size;
	int _capacity;
};
int main()
{
	Stack st; // 这里是定义
	st.StackInit(10);
	st.StackPush(1);
	st.StackPush(2);
	st.StackPush(3);
}
```

### 类的定义

```cpp
class 类名
{
	类体 // 定义成员函数和成员变量
};
```

类的两种定义方式 :

一.声明和定义全部放在类内

```c++
class Stack
{
public:
	void StackInit(int capacity = 4)
	{
		_a = (int*)malloc(sizeof(int) * capacity);
		_size = 0;
		_capacity = capacity;
	}
private:
	int* _a;
	int _size;
	int _capacity;
};



```

二.声明和定义分开,声明在类内,定义在类外,在类外定义的时候记得加上域作用限定符

```c++
class Stack
{
public:
	void StackInit(int capacity = 4);
private:
	int* _a;
	int _size;
	int _capacity;
};
void Stack::StackInit(int capacity)
{
	_a = (int*)malloc(sizeof(int) * capacity);
	_size = 0;
	_capacity = capacity;
}
```

### 类的访问限定符和封装

封装 :
在C语言阶段,数据和方法是分离开来的,使用方法可以去修改数据，但这样会破坏原有的数据,因此C++引入了封装
封装本质上是一种管理,封装把数据和方法封装到一起,隐藏对象的属性和实现细节,仅提供对外接口来实现和对象的交互

访问限定符 : public,protected,private

(1). public修饰的成员在类外可以直接被访问
(2). protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的)
(3). 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止
(4). class的默认访问权限为private，struct为public(因为struct要兼容C)

### 四.类的实例化和类对象模型

用类类型创建对象的过程，称为类的实例化
(1). 类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它
(2). 一个类可以实例化出多个对象，实例化出的对象占用实际的物理空间，存储类成员变量,类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间

类对象的存储方式 :

对象保存成员变量，成员函数存放在公共代码段

```
// 类中既有成员变量，又有成员函数
class A1
{
public:
 	void f1()
 	{}
private:
 	int _a;
};
// sizeof(A1) = 4

// 类中仅有成员函数
class A2
{
public:
 	void f2()
 	{}
};
// sizeof(A2) = 1

// 类中什么都没有---空类
class A3
{};
// sizeof(A3) = 1

```

注意当类中无成员函数时,类的大小不是0，而是1,因为我们用类去实例化多个对象出来时，为了区分这些对象,需要给一个字节去唯一标识对象



### 类的作用域与实例化

#### 1.类的作用域

类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用作用域解析符：：指明成员属于哪个类域。

```
class Person
{
public:
 void PrintPersonInfo();
private:
 char _name[20];
 char _gender[3];
 int _age;
};
// 这里需要指定PrintPersonInfo是属于Person这个类域
void Person::PrintPersonInfo()
{
 cout<<_name<<" "_gender<<" "<<_age<<endl; 
}

```



#### 类的实例化

类的实例化：用类类型创建对象的过程

对象是对类具体的一个体现，即实体。

1.类类似一个模型，限定了类有哪些成员，定义一个类并没有分配实际的内存空间来存储它

2.一个类可以实例化多个对象，实例化出的对象，占用实际的物理空间，存储类成员变量

3.做个比方。**类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图**，只设计出需要什
 么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占
 用物理空间

```
#include <iostream>
using namespace std;

class Date {
	
public:
	int day;
	int month;
	int year;
};

int main()
{
	Date day1;
	day1.day=20;
	day1.month=10;
	day1.year=3;
} 
```

**内联成员函数** 

类中的成员函数分为一般成员函数和内联成员函数。

把成员函数的代码放入类声明中，这种方式定义的类成员函数就叫内联成员函数(隐式定义)。程序使用内联成员函数的方式与一般的成员函数的调用方式一样。内联函数和外联函数之间的区别在于：定义一个内联函数时，编译器会把内联函数的代码替换到程序中(这样代码效率要高些)。使用非内联函数时，就不会这样做。

```
#include <iostream>
using namespace std;

inline int Max(int x, int y) {
	return (x > y) ? x : y;
}

// 程序的主函数
int main( ) {

	cout << "Max (20,10): " << Max(20, 10) << endl;
	cout << "Max (0,200): " << Max(0, 200) << endl;
	cout << "Max (100,1010): " << Max(100, 1010) << endl;
	return 0;
}
```

引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：

- 1.在内联函数内不允许使用循环语句和开关语句；

- 2.内联函数的定义必须出现在内联函数第一次调用之前；

- 3.类结构中所在的类说明内部定义的函数是内联函数。

-  只有当函数只有 10 行甚至更少时才将其定义为内联函数.

- 定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.

- 

  优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.

  缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。

  结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!

  另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).

  有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单,  比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便,  抑或是当作文档描述其行为, 比如精短的存取函数.

### 对象指针

#### 对象指针的一般概念

**对象指针：指向类的成员的指针。在C++中，可以说明指向类的数据成员和成员函数的指针。**
 对象指针遵循一般变量指针的各种规则：类名 **对象指针名；*
 对象指针名*成员名；
 对象指针在使用之前，也一定要先进行初始化，让它指向一个已经声明过的对象，然后再使用。通过对象指针，可以访问到所指向对象的公有成员。



#### 指向对像的指针

在建立对像时，编译系统会为每一个对像分配一定的存储空间，以存放其成员，对像空间的起始地址就是
 对像的指针。可以定义一个指针变量，用来存和对像的指针。如果有一个类：

### 五.this指针

```
class Date
{
public:
	void Init(int year = 0,int month = 1,int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1;
	d1.Init(2021,5,29);
	
	Date d2;
	d2.Init(2021,5,30);
}

```

对于上面的类,有这样一个问题 :

d1和d2调用的函数都是同一个位于公共代码区的函数Init(),但Init()函数怎么知道是哪个对象调用的它呢?

C++通过引入了this指针来解决这个问题,C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。

因此上面的函数调用编译器会处理为如下

```
d1.Init(&d1,2021,5,29);
d2.Init(&d2,2021,5,30);

void Init(Date* this,int year = 0,int month = 1,int day = 1)
{
		this->_year = year;
		this->_month = month;
		this->_day = day;
}
```

this指针的特性 :
(1). this指针的类型：类类型* const
(2). 只能在“成员函数”的内部使用
(3). this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this形参。所以对象中不存储this指针,this指针存储在栈中
(4). this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递.

了解了this指针之后，我们来看一道题

struct 和 class

    struct 是C 中用户自定义类型，主要功能是对功能相关数据的封装
    struct 不能直接封装函数，但可以通过封装函数指针来间接封装函数
    struct 就是 class 的初级阶段，class 在 struct 基础上做了很多扩展，便有了面向对象

访问权限

    类是对数据（成员变量）和方法（成员函数）的封装
    封装的一个重要特征就是访问权限管控，本质是为了隐藏实现细节，避免意外篡改
    C++ 支持三个访问管控级别：private、protected、public

C++的对象创建和销毁

    对象的本质等同于C中的变量，对象的创建和销毁也就是变量的产生和销毁，本质上是变量对应的内存地址的分配和释放。
    C中的全局变量和局部变量都是自动分配和回收内存的，堆内存需要用户手动申请和释放（malloc和free调用）
    C++ 中因为变量升级成了对象，涉及到构造函数和析构函数，因此 malloc 和free 升级为了 new 和 delete
    C++ 中仍然大量使用全局变量和局部变量，但是动态分配占比越来越多。这是业务特点决定的，不是C++语言决定的。语言只是提供机制，业务才决定策略。

二、C++中 static 和 this 关键字

static 在C 中的用法

    静态全局变量和函数，限制链接属性（只能在当前C文件中使用）。C++中建议优先使用命名空间机制替代
    静态局部变量，更改地址域和生命周期（随程序终止而终止）。C++中继续沿用

static 在 C++中新增用法

    用在 class 中，有静态数据成员 和 静态成员函数
    简单理解：静态成员和方法都是属于 class 的，而非静态是对于对象的（只有对象才能调用）
    静态类往往用在单例模式中，实际上和面向对象的思想有所差异

this 关键字

    本质是个指针，指向当前对象
    this 的主要作用是让我们在未定义对象前可以在方法中调用对象里的成员

static和this的使用demo

```
#include <iostream>
using namespace std;

class A {
	public:
		// 成员变量
		int i;
		// 成员函数 方法
		void func1(void);
		// 静态成员变量
		static int j;
		// 静态成员方法
		static void func2(void);		// static是一个声明性的
};

void A::func1(void) {
	//	cout << "A::func1, i = " << i << endl;		// 成员函数中访问成员变量，等同于下面
	cout << "A::func1, i = " << this->i << endl;
}

void A::func2(void) {
	cout << "A::func2" << endl;
}

```





### 类的访问限定符及封装

#### 访问限定符

> C++实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其
>  接口提供给外部的用户使用。

【访问限定符说明】

    public修饰的成员在类外可以直接被访问
    protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的)
    访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止
    class的默认访问权限为private，struct为public(因为struct要兼容C)
#### 封装

面向对象的三大特性：封装、继承、多态。

封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。

封装本质上是一种管理。

**类的实例化分为两种方式：**

  ***1.从栈实例化对象\***

```cpp
class lwx{

	public:

		int age;
		int num;

};

int main()

{
	lwx ar[3];
	ar[1].age = 10;

	cout<<ar[1].age<<endl;

	return 0;


}
```

> ***创建完成后每一个数组元素都可以访问各自的成员，使用完后直接销毁\***

***2.从堆中进行实例化***

```cpp
class lwx{



	public:



		int age;



		int num;



};



 



int main()



{



	lwx *p = new lwx[3];



	p[0].age = 10;



	p->age = 10;



	delete []p;



	p=NULL;



	return 0;



}
```

### •**类作用域、类类型的作用域和对象的作用域** 

#### 1.函数原型作用域：

此作用域为c++程序中最小的作用域，生存周期最短。

例：int func（int i） i为参数，作用域类型为函数原型类型。

#### 2.局部作用域：与C语言类似；

函数体或某一个模块中的变量，其作用域从声明开始，一直到声明所在的块结束为止。

#### 3.类的作用域

类中的所有成员在类外使用时需要用 :: [作用域](https://so.csdn.net/so/search?q=作用域&spm=1001.2101.3001.7020)限定符来使用

```
class A{
 public:
	void Set(int,int);
	int print();
 private:
	int _year;
 	int _day;
};
void A::Set(int year,int day)
{
	_year = year;
	_day = day;
}
int A::print()
{
cout<<_year<<"-"<<_day<<endl;

```

一个类也就是一个作用域

在声明一个类之后，也就是在类中是一个独立的作用域，可以使用作用域符号::来知名是哪个作用域的。

```
class Person 
{ 
	public:  
		void PrintPersonInfo(); 
	private: 
  		char _name[20];  
  		char _gender[3];  
  		int  _age; 
};
//这里需要指定PrintPersonInfo是属于Person这个类域 
void Person::PrintPersonInfo() 
{
cout<<_name<<" "_gender<<" "<<_age<<endl; 
}
```



类中的数据和函数分为公有类（public），保护类（protected），私有类（private），

类公有派生类，保护派生类，私有派生类

类中的成员 在public中 ，可以在其他地方直接使用  使用方法：对象.公用类成员（对象：：公用类成员）

而其他的需要借助公有类函数调用 ，但是在类中可以直接调用 。

例： class x的对象X的成员m具有类作用域，对m的访问有三种

（1）如果 在X的成员函数中没有声明 同名 的局部作用域标识符，那么可以在该函数内可以直接访问成员m。

（2）通过表达式x.m或者x::m。这正是程序中访问对象的最基本的方法

（3）通过ptr->m这样的表达式，其中ptr为指向x类的一个对象的指针。

#### 4.命名空间作用域

命名空间的语法为

namespace 命名空间名{

各种声明（class的声明，函数的声明，变量的声明，常量的声明………）}

如何引用呢？ 命名空间名：：标识符名

例：namespace WA{    class A;    }        引用: namespace WA::A；    using namespace WA；  using WA：：A;

命名空间分为三类：1.显示   在某某命名空间中

                                    2.全局命名空间        在using   namespace std；下进行命名，也可以叫做全局变量 为static 储存类型
    
                                    3.匿名命名空间              例：namespace{   class A；  }
# 变量作用域

## 1. C++变量根据定义位置的不同，具有不同的作用域，

作用域可分为6种：全局作用域，局部作用域，语句作用域，类作用域，命名作用域和文件作用域。

## 2.从作用域看：

全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包括全局变量定义的源文件需要用extern关键字再次声明这个全局变量。

静态局部变量具有局部作用域。它只被初始化一次，从第一次初始化直到程序运行结束都一直存在，他和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。

局部变量也只有局部作用域，他是自动对象，他在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用结束后，变量就被撤销，其所占用的内存也被收回。

静态全局变量也具有全局作用域，他与全局变量的区别在于如果程序包含多个文件的话，他作用于定义它的文件里，不能作用到其他文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同的静态全局变量，他们也是不同的变量。

## 3.从分配内存空间看：

全局变量、静态局部变量、静态全局变量都在静态存储区分配空间，而局部变量在栈分配空间。

全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上没有什么不同。区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。

1、静态变量会被放在程序的静态数据存储区里，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是他与堆栈变量和堆变量的区别

2、变量用static告知编译器，自己仅仅在变量的作用域范围内可见。这一点是他与全局变量的区别。

从以上分析可以看出，把局部变量改变为静态变量后是改变了他的存储方式，即改变了他的生存期。把全局变量改变为静态变量后是改变了他的作用域，限制了他的使用范围，因此static这个说明符在不同的地方起的作用是不同的。

TIPS：

1、若全局变量仅在单个文件中访问，则可以讲这个变量修改为静态全局变量。

2、若全局变量仅在单个函数中使用，则可以将这个变量修改为该函数的静态局部变量。

3、全局变量、静态局部变量、静态全局变量都存放在静态数据存储区。

4、函数中必须要使用static变量的情况：当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

方法作用域
局部变量

范围：在一个函数内部定义的变量，作用范围只限于本函数体内。

生存期：程序执行到本函数才会给局部变量分配内存单元，函数执行完毕局部变量所占的存储单元就被释放
静态局部变量

范围：函数体内，离开函数体就不起作用，但是值仍然被保留，下次被调用的时候使用的是上次的值

生存期：在编译阶段赋值，从程序运行开始就被分配固定的存储单元（静态存储区），整个程序运行期间不再重新分配，生存周期是整个程序运行期间

```
#include<iostream>
using namespace std;
 
int calltimes(){
    static int i=0;
    i++;
    cout<<"The function has been called "<< i <<" times!" <<endl;
}
 
int main(){
 
    calltimes();
    calltimes();
    calltimes();
    calltimes();
    system("pause");
    return 0;
}
```

全局变量

在函数体外部定义的变量是全局变量，可以被本文件所有其他函数访问使用。

作用域：所有文件。在一个cpp定义的全局变量在另一个cpp中使用，应该在使用它的函数体内部或外部进行extern说明

生存期：全局变量在程序的全部执行过程中占用固定的内存单元，生存周期是整个程序运行期间。

静态全局变量

作用域：定义它的cpp文件，而不是程序中的所有cpp文件

生存期：整个程序运行期间

不同cpp文件可以使用相同名称的静态全局变量名互不干扰

```
variable.cpp
static int i=10;
int j=100;
 
main.cpp
#include <cstdlib>
#include <iostream>
#include "test.h"
using namespace std;
//extern int i; //由于在variable.cpp中i是静态成员，所以即使加了extern声明也不能访问到，编译不成功
extern int j;//只有加extern声明才能访问到variable.cpp中的全局变量j
int main(int argc, char *argv[])
{
   // cout<<i<<endl;
    cout<<j<<endl;
    system("PAUSE");
    return EXIT_SUCCESS;
}
 
输出：
 
100
```

### static函数

静态函数只能被所在的cpp文件调用，不同cpp文件可以有相同的静态函数名字。

### 可被其他文件调用的函数

调用方式有两种

第一引入函数所在头文件，第二在调用函数前进行extern声明

```cpp
test.h
#include<iostream>
using namespace std;
int sum1(int,int);
static int sum2(int, int);
int sum3(int,int);
 
test.cpp
#include "test.h"
 
int sum1(int x, int y){
    cout<<"sum 1 calculating ...."<<endl;
    return x+y;
}
 
static int sum2(int x, int y){
    cout<<"static sum 2 calculating ...."<<endl;
    return x+y;
}
 
int sum3(int x, int y){
    cout<<"sum 3 calculating ...."<<endl;
    return sum2(x,y);
}
 
main.cpp
#include <cstdlib>
#include <iostream>
#include "test.h"
using namespace std;
 
int main(int argc, char *argv[])
{
    //extern int sum1(int,int);//如果不加test.h头文件引用，进行extern声明同样可以调用sum1
    cout<<sum1(1,2)<<endl;    
    //cout<<sum2(1,2)<<endl; //sum2是静态函数，不能调用     
    cout<<sum3(1,2)<<endl;   // sum3与sum2在同一个cpp文件中，sum3可以调用sum2   
    system("PAUSE");
    return EXIT_SUCCESS;
}
```

## 类的嵌套

### 1.作用域

```bash
	如果一个嵌套类在另一个类的私有部分声明的，嵌套类对于这个类是可见的，对于外界是不可见的。
	如果一个嵌套类在另一个类的公有部分声明的，则允许在这个类和外界使用这个嵌套类。
```

### 2.访问权限

```bash
	嵌套类的私有部分不允许在声明嵌套类中的这个类访问
```

### **3.嵌套类的作用域（可见性）**

**嵌套类的作用域与定义的位置有关**

**声明在私有区域(private)**

仅在外围类内部可见

也就是说，这种情况下，嵌套类的实例化对象可以当作外围类的数据成员，也可当作外围类的成员函数的参数或者在成员函数内部实例化。

```
class Outer {
private:
    class Inner {
        ...
    };
 
    Inner objInner;     //第一处
    ...
public:
    void f(Inner &Inner);   //第二处
    void g();
    ...
};
 
void Outer::g() {
    Inner objInner;     //第三处
    ...
}
```

第一处：嵌套类的实例化对象作为**外围类的成员**
 第二处：嵌套类的实例化对象作为**外围类成员函数的参数**
 第三处：嵌套类的实例化对象作为**外围类成员函数的局部变量**

**声明在保护区域(protected)**

仅在外围类和外围类的派生类内部可见

这种情况下，嵌套类的实例化对象可作为在外围类及外围类的派生类的成员，以及它们的成员函数的参数或者在它们的成员函数内部实例化。



## **引用私有数据成员**

1通过公有函数

2通过指针

```
#include <iostream>
using namespace std;
class Test {
		int x, y;
	public:
		void Setxy(int a, int b) {
			x = a;
			y = b;

		}
		void Printxy(void)

		{
			cout << "x=" << x << "\t" << "y=" << y << endl;
		}
		void Getxy(int *px,int *py)
		{
			*px=x;
			*py=y;
		}
};
int main() {
	Test p1,p2;
	p1.Setxy(10,1);
	p1.Printxy();
	int x1,y1;
	p2.Setxy(1,10);
	p2.Getxy(&x1,&y1);
	cout << "x1=" << x1 << "\t" << "y1=" << y1 << endl;
	
}
```

3.利用函数访问

```
#include <iostream>
using namespace std;
class Test {
		int x, y;
	public:
		void Setxy(int a, int b) {
			x = a;
			y = b;

		}
		int Getx() {
			return x;
		}
		int Gety() {
			return y;
		}
		void Printxy(void)

		{
			cout << "x=" << x << "\t" << "y=" << y << endl;
		}
};
int main() {	
	int a, b;
	Test p1;
	p1.Setxy(3, 5);
	a = p1.Getx();
	b = p1.Gety();
p1.Printxy();
}
```

**利用引用访问私有数据成员**

```
#include <iostream>
using namespace std;
class Test {
		int x, y;
	public:
		void Setxy(int a, int b) {
			x = a;
			y = b;

		}
		void Getxy(int &px, int &py) {
			px = x;
			py = y;
		}
		void Printxy(void)

		{
			cout << "x=" << x << "\t" << "y=" << y << endl;
		}
};
int main() {
	int a,b;
	Test p1;
	p1.Setxy(3, 5);
	p1.Getxy(a, b);
	p1.Printxy();
}

```





## **构造函数和析构函数**

在 C++ 程序中，变量在定义时可以初始化。如果不进行初始化，变量的初始值会是什么呢？对全局变量和局部变量来说，这个答案是不一样的。
未初始化的全部变量
全局变量在程序装入内存时就已经分配好了存储空间，程序运行期间其地址不变。对于程序员没有初始化的全局变量，程序启动时自动将其全部初始化为 0（即变量的每个比特都是 0）。

在大多数情况下，这是一种稳妥的做法。而且，将全局变量自动初始化为 0，是程序启动时的一次性工作，不会花费多少时间，所以大多数 C++ 编译器生成的程序，未初始化的全局变量的初始值都是全 0。
未初始化的局部变量
对于局部变量，如果不进行初始化，那么它的初始值是随机的。局部变量定义在函数内部，其存储空间是动态分配在栈中的。

函数被调用时，栈会分配一部分空间存放该函数中的局部变量（包括参数），这片新分配的存储空间中原来的内容是什么，局部变量的初始内容也就是什么，因此局部变量的初始值是不可预测的。

函数调用结束后，局部变量占用的存储空间就被回收，以便分配给下一次函数调用中涉及的局部变量。

为什么不将局部变量自动初始化为全 0 呢？因为一个函数的局部变量在内存中的地址，在每次函数被调用时都可能不同，因此自动初始化的工作就不是一次性的，而是每次函数被调用时都耍做，这会带来无谓的时间开销。

当然，如果程序员在定义局部变量时将其初始化了，那么这个初始化的工作也是每次函数被调用时都要做的，但这是编程者要求做的，因而不会是无谓的。 

## 对象的初始化

对象和基本类型的变量一样，定义时也可以进行初始化。一个对象，其行为和内部结构可能比较复杂，如果不通过初始化为其某些成员变量赋予一个合理的值，使用时就会产生错误。例如，有些以[指针](http://c.biancheng.net/c/80/)为成员变量的类可能会要求其对象生成时，指针就已经指向一片动态分配的存储空间。

 对象的初始化往往不只是对成员变量赋值这么简单，也可能还要进行一些动态内存分配、打开文件等复杂的操作，在这种情况下，就不可能用初始化基本类型变量的方法来对其初始化。

 虽然可以为类设汁一个初始化函数，对象定义后就立即调用它，但这样做的话，初始化就不具有强制性，难保程序员在定义对象后不会忘记对其进行初始化。面向对象的程序设计语言倾向于对象一定要经过初始化后，使用起来才比较安全。因此，引入了构造函数（constructor）的概念，用于对对象进行自动初始化。

在C++语言中，“构造函数”就是一类特殊的成员函数，其名字和类的名字一样，并且不写返回值类型（void 也不写）。

 构造函数可以被重载，即一个类可以有多个构造函数。

 如果类的设计者没有写构造函数，那么编译器会自动生成一个没有参数的构造函数，虽然该无参构造函数什么都不做。

 无参构造函数，不论是编译器自动生成的，还是程序员写的，都称为默认构造函数（default constructor）。如果编写了构造函数，那么编译器就不会自动生成默认构造闲数。

 对象在生成时，一定会自动调用某个构造函数进行初始化，对象一旦生成，就再也不会在其上执行构造函数。

 初学者常因“构造函数”这个名称而认为构造函数负责为对象分配内存空间，其实并非如此。构造函数执行时，对象的内存空间已经分配好了，构造函数的作用是初始化这片空间。

 为类编写构造函数是好的习惯，能够保证对象生成时总是有合理的值。例如，一个“雇员”对象的年龄不会是负的。

### **构造函数**

来处理对象的初始化。构造函数是一种特殊的成员函数，与其他的函数不同，她不需要用户来调用它，而是在建立对象时自动执行的。

#### **有关于构造函数的定义**

- C++中类可以定义和类名相同的特殊的成员函数，这种与类名一致的成员函数叫做**构造函数**
- 构造函数在定义时可以有参数
- 没有任何返回类型的声明

特点

•**可以带参数**

•**可以重载**

•**没有返回值**

•**是类的成员函数**

•**系统约定构造函数名必须与类名相同。**

•**主要作用是完成初始化对象的数据成员以及其它的初始化工作**。

•**一个类可以定义若干个构造函数。当定义多个构造函数时，**必须满足函数重载的原则



•**对于局部对象：**

​	•**每次定义对象时，都要调用构造函数。**

•**对于静态对象：**

​	•**在首次定义对象时，调用构造函数的**

​	•**由于对象一直存在，****只调用一次构造函数****。**

•**对于全局对象：**

​	•**在****main****函数执行之前调用构造函数的****。**



**缺省的构造函数**

**在定义类时，若没有定义类的构造函数，则编译器****自动****产生一个缺省的构造函数，其格式为：**

​    **className****::****className****() { }**

**缺省的构造函数并不对所产生对象的数据成员赋初值****；即****新产生对象的数据成员的值是不确定的。** 

  缺省构造函数，又称默认构造函数，是C++以及其他的一些面向对象的程序设计语言中，对象的不需要参数即可调用的构造函数。下面将针对缺省构造函数的定义、使用、以及注意问题等方面简要探讨。

 1、缺省构造函数是怎样的形式？是如何定义的？

         在C++的一个类中，如果构造函数没有参数，或者构造函数的所有参数都有默认值，就可以称其为缺省构造函数。一个类中，只能有一个缺省构造函数。
    
     对于如下代码：构造函数MyClass()没有参数，就是MyClass的缺省（默认）构造函数。
```
class MyClass
{
public:
	MyClass(){
		value = 1;
		cout<<"无参默认构造函数调用并初始化value："<<value<<endl;
	};
private:
	int value;
};
```

而对于如下代码：构造函数Myclass(int  i = 10)的所有参数（此处只有一个参数i）都有默认值，这样的形式，也是MyClass的缺省（默认）构造函数。

```
    class MyClass
    {
    public:
    	MyClass(int i = 10){
    		value = i;
    		cout<<"参数都有默认值的默认构造函数调用并初始化value："<<value<<endl;
    	};
    private:
    	int value;
    };


```

要注意，一个类中只能有一个缺省构造函数。如果将以上的两个构造函数均加入类中，形如以下代码，就会有问题。



 2、缺省构造函数在何时被调用？

        缺省构造函数的调用主要包括如下的几种情况：
    
    对象被定义时无参数，形如：MyClass mc;
    动态分配对象时无参数列表，形如：MyClass *mcptr = new MyClass; 或 MyClass *mcptr = new MyClass();
    使用静态分配的数组，数组元素为某个类的对象，形如： MyClass mcArrayStatic[5];
    使用动态分配的数组，数组元素为某个类的对象，形如：MyClass *mcArrayDynamic = new MyClass[6];
    使用标准库的容器（如vector），容器的元素类型是某个类的对象，形如：vector<MyClass> vmc(7);
    在派生类的构造函数中未显示调用基类的构造函数，此时基类的缺省构造函数会被调用
    
        下面通过一段代码加以演示：
**构造函数与new运算符**

我们在开发过程中经常会使用new运算符实例化对象。
比如：let date = new Date();
实际上就是 new 构造函数() 来实例化一个对象。任何的函数都可以作为构造函数存在。之所以有构造函数与普通函数之分，主要从功能上进行区别的，构造函数的主要功能是初始化对象，特点是和new 一起使用。new就是在创建对象，从无到有，构造函数就是在为初始化的对象添加属性和方法。
构造函数定义时首字母大写（规范）

```
#include<iostream>
using namespace std;

class  A {
		float   x, y;
	public:
		A(float a, float b)	{
			x = a;
			y = b;
		}
		A()	{
			x = 0;
			y = 0;
		}
		void  Print(void)	{
			cout << x << '\t' << y << endl;
		}
};
int main(void) {
	A   *pa1, *pa2;
	pa1 = new  A(3.0, 5.0); //用new动态开辟对象空间，初始化
	pa2 = new A; //用new动态开辟空间，调用构造函数初始化
	pa1->Print();
	pa2->Print();
	delete  pa1;  //用delete释放空间
	delete  pa2; //用delete释放空间
}

```

### 用构造函数实现数据成员的初始化



```
#include <iostream>
using namespace std;

class Time {
	private:
		int hour, minture, sec;
	public:
		Time() {
			hour = 0;
			minture = 0;
			sec = 0;
		}
		void set_time();
		void show_time();

};

void Time::set_time() {
	cin >> hour >> minture >> sec;
}

void Time::show_time() {
	cout << hour << ":" << minture << ":" << sec << endl;
}

int main() {
	Time t1;
	t1.set_time();
	t1.show_time();
	return 0;
}
```

### 在类外定义带参数的构造函数

```
#include<iostream>
using namespace std;
 
class Time
{
public:
    void set_time();
    void show_time();
private:
    int hour;
    int minute;
    int sec;
};
/**在类外定义含参数的构造函数**/
void Time::time(int h, int m, int s)
{
     hour = h;
     minute = m;
     sec = s;
}
 
void Time::set_time()
{
    cin >> hour;
    cin >> minute;
    cin >> sec;
}
 
void Time::show_time()
{
    cout << hour << ":" << minute << ":" << sec << endl;
}
 
int main(void)
{
    Time t1;
    Time time1(0, 0, 0);//建立对象time1，并指定time1的值
    t1.set_time();
    t1.show_time();
    Time t2;
    Time time2(1, 1, 1);//建立对象time2，并指定time2的值
    t2.set_time();
    t2.show_time();
    return 0;
}
//带参数的构造函数
#include<iostream>
using namespace std;

class Box {
	private:
		int height, width, length;
	public:
		Box(int, int, int);
		int Volume();

};
Box::Box(int h, int w, int l) {
	height = h;
	width = w;
	length = l;
}

int Box::Volume() {
	return (height * width * length);
}

int main() {
	Box bo(1, 2, 3);
	cout << bo.Volume() << endl;
	return 0;
}
```



# C++构造函数中用参数列表初始化成员

一、需要初始化的数据成员是对象的情况(这里包含了继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化)； 
 二、需要初始化const修饰的类成员； 
 三、需要初始化引用成员数据； 

```
#include<iostream>
using namespace std;

class Box {
	private:
		int height, width, length;
	public:
		Box();
		Box(int h, int w, int l): height(h), width(w), length(l) {}
		int Volume();


};
Box::Box() {
	height = 10;
	width = 20;
	length = 30;
}

int Box::Volume() {
	return (height * width * length);
}

int main() {
	Box bo1(1, 2, 3), bo2;
	cout << bo1.Volume() << endl;
	cout << bo2.Volume() << endl;
	return 0;
}
```



构造函数使用默认函数

```
#include<iostream>
using namespace std;

class Box {
	private:
		int height, width, length;
	public:

		Box(int h = 10, int w = 200, int l = 3000);
		int Volume();


};
Box::Box(int h, int w, int l) {
	height = h;
	width = w;
	length = l;
}

int Box::Volume() {
	return (height * width * length);
}

int main() {
	Box bo1(1, 2, 3), bo2, bo3(1), bo4(1, 2);
	cout << bo1.Volume() << '\t'
	     << bo2.Volume() << '\t'
	     << bo3.Volume() << '\t'
	     << bo4.Volume() << '\t'
	     << endl;
	return 0;
}
```



### 析构函数

概述

C++析构函数是一个特殊的成员函数，作用与构造函数相反，它的名字是类名的前面加一个～符号，析构函数是与构造函数作用相反的函数，当对象的生命期结束时，会自动执行析构函数。



如果在一个函数中定义了一个对象，当这个函数被调用结束时，对象应该释放，在对象释放前自动执行析构函数。

static局部对象在函数调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束调用exitt函数结束程序时，才调用static局部对象的析构函数。

如果定义了一个全局对象，则在程序的流程离开其作用域时，调用该全局对象的析构函数。

如果用new运算符动态地建立了一个对象，当用delete运算符释放该对象时，先调用该对象的析构函数。



析构函数的作用并不是删除对象，而是在撤销对象占用的内存之前完成一些清理工作，使这部分内存可以被程序分配给新对象使用。

析构函数不返回任何值，没有函数类型，也没有函数参数，因此不能重载，一个类可以有多个构造函数，但只能有一个析构函数。 

析构函数的作用并不仅限于释放资源方面，它还可以被用来执行程序员希望在最后一次使用对象之后所执行的任何操作。

如果没有定义析构函数，C++编译系统会自动生成一个析构函数，但它只是徒有析构函数的名称和形式，实际上什么都不执行，要想让析构函数执行，必须在定义的析构函数中指定。



````
#include <iostream>
using namespace std;
class Number
{
   public:
      void setNumber( double num );
      double getNumber( void );
      Number(); // 这是构造函数声明
      ~Number(); // 这是析构函数声明
   private:
      float number;
};
// 成员函数定义，包括构造函数
Number::Number(void)
{
    cout << "我是构造函数" << endl;
}
Number::~Number(void)
{
    cout << "我是析构函数" << endl;
}
 
void Number::setNumber( double num )
{
    number = num;
}
 
double Number::getNumber( void )
{
    return number;
}
// 程序的主函数
int main( )
{
   Number num;
   num.setNumber(6.0); // 设置长度
   cout << "学号是：" << num.getNumber() <<endl;
   return 0;
}
````

```
#include<iostream>
#include<string>
using namespace std;
 
class Student
{
public:
    Student(int n, string nam, char s) //定义有参数的构造函数
    {
        num = n;
        sex = s;
        name = nam;
        cout << "Contructor called." << endl;
    }
    ~Student()//定义析构函数
    {
        cout << "Destructor called." << num << endl;//输出指定的信息
    }
    void display()
    {
        cout << "num:" << num << endl;
        cout << "name:" << name << endl;
        cout << "sex:" << sex << endl;
    }
private:
    int num;
    string name;
    char sex;
};
 
int main(void)
{
    Student stud1(10010, "Wang_li", 'f');
    stud1.display();
    Student stud2(10011, "Zhang_fan", 'm');
    stud2.display();
    return 0;
}
```

对象的**初始化和清理**也是两个非常重要的安全问题

​	一个对象或者变量没有初始状态，对其使用后果是未知

​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

c++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**

**编译器提供的构造函数和析构函数是空实现。**

- 构造函数：主要作用在于创建对象时为对象的成员属性赋值（进行类初始化的操作）。构造函数由编译器自动调用，无须手动调用。
- 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。

**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数*可以有参数*，因此*可以发生重载*
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次

**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号  ~
3. 析构函数*不可以有参数*，因此*不可以发生重载*
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次

```
class Person
{
public:
	//构造函数
	Person()
	{
		cout << "Person的构造函数调用" << endl;
	}
	//析构函数
	~Person()
	{
		cout << "Person的析构函数调用" << endl;
	}

};

void test01()
{
	Person p;
}

int main() {
	
	test01();

	system("pause");

	return 0;
}
```

**注意：**在main函数中，只有构造没有析构，因为程序在system(“pause”)处暂停了程序，所以不会调用析构函数，当main函数运行完成前会自动调用析构函数。图二所示每次初始化对象时只调用一次。

#### 构造函数的分类及调用

两种分类方式：

​	按*参数*分为： 有参构造和无参构造(默认构造函数)

​	按*类型*分为： 普通构造和拷贝构造

三种调用方式：

​	1.括号法(常用)

​	2.显示法

​	3.隐式转换法

```
//1、构造函数分类
// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数
// 按照类型分类分为 普通构造和拷贝构造

class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int age;
};

//2、构造函数的调用

void test01() {
    //2.1  括号法（常用）
	Person p1;//调用无参构造函数，默认构造函数的调用
    Person p2(10);//有参构造函数
    Person p3(p2);//拷贝构造函数
	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//Person p2();

	//2.2 显式法
	Person p2 = Person(10); //相当于给匿名对象Person(10)起个名字叫p2
	Person p3 = Person(p2);
	//Person(10)单独写就是匿名对象（等同于int(10)存于栈上），特点：当前行结束之后，马上析构，即系统立即回收掉匿名对象。

	//2.3 隐式转换法（简化的显示法）
	Person p4 = 10; // Person p4 = Person(10); 
	Person p5 = p4; // Person p5 = Person(p4); 
    //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
	//Person (p5);等同于Person p5；

}

int main() {

	test01();

	system("pause");

	return 0;
}
```

Person(10)单独写就是匿名对象（等同于int(10)存于栈上），特点：当前行结束之后，马上析构，即系统立即回收掉匿名对象。

匿名对象同上面章节的int(10)注意加上new就可以将数据开辟到堆区。

**注意点：**

1. 括号法调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明。错误：Person p2();
2. 不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明。错误：Person (p5);等同于Person p5；

调用情况

（1）如果在一个函数中定义了一个对象(它是自动局部对象)，当这个函数被调用结束时，对象应该释放，在对象释放前自动执行析构函数。
（2）static局部对象在函数调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束或调用exit函数结束程序时，才调用static局部对象的析构函数。
（3）如果定义了一个全局对象，则在程序的流程离开其作用域时(如main函数结束或调用exit函数) 时，调用该全局对象的析构函数。
（4）如果用new运算符动态地建立了一个对象，当用delete运算符释放该对象时，先调用该对象的析构函数。
（5）调用复制构造函数后。 



## c++多态

### 多态概念引入

### 1. 多态定义的构成条件

多态是在不同继承关系的类对象，去调同一函数，产生了不同的行为。

就是说，有一对继承关系的两个类，这两个类里面都有一个函数且名字、参数、返回值均相同，然后我们通过调用函数来实现不同类对象完成不同的事件。

**但是构成多态还有两个条件：**

1. 调用函数的对象必须是指针或者引用。
2. 被调用的函数必须是虚函数，且完成了虚函数的重写。

### 分类

静态

动态





## 运算符重载

运算符重载的实质就是函数重载或函数多态。运算符重载是一种形式的C++多态。目的在于让人能够用同名的函数来完成不同的基本操作。要重载运算符，需要使用被称为运算符函数的特殊函数形式，运算符函数形式：operatorp（argument-list）//operator 后面的'p'为要重载的运算符符号。

即：

```    &lt;返回类型说明符&gt; operator &lt;运算符符号&gt;(&lt;参数表&gt;)
<返回类型说明符> operator <运算符符号>(<参数表>)
{

     <函数体>

}
```

### 重载运算符遵循规则：

(1)C++不允许自定义新的运算符，只能重载已有运算符。

(2)五种运算符不能重载：“.”、“.*”、“::”、“sizeof”、“?:”

(3)重载不能改变运算对象个数，即双目仍为双目、单目仍为单目。

(4)重载不能改变运算符优先级。

(5)重载不能改变运算符结合方式。

(6)重载运算符的函数无默认参数。

(7)重载的运算符必须和用户定义的对象一起使用，运算符参数（操作的对象）中至少应有一个是类对象（或类对象的引用）。

(8)对于类对象操作的运算符一般必须重载，但“=”、“&”不必用户重载。

(9)运算符重载函数可以是类的成员函数，可以是类的友元函数，可以是普通函数。

(10)对于运算符重载函数“=”、“[]”、“()”必须定义为类成员函数，“<<”、“>>”、“（类型）”不能定义成类的成员函数，一般单目运算符重载为成员函数，双目运算符重载为友元函数（若为成员函数交换律将不适用）。

(11)“>>”、“<<”的重载函数形式：

istream & operator>>（istream&，自定义类 &）；

ostream & operator<<（istream&，自定义类 &）；

重载函数的形式注定了其没有隐含参数*this，自然也就不能是成员函数。

(12)类型转换的重载：

<1>转换构造函数：其他类型数据转化成一个类对象，要求只有一个形参。

形式：类名（类型名   类型形参）{类的初始化语句}

<2>类型转化函数(类型转化运算符重载函数)：对象转化成其他类型的数据，要求不能有参数。

形式：operator 类型名（）{实现转换的语句}



友元函数

访问私有数据的友元函数

1. 普通函数声明为友元函数

   ```
   #include <iostream>
   using namespace std;
   
   class Time {
   	private:
   		int hour, minute, sec;
   	public:
   		Time(int, int, int);
   		friend void display(Time &);
   };
   
   Time::Time(int h, int m, int s) {
   	hour = h;
   	minute = m;
   	sec = s;
   }
   
   void display(Time& t) {
   	cout << t.hour << ":" << t.minute << ":" << t.sec << endl;
   }
   
   int main() {
   	Time t1(10, 13, 1);
   	display(t1);
   	return 0;
   }
   
   ```

   

2. 友元成员函数访问私有数据





## c++继承

### 继承

继承(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。继承是类设计层次的复用

```
class Person
{
public:
	void Print()
	{
		cout << "name:" << _name << endl;
		cout << "age:" << _age << endl;
	}
protected:
	string _name = "fl"; // 姓名
	int _age = 21;
};

class Student :public Person
{
protected:
	int _stuid;//学号
};

class Teacher :public Person
{
protected:
	int _jobid;//工号
};

int main()
{
	Student s;
	Teacher t;
	s.Print();
	t.Print();
}

```



继承后父类的Person的成员（成员函数+成员变量）都会变成子类的一部分。这里体现出了Student和Teacher复用了Person的成员。下面我们使用监视窗口查看Student和Teacher对象，可以看到变量的复用。调用Print可以看到成员函数的复用。

### 派生类

一、基类 & 派生类

        当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。
    
        例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同。
```
#include<iostream>
using namespace std;

//基类
class basepage {
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...（公共头部）" << endl;
	}
	void footer()
	{
		cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java,Python,C++...(公共分类列表)" << endl;
	}
};

//派生类
class CPP :public basepage {
public:
	void content() {
		cout << "C++学科视频" << endl;
	}
};

void test01()
{
	//C++页面
	cout << "C++下载视频页面如下： " << endl;
	CPP cp;
	cp.header();
	cp.footer();
	cp.left();
	cp.content();
}

int main() {
	test01();
	system("pause");
	return 0;
}


```

从运行结果可以看出，CPP类在定义自己的特性基础上还保留basepage类的属性，这就是派生的基本用法。

        一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：

class 派生类名:继承方式 基类名

        其中继承属性有public、private、protected三种 。

多继承的方式如下：

        语法：class 派生类：继承方式 基类1 ，继承方式 基类2

二、继承方式

        前面说了类的继承方式有三种public、private、protected，他们的区别就是派生类对基类的访问权限有所不同！
    
    公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。
    保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
    私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。
    
        代码如下：

```
#include <iostream>
using namespace std;
 
//
//**继承方式一共有三种：**
//
//* 公共继承
//* 保护继承
//* 私有继承
 
class base1 {
public:
	int m_a;
protected:
	int m_b;
private:
	int m_c;
};
 
//公有派生
class son1 :public base1 {
public:
	void func() {
		m_a;	//可访问public权限
		m_b;	//可访问protected权限
		//m_c;	//m_c是基类的私有权限无法访问
	}
};
 
//保护派生
class son2 :protected base1 {
public:
	void func() {
		m_a;	//可访问protected权限
		m_b;	//可访问protected权限
		//m_c;	//m_c是基类的私有权限无法访问
	}
};
 
//保护派生
class son3 :private base1 {
public:
	void func() {
		//m_a;	//不可访问private权限
		//m_b;	//不可访问private权限
		//m_c;	//m_c是基类的私有权限无法访问
	}
};
 
 
void test() {
	son1 s;
	s.m_a;
	//s.m_b; 公有派生不改变成员变量的权限，因此m_b是保护权限，类外无法访问
 
	son2 s1;
	//s1.m_a;	//protected权限，类外无法访问
}
 
int main()
{
	system("pause");
	return 0;
}
```

三、继承的对象模型

        从父类继承过来的成员变量，哪些属于子类对象中？我们已经知道当发生公有继承的时候，不会改变基类成员变量的访问权限。
        并且在派生类中，无法访问基类中private属性的成员变量。无法访问并不意味着没有继承到派生对象中。可以看到如下代码：
```
#include <iostream>
using namespace std;
 
//基类
class base {
public:
	int m_a;
protected:
	int m_b;
private:
	int m_c;
};
 
class son1 :private base {
public:
	int m_d;
};
 
void test() {
	cout << "son1 的 size = " << sizeof(son1) << endl;
}
 
int main()
{
	test();
	system("pause");
	return 0;
}
```

继承基类成员访问方式的变化：

| 类成员/继承方式     | public继承            | protected继承          | private继承          |
| ------------------- | --------------------- | ---------------------- | -------------------- |
| 基类的public成员    | 派生类的public成员    | 派生类的protected成 员 | 派生类的private成 员 |
| 基类的protected成员 | 派生类的protected成员 | 派生类的protected成员  | 派生类的private成员  |
| 基类的private成员   | 在派生类中不可见      | 在派生类中不可见       | 在派生类中不可见     |





基类private成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它
基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected。可以看出保护成员限定符是因继承才出现的
. 实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，public > protected > private
使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过最好显示的写出继承方式
在实际运用中一般使用都是public继承，几乎很少使用protetced/private继承，也不提倡使用protetced/private继承，因为protetced/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强





### C++派生类的构造函数和析构函数

派生类对象中包含基类对象，因此派生类对象在创建时，除了要调用自身的构造函数进行初始化外，还要调用基类的构造函数初始化其包含的基类对象。因此，程序中任何能够生成派生类对象的语句，都要说明其包含的基类对象是如何初始化的。

 如果对此不做说明，则编译器认为基类对象要用无参构造函数初始化——如果基类没有无参构造函数，则会导致编译错误。

 在执行一个派生类的构造函数之前，总是先执行基类的构造函数。

 和封闭类说明成员对象如何初始化类似，派生类说明基类对象如何初始化，也需要在构造函数后面添加初始化列表。在初始化列表中，要指明调用基类构造函数的形式。具体写法如下：

构造函数名(形参表): 基类名(基类构造函数实参表)
 {
  ...
 }

对象在使用之前必须初始化，因此构造派生类对象时，就要对基类成员对象和新增成员对象进行初始化。

基类的构造函数并没有继承下来，要完成这些工作，就必须给派生类添加新的构造函数。

派生类对于基类的很多成员对象是不能直接访问的，因此要完成对基类成员对象的初始化工作，需要通过调用基类的构造函数。

在构造派生类对象时，会首先调用基类的构造函数，来初始化它们的数据成员，然后按照构造函数初始化表列中指定的方式初始化派生类新增的成员对象，最后才执行派生类构造函数的函数体。

派生类构造函数的一般语法形式为：

```cpp
派生类名::派生类名(参数表):基类名1(基类1初始化参数表),...,基类名n(基类n初始化参数表),成员对象名1(成员对象1参数初始化参数表),...,成员对象名m(成员对象名m初始化参数表)
{
	派生类构造函数的其他初始化操作;
}
```

对于默认构造函数的基类，可以不给出类名。同样，对于成员都西昂，如果时使用默认构造函数，也不需要写出对象名和参数表。

如果对基类初始化时，需要调用积累带有形参表的构造函数时，派生类就必须声明构造函数。

当派生类没有显示的构造函数时，系统会隐含生成一个默认构造函数，该函数会使用基类的默认构造函数对继承自基类的数据初始化，并且调用类类型的成员对象的默认构造函数，对这些成员对象初始化。

派生类构造函数执行的一般次序如下：

（1）调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）
 （2）对派生类新增的成员进行初始化，调用顺序按照它们在类中声明的顺序。
 （3）执行派生类构造函数体中的内容。

例：派生类构造函数举例（多继承、含有内嵌对象）

```
class Base1{
public:
	Base1(int i){cout << "Constructing Base1" << i << endl;}
}; 

class Base2{
public:
	Base2(int j){cout << "Constructing Base2" << j << endl;}
};

class Base3{
public:
	Base3(){cout << "Constructing Base3*"  << endl;}
};

class Derived:public Base2, public Base1, public Base3{
public:
	Derived(int a, int b, int c, int d):Base1(a), member2(d), member1(c), Base2(b){}

private:
	Base1 member1;
	Base2 member2;
	Base3 member3;
};

int main() {
	Derived obj(1, 2, 3, 4);
	return 0;
}
```



### 多重继承

概念： 一个派生类如果只继承一个基类，称作单继承，那么如果继承了多个基类，就称作多继承。
比如：

```cpp
class C:public A,public B{};
```

#### 多重继承的优点：

多重继承可以做更多的代码复用！
 派生类通过多重继承，可以得到多个基类的数据和方法，`更大程度的实现了代码复用`。

**多重继承有优点，那就也会存在缺陷：**

首先我们通过[菱形继承](https://so.csdn.net/so/search?q=菱形继承&spm=1001.2101.3001.7020)了解一下多重继承的缺陷：

### 菱形继承

菱形继承是多继承的一种：

c++内存

## 1 代码区

存放 CPU  执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。

总结：你所写的所有代码都会放入到代码区中，代码区的特点是共享和只读。

## 2 全局区

全局区中主要存放的数据有：全局变量、静态变量、常量（如字符串常量）

全局区的叫法有很多：全局区、静态区、数据区、全局静态区、静态全局区

这部分可以细分为data区和bss区

**2.1 data区**

data区里主要存放的是已经初始化的全局变量、静态变量和常量

**2.2 bss区**

bss区主要存放的是未初始化的全局变量、静态变量，这些未初始化的数据在程序执行前会自动被系统初始化为0或者NULL

**2.3 常量区**

常量区是全局区中划分的一个小区域，里面存放的是常量，如const修饰的全局变量、字符串常量等

在VS下运行结果如下：

总结：全局区存放的是全局变量、静态变量和常量

在程序运行后由产生了两个区域，栈区和堆区



## 3 栈区（stack）

栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。



## 4 堆区（heap）

堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。

| 栈区（stack）                | 由编译器自动分配释放，存放函数的参数值，局部变量的值等。     |
| ---------------------------- | ------------------------------------------------------------ |
| 堆区（heap）                 | 一般由程序员分配释放（动态内存申请与释放），若程序员不释放，程 |
| 序结束时可能由操作系统回收。 |                                                              |
| 全局区（静态区）（static）   | 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，该区域在程序结束后由操作系统释放。 |
| 常量区                       | 字符串常量和其他常量的存储位置，程序结束后由操作系统释放。   |
| 程序代码区                   | 存放函数体的二进制代码。                                     |

## c++模板



```
template <typename T>
T Max(T a, T b) {
	return a > b ? a : b;
}

int main(void)
{

	int  n = 1;
	int	 m = 2;
	cout << "max(1, 2) = " << Max(n, m) << endl;

	float a = 2.0;
	float b = 3.0;
	cout << "max(2.0, 3.0) = " << Max(a, b) << endl;

	char i = 'a';
	char j = 'b';
	cout << "max('a', 'b') = " << Max(i, j) << endl;
	
	return 0;
}
```

所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。

    凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。

函数模板定义形式
由以下三部分组成： 模板说明 + 函数定义 + 函数模板调用

template < 类型形式参数表 >
类型 函数名 (形式参数表)
{
//语句序列
}

我们也可以定义多个类型

```cpp
template <typename T, typename T2>
```

```
template <typename T, typename T2>
T Max(T a, T2 b) {
	return a > b ? a : b;
}

int main(void){

	int n = 6;
	int m = 9;

	cout << Max(n, m) << endl;

	system("pause");
	return 0;
}
```

1.模板说明

template < 类型形式参数表 >
类型形式参数的形式：
typename T1 , typename T2 , …… , typename Tn
或 class T1 , class T2 , …… , class Tn
（注意： typename 和 class 的效果是一样的，不过建议呢使用typename，为了防止用class有歧义）

2.函数定义

类型 函数名 (形式参数表)
{
}
注意： 模板说明的类属参数必须在函数定义中出现一次,函数参数表中可以使用类属类型参数，也可以使用一般类型参数
3.函数模板调用

Max<int,int>(a, b); //显式类型调用
Max(a, b); //自动数据类型推导

一、纯虚函数定义
   纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”

二、引入原因：
1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。
   为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重载以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。

 带有纯虚函数的类称为抽象类。抽象类是一种特殊的类，它是为了抽象和设计的目的而建立的，它处于继承层次结构的较上层。**抽象类是不能定义对象的，在实际中为了强调一个类是抽象类，可将该类的构造函数说明为保护的访问控制权限。**

  抽象类的主要作用是将有关的组织在一个继承层次结构中，由它来为它们提供一个公共的根，相关的子类是从这个根派生出来的。

  抽象类刻画了一组子类的操作接口的通用语义，这些语义也传给子类。一般而言，抽象类只描述这组子类共同的操作接口，而完整的实现留给子类。

  抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类没有重新定义纯虚函数，而派生类只是继承基类的纯虚函数，则这个派生类仍然还是一个 抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体类了。

**抽象类的规定**

（1）抽象类只能用作其他类的基类，不能建立抽象类对象。

（2）抽象类不能用作参数类型、函数返回类型或显式转换的类型。

（3）**可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。**

 ```
#include<iostream>
using namespace std;

const double PI=3.14159;

class Shapes   //抽象类
{
protected:
    int x, y;
public:
    void setvalue(int d, int w=0){x=d;y=w;}
    virtual void disp()=0;//纯虚函数
};

class Square:public Shapes
{
public:
    void disp(){
        cout<<"矩形面积:"<<x*y<<endl;
    }
};

class Circle:public Shapes{
public:
    void disp(){
        cout<<"圆面积:"<<PI*x*x<<endl;
    }
};

int main()
{
    Shapes *ptr[2]; //定义对象指针数组
    Square s1;
    Circle c1;
    ptr[0] = &s1;
    ptr[0]->setvalue(10, 5);
    ptr[0]->disp();
    ptr[1] = &c1;
    ptr[1]->setvalue(10);
    ptr[1]->disp();
    return 0;

}#include<iostream>
using namespace std;

const double PI=3.14159;

class Shapes   //抽象类
{
protected:
    int x, y;
public:
    void setvalue(int d, int w=0){x=d;y=w;}
    virtual void disp()=0;//纯虚函数
};

class Square:public Shapes
{
public:
    void disp(){
        cout<<"矩形面积:"<<x*y<<endl;
    }
};

class Circle:public Shapes{
public:
    void disp(){
        cout<<"圆面积:"<<PI*x*x<<endl;
    }
};

int main()
{
    Shapes *ptr[2]; //定义对象指针数组
    Square s1;
    Circle c1;
    ptr[0] = &s1;
    ptr[0]->setvalue(10, 5);
    ptr[0]->disp();
    ptr[1] = &c1;
    ptr[1]->setvalue(10);
    ptr[1]->disp();
    return 0;

}
 ```



1、多态性
  指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。
  a.编译时多态性： 通过函数重载和运算符重载来实现的。
  b 运行时多态性：通过继承和虚函数来实现的。
2、虚函数
  虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载
  **纯虚函数的声明有着特殊的语法格式：****virtual 返回值类型成员函数名（参数表）=0；**

 

  请注意，纯虚函数应该只有声明，没有具体的定义，即使给出了纯虚函数的定义也会被编译器忽略。

 

3、抽象类

 

   包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。
   在C++中，我们可以把只能用于被继承而不能直接创建对象的类设置为抽象类（Abstract Class）。

 

   之所以要存在抽象类，最主要是因为它具有不确定因素。我们把那些类中的确存在，但是在父类中无法确定具体实现的成员函数称为纯虚函数。纯虚函数是一种特殊的虚函数，它只有声明，没有具体的定义。抽象类中至少存在一个纯虚函数；存在纯虚函数的类一定是抽象类。存在纯虚函数是成为抽象类的充要条件。