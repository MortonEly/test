python简介

python 是一门非常简单易学好用，同时功能强大的编程语言，具有丰富和强大的库，开发效率特别高。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起， python 是一门的[面向对象](https://so.csdn.net/so/search?q=面向对象&spm=1001.2101.3001.7020)的**解释型编程语言**，Python语法简洁清晰优雅

- 一是他们都有自己的解释器，也可以通俗的理解为翻译器；
- 二是他们都是在其他的编译语言（通常是C语言）的基础上定义和扩充了自己的语法结构。



解释性语言的工作原理就是用自己定义的解释器，解释并执行有自己定义的语法结构生成的程序代码。 
 所以解释性语言并不编译。

这里要区分Java，因为Java并不是单单是一门解释性语言，它为了提高效率而拥有他自己的即时解释器，实际上Java可以算作一门解释和编译的结合语言。



**编译型和解释型语言：**

计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能值型高级语言编写的程序。

翻译的方式有两种，一个是编译，一个是解释。两种方式只是翻译的时间不同。

- 编译型语言写的程序执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如.exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语 言的程序执行效率高。
- 解释则不同，解释性语言的程序不需要编译，省了道工序，解释性语言在运行程序的时候才翻译，比如解释性basic语言，专门有一个解释器能够直接执行basic程序，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就要翻译一次，效率比较低。



> java很特殊，java程序也需要编译，但是没有直接编译称为机器语言，而是编译称为字节码，然后用解释方式执行字节码。

Python为什么是一种解释性语言，解释性语言又有什么优越性呢？随着分布式概念的提出，计算机的应用越来越趋向于多平台实用性甚至是跨平台。而随着Web应用的普及，从而使的解释性语言得到空前发展，因为解释性语言拥有自己的解释器，所以这种语言对于平台的依赖性降低到最低程度，而Python就是在这种背景下发展起来的。

当然，虽然解释性语言对平台的依赖性相对小，甚至是独立于平台拥有很大的灵活性，但是由于他并不编译，所以用解释性语言编写的程序代码，在执行过程中要比编译性语言的效率要低得多。。。。

优缺点

优点：

1. 简单 Python的语法非常优雅，甚至没有像其他语言的大括号，分号等特殊符号，代表了一种极简主义的设计思想。阅读Python程序像是在读英语。
2. 易学 Python入手非常快，学习曲线非常低，可以直接通过命令行交互环境来学习Python编程。
3. 免费/开源 Python的所有内容都是免费开源的，这意味着你不需要花一分钱就可以免费使用Python，并且你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。
4. 自动内存管理 如果你了解C语言、C++语言你就会知道内存管理给你带来很大麻烦，程序非常容易出现内存方面的漏洞。但是在Python中内存管理是自动完成的，你可以专注于程序本身。
5. 可以移植 由于Python是开源的，它已经被移植到了大多数平台下面，例如：Windows、MacOS、Linux、Andorid、iOS等等。
6. 解释性  大多数计算机编程语言都是编译型的，在运行之前需要将源码编译为操作系统可以执行的二进制格式(0110格式的)，这样大型项目编译过程非常消耗时间，而Python语言写的程序不需要编译成二进制代码。你可以直接从源代码运行程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。
7. 面向对象 Python既支持面向过程，又支持面向对象，这样编程就更加灵活。
8. 可扩展 Python除了使用Python本身编写外，还可以混合使用像C语言、Java语言等编写。
9. 丰富的第三方库 Python具有本身有丰富而且强大的库，而且由于Python的开源特性，第三方库也非常多，例如：在web开发、爬虫、科学计算等等
    缺点：
10. 速度慢 由于，Python是解释型语言，所有它的速度会比，C、C++慢一些，但是不影响使用。由于，现在的硬件配置都非常高，基本上没有影响，除非是一些实时性比较强的程序可能会受到一些影响，但是也有解决办法，可以嵌入C程序。
11. 强制缩进 如果你有其他语言的编程经验，例如：C语言或者Java语言，那么Python的强制缩进一开始会让你很不习惯。但是如果你习惯了Python的缩进语法，你会觉得它非常优雅。
12. 单行语句 由于Python可以在尾部不写分号，所以一行只能有一条语句，这可能也算是一个不足吧，不过这真的微不足道

ython是一种跨平台、开源、免费的高级动态编程语言，对。python具有简单、易学、速度快、免费、开源、可移植性、可扩展性、丰富的库等优点。python语言极其容易上手，它是一种代表简单主义思想的语言。

python是一种跨平台、开源、免费的高级动态编程语言，对。

(推荐教程：python教程)

相关介绍：

python的优点：

简单：Python是一种代表简单主义思想的语言。它使你能够专注于解决问题而不是去搞明白语言本身。

易学：Python极其容易上手，因为Python有极其简单的说明文档。

速度快：Python 的底层是用 C 语言写的，很多标准库和第三方库也都是用 C 写的，运行速度非常快。

免费、开源：Python是FLOSS(自由/开放源码软件)之一。使用者可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。

可移植性：由于它的开源本质，Python已经被移植在许多平台上(经过改动使它能够工作在不同平台上)。

解释性：一个用编译性语言比如C或C++写的程序可以从源文件(即C或C++语言)转换到一个你的计算机使用的语言(二进制代码，即0和1)。这个过程通过编译器和不同的标记、选项完成。

面向对象：Python既支持面向过程的编程也支持面向对象的编程。在“面向过程”的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。

可扩展性：如果需要一段关键代码运行得更快或者希望某些算法不公开，可以部分程序用C或C++编写，然后在Python程序中使用它们。

可嵌入性：可以把Python嵌入C/C++程序，从而向程序用户提供脚本功能。

丰富的库：Python标准库确实很庞大。它可以帮助处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、GUI(图形用户界面)、Tk和其他与系统有关的操作。除了标准库以外，还有许多其他高质量的库，如wxPython、Twisted和Python图像库等等。

规范的代码：Python采用强制缩进的方式使得代码具有较好可读性。而Python语言写的程序不需要编译成二进制代码。



注释

**单行注释**

`#` 只能注释一行

**多行注释**

根据对象的引用计数器，对象创建会给对象一个引用计数器属性，如果该属性的值为0，那么该对象会被释放。创建了一个字符串对象，但是没有任何的引用，所以计数器为0。

```python
''
print("hello world!")
print("这两行是多行注释!")
'''
print("上面两行是注释，看不到!")
```

### python第三方库和包、模块

#### **一** **模块(module)**

**1.1 什么是模块**模块(module)是一个包含Python定义和语句的文件，也就是一个.py文件就可以称为一个模块。

#### **二** **包(Package)**

模块一般就是我们日常随手用的一些规模较小的代码，而在比较大规模的任务一般需要用到大量的模块，此时我们可以使用包(Package)来管理这些模块。我们平时下载的第三方包也就是这个，如Numpy,
**2.1 什么是包？**包，就是里面装了一个__init__.py文件的文件夹。__ init __.py脚本有下列性质：

（1）它本身是一个模块；

（2）模块名不是__ init __，而是包的名字，也就是装着__  init __.py文件的文件夹名。

（3）它的作用是将一个文件夹变为一个Python模块

（4）它可以不包含代码，不过一般会包含一些Python初始化代码(例如批量导入需要的模块)，在这个包被import的时候，这些代码会自动被执行。
**2.2 导入包**导入包的方法和导入模块比较类似，只不过由于层级比一般模块多了一级，所以多了一条导入形式.

import 包名.模块名

import 包名.模块名 as 模块别名



python库(library)的概念，网上搜到的信息也五花八门，没有一个统一的概念，主要总结为两种观点：
观点1：严格来说Python中是没有库(library)的概念，模块(module)和包(package)都是Python语法中有的概念，Python中的库是借用其他编程语言的概念，没有特别具体的定义，只是一个通俗的说法，平时说的库既可以是一个模块也可以是一个包。

观点2：从大到小的层级关系：库->包->模块。库是指具有相关功能模块的集合，是一个完整的东西，可以认为库是一个完整的项目打包，可直接调用或者运行，一个库中可能有多个包。

搜索到的答案中，大部分倾向于第一种观点。

最后总结就是：模块module：一个 .py 文件就是个模块，由函数和类组成；包package：多个模块放在一个文件夹，就是一个包；
库library：只是一个通俗的说法，平时说的库既可以是一个模块也可以是一个包。

#### 版本兼容问题

##### **虚拟环境**

Python 开发中所谓的**虚拟环境**，就是为 Python 版本及第三方库创建独立的开发环境，使不同项目之间互不干扰。借助于虚拟环境，我们可以在同一台电脑上构建出项目 A 在基于 Python 2 的环境中运行，而项目 B 可以在基于 Python 3 的环境中运行。

Python2和Python3的兼容写法

eval函数

  eval是Python的一个内置函数，功能十分强大，这个函数的作用是，返回传入字符串的表达式的结果。就是说：将字符串当成有效的表达式 来求值 并 返回计算结果。

    eval函数就是实现list、dict、tuple与str之间的转化，同样str函数把list，dict，tuple转为为字符串

### Python的两种编程方式

**交互式和文件式**
 交互式：对每个输入语句即时运行结果，适合单条语法的练习。
 文件式：批量执行一组语句并运行结果，是**编程的主要方式**。

## 数据类型和基本运算符

### 数据类型

#### 一、数字型

##### 整型

1、整型：int
 在数字中，正整数、0、负整数都称为整型。
 例：

```python
intvar = 1000
#type获取数据类型
res1 = type(intvar)
print (res1)
#id获取内存地址
res2 = id(intvar)
print (res2)
```

2、二进制整型
也可用二进制表示整型，print自动转换为十进制。
例：

```python
intvar = 0b1010
print (intvar)
```

##### 浮点型

1、浮点型：float
含有小数点的数据都是浮点型。

```python
floatvar = 3.14
print (floatvar,type(floatvar))
```

2、科学计数法：

```python
floatvar = 3.456e5 #小数点向右移动5位
print (floatvar,type(floatvar))
```

##### 布尔型

布尔型：bool
 布尔型数据只有两种：True、False。表示真假。
 例：

```python
boolvar = True
print (boolvar,type(boolvar))
```

##### 复数类型

1、复数：complex
 复数为实数加虚数，只要存在虚数，此数据类型就为复数类型。
 2、表达方法一：

```python
complexvar = 3-91j
print (complexvar,type(complexvar))
```

表达方法二：
 语法：complex(实数,虚数)
 例：

```python
complexvar = complex(3,-91)
print (complexvar,type(complexvar))
```

  空值

在Python中，None、空列表[]、空字典{}、空元组()、0等一系列代表空和无的对象会被转换成False。除此之外的其它对象都会被转化成True。python变量初始化为空值分别是：

数值 

```
digital_value = 0
```



字符串

```
str_value = ""
```



列表

```''
list_value = []
```



字典

```
ditc_value = {}
```



元组

```
tuple_value = ()
```



#### 二、字符串

1、字符串：str
 用引号引起来的就是字符串。
 可用：单引号、双引号、三引号

```python
strvar1 = '123'
strvar2 = "123,数字"
strvar3 = """
转义字符：\ + 字符
  （1）把无意义的字符变的有意义
  （2）把有意义的字符变的无意义
\\n：换行
\\r\\n：换行
\\t：缩进（tab，水平制表符）
\\r：把\\r后面的字符串直接拉到当前行行首
"""
print (strvar1)
print (strvar2)
print (strvar3)
```

元字符串：
 r + 字符串 ==> 表示不转字符，原型化输入字符串。（相当于字符串中给所有特殊意义的字符加了转义符）
 例：

```python
strvar = r"E:\thabc_\nay"
print (strvar)
```

#### 三、列表

1、列表：list
 定义一个空列表：
 listvar = []
 定义一个普通列表

```python
listvar = [111,3,13,True,3+4j,"abc"]
print (listvar,type(listvar))
```

2、正向索引下标：
 列表元素从左到右依次为：0、1、2、3……
 例：
 获取列表当中的值

```python
listvar = [111,3,13,True,3+4j,"abc"]
res = listvar[2]
print (res)
```

3、逆向索引下标
 列表元素从右向左依次为：-1、-2、-3、-4、-5……
 例：
 获取列表当中的值

```python
listvar = [111,3,13,True,3+4j,"abc"]
res = listvar[-4]
print (res)
```

当列表很长时，要获取列表中最后一个元素，一种方法是使用逆向索引下标，另一种方法是使用len函数获取容器类型数据总长度。
 例：

```python
listvar = [111,3,13,True,3+4j,"abc"]
res1 = len(listvar)
res2 = listvar[res1-1]
print (res2)
```

4、修改列表中的值：

```python
listvar = [111,3,13,True,3+4j,"abc"]
listvar[1] = 123
print (listvar)
```

5、列表的特点：
 可获取，可修改，有序。



#### 四、元组

1、元组：tuple
定义一个空元组：
tuplevar=()
定义一个普通元组：
tuplevar = (False,3+4j,“aaa”,456)

正向下标和逆向下标与列表相同。

2、获取元组中的元素：

```python
tuplevar = (False,3+4j,"aaa",456)
res = tuplevar[-3]
print (res)
```

3、是否可以修改元组中的元素？
 答：元组不支持赋值。
 4、元组特点
 可获取、不可修改、有序
 5、元组注意点：

```python
tuplevar =(123)
print(tuplevar,type(tuplevar))
tuplevar =(123,)
print(tuplevar,type(tuplevar))
```

如图，如果不加逗号，输出结果为整型，加了逗号输出结果为元组。
 结论：加逗号才是元组，逗号是区分是否是元组的标识符，tuplevar=1,2,3也是元组。

#### 五、集合

1、集合：set（作用：较差并补）
 定义一个空集合：
 setvar = set()
 定义一个普通集合：

```python
setvar={"123","573","张三","李四"}
print (setvar,type(setvar))
```

2、可否获取集合中的元素？
 答：不可以

3、自动去重
 例：

```python
setvar={"123","123","456","567"}
print(setvar)
```

由图可见，集合有自动去重的功能。

当集合内有重复元素时，输出集合会自动将重复元素去掉

```
s = {1,2,4,5}
print(type(s))

s1 = {}
print(type(s1))   ##空字典定义

s1 = set([])
print(type(s1))    ###空集合定义

去重
i = [1,2,3,1,1,2,3]
print(list(set(li)))    ###去重  ##将其转化为集合类型去重，然后再转为列表类型输出  
```

迭代

```
for i in s:
	print(i)  ##迭代输出其内容
```



枚举**###返回对应元素与其索引值**

```
for i,v in enumerate(s):
	print('index: %s,value: %s' %(i,v))
```



增删改查

```
s.add(1)   ###增加一个元素
s.update([5,2,3,6])  ###添加多个元素

s.pop()     ##删除最前面的元素【第一个】
s.remove()  ###指定删除某个元素
```



交集

```
print('交集:',s1.intersection(s2))
print('交集:',s1 & s2)   
```



并集

```
print('并集',s1.union(s2))
print('并集',s1 | s2)
```

4、集合特点
 无序、不可修改、自动去重。

运算符

　　3.集合的运算
		　　　　交集，并集，补集，子集，超集

​		　　　　1.交集 - &
​			　　　　　　s1 = {1,2,3}
​			　　　　　　s2 = {2,3,4}
​			　　　　　　s3 = s1 & s2 # s3 = {2,3}
​		　　　　2.并集 - |
​			　　　　　　s1 = {1,2,3}
​			　　　　　　s2 = {2,3,4}
​			　　　　　　s3 = s1 | s2 #s3 = {1,2,3,4}
​		　　　　3.补集 - -
​			　　　　　　s1 = {1,2,3}
​			　　　　　　s2 = {2,3,4}
​			　　　　　　s3 = s1 - s2 #生成属于s1 但 不属于s2的所有的元素
​			　　　　　　#s3 = {1}
​		　　　　4.对称补集 - ^
​			　　　　　　s1 = {1,2,3}
​			　　　　　　s2 = {2,3,4}
​			　　　　　　s3 = s1 ^ s2 # (s1 - s2) | (s2 - s1)
​		　　　　5.超集 - >
​		　　　　6.子集 - <
​			　　　　　　s1 = {1,2,3}
​			　　　　　　s2 = {2,3}

​			　　　　　　s1 > s2 # True s1 是 s2 的超集
​			　　　　　　s1 < s2 # False s1 不是 s2 的子集
​		　　　　7.集合的相等 - ==
​		　　　　8.集合的不等 - !=
​			　　　　　　s1 = {1,2,3}
​			　　　　　　s2 = {3,2,1}

 　　　　　　s1 == s2 #True,集合相等
		　　　　9.成员运算 - in , not in
			　　　　　　等同于字典 in , not in
			　　　　　　目的：判断某个值在集合中存在 / 不存在
	　　4.用于集合的内建函数
		　　　　len(set) : 集合内元素的个数
		　　　　max(set) : 最大值
		　　　　min(set) : 最小值
		　　　　sum(set) : 和
		　　　　any(set) : 任何一个元素为真，则返回真
		　　　　all(set) : 所有元素为真，则返回真

#### 六、字典

1、字典：dict
 键值对存储数据。
 语法：{键1:值1,键2:值2,键3:值3……}
 定义一个空字典：
 dictvar = {}
 定义一个普通字典：
 例：

```python
dictvar = {"a1":"123","a2":"234","b1":"345","b2":"456"}
print (dictvar,type(dictvar))
```

2、获取、修改字典中的值
 获取：通过键获取值

```python
dictvar = {"a1":"123","a2":"234","b1":"345","b2":"456"}
res = dictvar["a2"]
print(res)
```

修改：同样通过键修改值

```python
dictvar = {"a1":"123","a2":"234","b1":"345","b2":"456"}
dictvar["a2"] = "678"
print(dictvar)
```

返回



python不支持的数据类型是**

python不支持的数据类型是char 、byte类型。

Python没有char或byte类型来保存单一字符或 8 比特整数。你可以使用长度为 1 的字符串表示字符或 8 比特整数。python的数据类型有：数字(int)、浮点(float)、字符串(str)，列表(list)、元组(tuple)、字典(dict)、集合(set)、



### 标识符

标识符是变量、函数、类、模块和其他对象的名称。

①在 Python 里，标识符由字母、数字、下划线组成。

  在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。

②Python 中的标识符是区分大小写的。

③以下划线开头的标识符是有特殊意义的。

　以双下划线开头的 __foo 代表类的私有成员，__foo(self)代表类的私有方法，不能直接从外部调用，需通过类里的其他方法调用。

  以双下划线开头和结尾的 __foo__ 代表 Python 里特殊方法专用的标识，如 __init__() 代表类的构造函数。

④避免使用python预定义标识符名作为自定义标识符名。例如，NotImplemented、Ellipsis、int、float、list、str、tuple等

#### 保留关键字

关键字即预定义保留标识符。

关键字不能在程序中用作标识符，否则会产生编译错误。

| False  | class    | from     | or     |
| ------ | -------- | -------- | ------ |
| None   | continue | global   | pass   |
| True   | def      | if       | raise  |
| and    | del      | import   | return |
| as     | elif     | in       | try    |
| assert | else     | is       | while  |
| async  | except   | lambda   | with   |
| await  | finally  | nonlocal | yield  |
| break  | for      | not      |        |

规则

- 标识符是由**字母（A–Z 和 a–z）、下划线和数字**组成。如果标识符中出现除了这 3 类字符之外的其他字符，就肯定是不合法标识符。
- 标识符的第一个字符不能是数字。
- 标识符不能和 Python 关键字相同。
- 标识符中的字母是严格区分大小写的。
- 以下划线开头的标识符有特殊含义，除非特定场景需要，应避免使用以下划线开头的标识符。具体内容请参见本文第 5 小节 保留的标识符类。
- 标识符可以是汉字。但我们应尽量避免使用汉字作为标识符，这会避免遇到很多没必要的错误。

运算符

| 符号 | 意义                                                         |
| ---- | ------------------------------------------------------------ |
| +    | 加                                                           |
| -    | 减                                                           |
| *    | 乘                                                           |
| \    | 除，得到**浮点数**                                           |
| \ \  | 除，**向下取整**，但是得到的并不一定是整数类型，它与分母分子的数据类型有关系 |
| %    | 取余                                                         |
| **   | 乘方                                                         |

[![ziSJbt.jpg](https://s1.ax1x.com/2022/11/12/ziSJbt.jpg)](https://imgse.com/i/ziSJbt)

```python
>>> 3.0/2
1.5
>>> 3/2.0
1.5
>>> 3/2
1.5
>>> 3.0/2.0
1.5
>>>
```



强制转化

| 函数名        | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| int(x)        | 将x转换为一个整数                                            |
| float(x)      | 将x转换到一个浮点数                                          |
| complex(x)    | 将x转换到一个复数，实数部分为 x，虚数部分为 0                |
| complex(x, y) | 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式 |

## 字符串、列表、元组、字典和集合

## 不可变数据类型

python中不可变数据类型的定义为：**当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，就称不可变数据类型**，包括：`int`（整型）、`string`（字符串）、`tuple`（元组）

列表、元组、字符串是python的有序序列；其中列表是可变对象，元组和字符串则是不可变对象。序列中的每个元素都分配一个数字，即它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。

集合的元素**不可以是列表**，只能是固定数据类型，例如数值、字符串、元组



### 整型

首先我们来看一下整型为什么是不可变数据类型。给一个变量`x`赋值，然后改变这个x的值，输出前后两次的内存地址id和数据类型type

- `id()`：获取对象的内存地址
- `type()`：当只有一个参数的时候，返回对象的类型。当有三个参数的时候返回一个类对象。

```python3
# 赋值
x = 1
# 打印x的内存地址和数据类型
print(id(x), type(x))

# 输出：8791164511056 <class 'int'>


# 改变x的值
x = 2
# 打印改变后的x的内存地址和数据类型
print(id(x), type(x))

# 输出：8791164511088 <class 'int'>
```

从上面的代码我们可以得出，变量x为整型，且当x的值发生改变的时候，变量的内存地址也发生了改变。所以整型是不可变的数据类型。

### 字符串

根据上面的实例，我们把变量x的值换成字符串试试，看能不能得出字符串是不可变数据类型的结论呢~

```python3
# 赋值
x = 'abcdefg'
# 打印x的内存地址和数据类型
print(id(x), type(x))

# 输出：30828000 <class 'str'>

# 改变x的值
x = 'higklmn'
# 打印改变后的x的内存地址和数据类型
print(id(x), type(x))

# 输出：30828168 <class 'str'>
```

代码中当变量改变时，变量的内存地址由30828000 变为了30828168 。所以字符串是不可变数据类型。

endwith 

split 

解释：拆分str，通过指定的sep对str进行分割，并返回分割后的**字符串列表**
       sep为[分隔符](https://so.csdn.net/so/search?q=分隔符&spm=1001.2101.3001.7020)，默认为所有空字符，包括空格（‘ ’），换行（\n)，制表符(\t)，但不可为空，若字符串中没有sep，则把整个字符串作为列表的一个元素；

```pyhton
    >>> x = 'with a moo-moo here, and a moo-moo there'
    >>> x.split()
    ['with', 'a', 'moo-moo', 'here,', 'and', 'a', 'moo-moo', 'there']
```



reverse 

lower

```python
>>> x = 'akAdFgP'



>>> x.lower()



'akadfgp'
```

### 元组

元组被称为只读列表，即数据可以被查询，但不能被修改。如果我们强行修改元组中的数据，会报错。

```python3
t = (1, 2, 3, 4, 5)
# 修改元组的值
t[1] = 100

会报错：TypeError: 'tuple' object does not support item assignment
```

### 可变数据类型

python中对可变数据类型的定义为：**当该数据类型的对应变量的值发生了改变，那么它对应的内存地址不发生改变，就称可变数据类型**。包括：set（集合）、list（列表）、dict（字典）

### 集合

我们先来看一下集合，定义一个集合set1，改变set1的值，且输出两次的内存地址

```python3
set1 = {1, 2, 3, '123'}
print("集合:", set1, "内存地址：", id(set1), "\t", "数据类型：", type(set1), "\t")

# 输出：集合: {1, 2, 3, '123'} 内存地址： 41388296     数据类型： <class 'set'>    


# 给set1添加一个元素
set1.add(100)
print("集合:", set1, "内存地址：", id(set1), "\t", "数据类型：", type(set1), "\t")

# 输出：集合: {1, 2, 3, 100, '123'} 内存地址： 41388296    数据类型： <class 'set'>    
```

从上面代码我们可以看出，即使一个集合发生了改变，这个集合的内存地址是不变的。所以集合是可变数据类型。

### 列表

```python3
list1 = [1, 2, 3, 4, 5]
print("列表:", list1, "内存地址：", id(list1), "\t", "数据类型：", type(list1), "\t")
# 输出：列表: [1, 2, 3, 4, 5] 内存地址： 1860168   数据类型： <class 'list'> 

list1[0] = 100
print("列表:", list1, "内存地址：", id(list1), "\t", "数据类型：", type(list1), "\t")
# 输出：列表: [100, 2, 3, 4, 5] 内存地址： 1860168     数据类型： <class 'list'>   
```





当列表中的值发生了改变时，内存地址依旧不变，所以列表是可变数据类型。

# 1. 列表元素逆序排列

```scss
list.reverse()
```

list.reverse() 方法，会直接在原来的列表里面将元素进行逆序排列，不需要创建新的副本用于存储结果，不需要重新申请空间来保存最后的结果，但是修改了原来的数据。

```scss
list[::-1] 
```

Python 的列表有一个特性叫做切片，mylist[:] 会返回 mylist 的副本，当start 、end 和 step 为负时，表示从反方向遍历，所以 mylist[::-1] 就能达到逆序的目的。相比于第一种方式，这种方式会另外创建副本来保存列表的所有元素，所以需要更多的内存空间。

```
reversed() 
```

reversed 方法会将列表逆序的结果存储到迭代器里面，这种方式不会改变原来的列表，也不会创建原来列表的完整副本，只会多出迭代器对象所占的空间，相对来说也比较高效。也就是说其返回值是一个迭代器，你可以将其理解为一个指针，指向原来的列表。





### 字典

字典是python中唯一的映射类型，采用键值对（key-value）的形式存储数据。字典中的key值必须是可哈希的数据类型，也就是整型，字符串，元组等。

```python3
dict1 = {'name': 'kkk', 'age': 18}
print("字典:", dict1, "内存地址：", id(dict1), "\t", "数据类型：", type(dict1), "\t")

# 字典: {'name': 'kkk', 'age': 18} 内存地址： 31033960      数据类型： <class 'dict'> 

dict1['sex'] = 'man'
print("字典:", dict1, "内存地址：", id(dict1), "\t", "数据类型：", type(dict1), "\t")

# 字典: {'name': 'kkk', 'age': 18, 'sex': 'man'} 内存地址： 31033960    数据类型： <class 'dict'>   
```

从上面代码可以看出，当字典中的元素发生改变时，内存地址不变，都是31033960。所以字典是可变数据类型。



### 字符串

#### 基本概念

字符串是 Python 中最常用的数据类型。我们可以使用引号( **'** 或 **"** )来创建字符串。

创建字符串很简单，只要为变量分配一个值即可。例如：

```python
>>> 'Hello World!' 
'Hello World!'
>>>
>>> "Hello World!" 
'Hello World!'
>>>
var1 = 'Hello World!'
var2 = "csdn"
```

#### 访问

Python 不支持单字符类型，也就是没有字符只有字符串，单字符在 Python 中也是作为一个字符串使用。

Python 访问子字符串，可以使用方括号 **[]** 来截取字符串，字符串的截取的语法格式如下：

```python
变量[头下标:尾下标]
```

```python
var1 = 'Hello World!'
var2 = "csdn"
 
print ("var1[0]: ", var1[0])
print ("var2[1:2]: ", var2[1:2])
    var1[0]:  H
    var2[1:2]:  sd
```

拼接

```python
var1 = 'Hello World!'
 
print ("已更新字符串 : ", var1[:6] + 'csdn.net')
```

Python转义字符

| 转义字符    | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| \(在行尾时) | 续行符                                                       |
| \\          | 反斜杠符号                                                   |
| \'          | 单引号                                                       |
| \"          | 双引号                                                       |
| \a          | 响铃                                                         |
| \b          | 退格(Backspace)                                              |
| \000        | 空                                                           |
| \n          | 换行                                                         |
| \v          | 纵向制表符                                                   |
| \t          | 横向制表符                                                   |
| \r          | 回车                                                         |
| \f          | 换页                                                         |
| \oyy        | 八进制数，yy 代表的字符，例如：\o12  代表换行，其中 o 是字母，不是数字 0。 |
| \xyy        | 十六进制数，yy代表的字符，例如：\x0a代表换行                 |
| \other      | 其它的字符以普通格式输出                                     |

#### 字符串运算符

| 操作符 | 描述                                                         | 实例                                                       |
| ------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
| +      | 字符串连接                                                   | a + b 输出结果：  HelloPython                              |
| *      | 重复输出字符串                                               | a*2 输出结果：HelloHello                                   |
| []     | 通过索引获取字符串中字符                                     | a[1] 输出结果 e                                            |
| [ : ]  | 截取字符串中的一部分，遵循左闭右开原则，str[0:2] 是不包含第 3 个字符的。 | a[1:4] 输出结果 ell                                        |
| in     | 成员运算符 - 如果字符串中包含给定的字符返回 True             | 'H' in a 输出结果  True                                    |
| not in | 成员运算符 - 如果字符串中不包含给定的字符返回 True           | 'M' not in a 输出结果  True                                |
| r/R    | 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。  原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 | print( r'\n' )   print( R'\n' )  ( r'\n' )  print( R'\n' ) |
| %      | 格式字符串                                                   | 请看下一节内容。                                           |

```python
a = "Hello"
b = "Python"
 
print("a + b 输出结果：", a + b)
print("a * 2 输出结果：", a * 2)
print("a[1] 输出结果：", a[1])
print("a[1:4] 输出结果：", a[1:4])
 
if( "H" in a) :
    print("H 在变量 a 中")
else :
    print("H 不在变量 a 中")
 
if( "M" not in a) :
    print("M 不在变量 a 中")
else :
    print("M 在变量 a 中")
 
print (r'\n')
print (R'\n')

    a + b 输出结果： HelloPython
    a * 2 输出结果： HelloHello
    a[1] 输出结果： e
    a[1:4] 输出结果： ell
    H 在变量 a 中
    M 不在变量 a 中
    \n
    \n
```

格式化

Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。

在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。



```
print ("我叫 %s 今年 %d 岁!" % ('小明', 10))
```

​	格式化符号

| 符   号 | 描述                                 |
| ------- | ------------------------------------ |
| %c      | 格式化字符及其ASCII码                |
| %s      | 格式化字符串                         |
| %d      | 格式化整数                           |
| %u      | 格式化无符号整型                     |
| %o      | 格式化无符号八进制数                 |
| %x      | 格式化无符号十六进制数               |
| %X      | 格式化无符号十六进制数（大写）       |
| %f      | 格式化浮点数字，可指定小数点后的精度 |
| %e      | 用科学计数法格式化浮点数             |
| %E      | 作用同%e，用科学计数法格式化浮点数   |
| %g      | %f和%e的简写                         |
| %G      | %f  和 %E 的简写                     |
| %p      | 用十六进制数格式化变量的地址         |





| 符号  | 功能                                                         |
| ----- | ------------------------------------------------------------ |
| *     | 定义宽度或者小数点精度                                       |
| -     | 用做左对齐                                                   |
| +     | 在正数前面显示加号( + )                                      |
| <sp>  | 在正数前面显示空格                                           |
| #     | 在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X') |
| 0     | 显示的数字前面填充'0'而不是默认的空格                        |
| %     | '%%'输出一个单一的'%'                                        |
| (var) | 映射变量(字典参数)                                           |
| m.n.  | m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)        |

三引号

```python
para_str = """这是一个多行字符串的实例

多行字符串可以使用制表符
TAB ( \t )。
也可以使用换行符 [ \n ]
"""
print (para_str)


    这是一个多行字符串的实例
    多行字符串可以使用制表符
    TAB (    )。
    也可以使用换行符 [ 
     ]。
```

#### 切片

**1.没有步长的简单切片**

- 首先定义一格字符串，比如叫s,然后给它赋值
- 截取字符串中的一部分，我们用的语法是 s[ start : stop ]
- start表示的是字符串要截取的开始下标，stop 表示终止的字符串结束的前一个位置。

**2.单个切片**

```python
url = 'http://c.biancheng.net/python/'#获取索引为10的字符
print(url[10])#获取索引为 6 的字符
print(url[-6])
```



从上面我们可以知道，如果从开头截取到某个特定的位置可以用 [ : a]来表示



如果从某一位开始截取到最后一位可以用[ a : ]来表示



### 列表

#### 基本概念

- 列表是有序的元素集合，所有元素放在一对中括号中，用逗号隔开，没有长度限制；
- 列表索引值以0为开始值，-1为从未尾的开始位置。
- 列表可以使用+操作符进行拼接，使用*表示重复。
- 当列表元素增加或删除时，列表对象自动进行扩展或收缩内存，保证元素之间没有缝隙；
- 列表中的元素可以是不同类型的

```javascript
list = ["zeruns","blog","blog.zeruns.tech",9527,[0,1,2,[1,2]]]#创建一个列表，一个列表里可以有多种数据类型，甚至可以嵌套列表来做二或三维列表
#          0       1           2             3       4
#         -5      -4          -3            -2      -1
print(list[0])
print(list[2])
print(list[4][2])
print(list[4][3][0])
print(list[-1])
print(list[-2])
'''
结果：
zeruns
blog.zeruns.tech
2
1
[0, 1, 2, [1, 2]]
9527
'''
```

#### 列表操作

| 列表操作符                            | 操作符含义                         |
| ------------------------------------- | ---------------------------------- |
| < list1 > + < list2 >                 | 连接两个列表                       |
| < list > * < 整数类型 >               | 对列表进行整数次重复               |
| < list >[< 整数类型 >]                | 索引列表中的元素                   |
| len( < seq > )                        | 获取列表中元素个数                 |
| for < var > in < list > :             | 对列表进行循环列举                 |
| < list >[< 整数类型 > : < 整数类型 >] | 取列表的一个子序列                 |
| < expr > in < list >                  | 成员检查，判断< expr >是否在列表中 |





列表方法

| 方法                    | 方法含义                        |
| ----------------------- | ------------------------------- |
| < list >.append( x )    | 将元素x增加到列表的最后         |
| < list >.sort( )        | 将列表元素排序，默认为升序      |
| < list >.reverse( )     | 将列表元素反转                  |
| < list >.index( )       | 返回第一次出现元素x的索引值     |
| < list >.insert( i, x ) | 在位置i处插入新元素x            |
| < list >.count( x )     | 返回元素x在列表中的数量         |
| < list >.remove( x )    | 删除列表中第一次出现的元素x     |
| < list >.pop( i )       | 取出列表中位置i的元素，并删除它 |

```javascript
>>> a = [2,0,9,1,5]
>>> b = ['c','w','b','a']
>>> a.append(9)
>>> a
[2, 0, 9, 1, 5, 9]
>>> a.sort()
>>> a
[0, 1, 2, 5, 9, 9]
>>> a.reverse()
>>> a
[9, 9, 5, 2, 1, 0]
>>> b.sort()
>>> b
['a', 'b', 'c', 'w']
>>> a.index(5)
2
>>> a.insert(2,7)
>>> a
[9, 9, 7, 5, 2, 1, 0]
>>> a.count(9)
2
>>> a.remove(9)
>>> a
[9, 7, 5, 2, 1, 0]
>>> a.pop(0)
9
>>> a
[7, 5, 2, 1, 0]
```

#### 列表推导式

- 列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。
- 它的结构是在一个中括号里包含一个表达式，然后是一个for语句，然后是 0 个或多个 for 或者 if 语句。那个表达式可以是任意的，意思是你可以在列表中放入任意类型的对象。返回结果将是一个新的列表，在这个以 if 和 for 语句为上下文的表达式运行完成之后产生。
- 列表推导式的执行顺序：各语句之间是嵌套关系，左边第二个语句是最外层，依次往右进一层，左边第一条语句是最后一层。

```javascript
data = [i for i in range(10)]
#等价于
data = []
for i in range(10):
data.append(i)
'--------------分割线---------------'
data = [2**i for i in range(10)]
#等价于
data = []
for i in range(10):
data.append(2**i)
'--------------分割线---------------'
data = [num for num in range(20) if num%2==1]
#等价于
data = []
for num in range(20):
if num%2==1:
    data.append(num)
```

### 字典

### 元组

#### 基本概念

- 元组（tuple）是包含多个元素的类型，元素之间用逗号分割 如：t1 =（123,456,"hello"）
- 可以通过把若干元素放在一对圆括号中创建元组，如果只有一个元素的话则需要多加一个逗号，例如（3,）。
- 也可以使用tuple()函数把列表、字典、集合、字符串以及range对象、map对象、zip对象或其他类似对象转换为元组。
- 元组可以是空的，t2=()
- 一个元组也可以作为另一个元组的元素，此时，作为元素的元组需要增加括号，从而避免歧义，如：t3=（123,456,("hello","world")）
- Python 的元组与列表类似，不同之处在于元组的元素不能修改。

定义

```python
t2 = ()          ##空元组的定义
print(type(t2))

t2 = ('xyy',)   ##单个内容元祖定义 【不加逗号为字符串类型】
print(type(t2))

t2 = ('xyy')  ##为字符串类型
print(type(t2))
```



#### 元组的使用

```javascript
>>> a = ('hello',2020,110)
>>> a
('hello', 2020, 110)
>>> a[1]
2020
```

元组中的元素值是**不允许修改和删除**的，但我们可以使用del语句来删除整个元组

```javascript
>>> a = ('hello',2020,'blog.zeruns.tech')
>>> print(a)
('hello', 2020, 'blog.zeruns.tech')
>>> del a
>>> print(a)
Traceback (most recent call last):
  File "<pyshell#24>", line 1, in <module>
    print(a)
NameError: name 'a' is not defined
```

所谓元组的不可变指的是元组所指向的内存中的内容不可变。

```python
>>> tup = ('r', 'u', 'n', 'o', 'o', 'b')
>>> tup[0] = 'g'     # 不支持修改元素
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> id(tup)     # 查看内存地址
4440687904
>>> tup = (1,2,3)
>>> id(tup)
4441088800    # 内存地址不一样了
```

#### 切片



```python
users = ('root','westos','redhat')
passwds = ('123','456','012'

print(users[0])
print(users[:1])   #切出第一个元素

```

重复

```
print(users * 3)l
```

链接

```
print(passwds + ('012','230'))
```

## python函数

### 1.函数function

函数是组织好的，可重复使用的，用来实现单一或相关联功能的代码段。

函数能提高应用的模块性，和代码的重复利用率。

Python提供了许多内建函数built-in，比如print()。

也可以自己创建函数，叫做用户自定义函数。

### 2.函数的定义（define）和调用（call）

定义一个函数的规则：
（1）函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。
（2）任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。
（3）函数内容以冒号 : 起始，并且缩进。
（4）函数体的第一行语句可以选择性地使用文档字符串—用于函数说明。
（5） return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。

Python 定义函数使用 def 关键字，一般格式如下：

```
def 函数名(参数列表):
    函数体
```

```
def hello():
    print("Hello World!")

hello()
```

可更改(mutable)与不可更改(immutable)对象

在 python 中，strings, tuples 和 numbers 是不可更改的对象，而 list, dict 等则是可以修改的对象。

    不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。
    
    可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。
（1）无参数、无返回值

```python
def 函数名():
	代码
```

（2）无参数、有返回值

```python
def 函数名():
	语句
	return 需要返回的数值
```

- 一个函数到底有没有返回值，就看有没有return，因为只有return才可以返回数据
- 在开发中往往根据需求来设计函数需不需要返回值
- 函数中，可以有多个return语句，但是只要执行到一个return语句，那么就意味着这个函数的调用完成

（3）有参数、无返回值

```python
def 函数名(形参列表):
	语句
```

（4）有参数、有返回值

```python
def 函数名(形参列表):
	语句
	return 需要返回的数值
```



```
#函数的定义
def printinfo():
    print('--'*30)
    print('  人生苦短，我用python  ')
    print('--'*30)

#函数的调用
printinfo()
printinfo()

#带参数的函数
def add2Num(a,b):
    c = a + b
    print(c)
add2Num(11,22)

#带返回值的参数
def add2Num(a,b):
   return a + b
result = add2Num(11,22)
print(result)   #33
print(add2Num(11,22))   #33


# 返回多个值的函数
def divid(a,b):
    shang  = a//b
    yushu  = a%b
    return shang,yushu  #多个返回值用逗号分隔
sh,yu = divid(5,2)  #需要使用多个值来保存返回内容
print('商：%d,余数：%d'%(sh,yu))
```



# 全局变量和局部变量使用

```
def test1():
    a = 300 #局部变量
    print('test1-----------修改前：a = %d'%a)
    a = 100
    print('test1-----------修改后：a = %d'%a)
def test2():
    a = 500 #不同的函数可以定义相同的名字，彼此无关
    print('test2-----------a = %d'%a)

test1()
test2()
```



# 全局变量和局部变量相同名字

a = 100 #全局变量
def test1():
    a = 300 #局部变量优先使用
    print('test1-----------修改前：a = %d'%a)
    a = 200
    print('test1-----------修改后：a = %d'%a)
def test2():
    #a = 500 #不同的函数可以定义相同的名字，彼此无关
    print('test2-----------a = %d'%a)

test1()
test2()  

# 全局变量和局部变量相同名字

```
a = 100 #全局变量
def test1():
    global  a #声明全局变量在函数中的标识符，声明之后所有函数访问全局变量的值a
    print('test1-----------修改前：a = %d'%a)
    a = 200
    print('test1-----------修改后：a = %d'%a)
def test2():
    print('test2-----------a = %d'%a)#没有局部变量，默认使用全局变量 #输出test2-----------a = 200

test1()
test2()
```

参数传递

参数

- 必备参数（位置参数）
- 关键字参数
- 默认参数
- 不定长参数
- 必备参数





在 python 中，类型属于对象，变量是没有类型的：

必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。

调用函数时，你必须传入一个参数，不然会出现语法错误

定义一个函数rt(a)，调用函数时没有传入实参：

```python
def rt(a):
    print(a)

rt(123)
rt('ASggh')
```



**关键字参数**

关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。

使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。

```python
# 可写函数说明
def printinfo(name, age):
    """打印任何传入的字符串"""
    print("Name: ", name)
    print("Age ", age)
    return

# 调用printinfo函数
printinfo(age=50, name="miki")
```



**默认参数**

调用函数时，默认参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：

```python
# 可写函数说明
def printinfo(name, age = 28):
    """打印任何传入的字符串"""
    print("Name: ", name)
    print("Age ", age)
    return

# 调用printinfo函数
printinfo(name='Carson')
printinfo(age=50, name="miki")
```

局部变量使用全局变量就要使用关键字global



不定长参数

你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。



**四：匿名函数**

python 使用 lambda 来创建匿名函数。

- lambda只是一个表达式，函数体比def简单很多。
- lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。
- lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。
   虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。

语法：

lambda函数的语法只包含一个语句，如下：

```python
lambda [arg1 [,arg2,.....argn]]:expression
```

```python
num = lambda x, y: x*y
print(num(3, 9))
print(num(7, 8))
```

返回值

- 函数体中 return 语句有指定返回值时返回的就是其值
- 函数体中没有 return 语句时，函数运行结束会隐含返回一个 None 作为返回值，类型是 NoneType，与 return 、return None 等效，都是返回 None。



```
def` `showplus(x):
  ``print``(x)
  ``return` `x ``+` `1
  
num ``=` `showplus(``6``)
add ``=` `num ``+` `2
print``(add)
```



```
输出结果：
6
9
```

```
def showplus(x):
    print(x)
 
num = showplus(6)
print(num)
print(type(num))
```

多条return返回语句



- python 函数使用 return 语句返回 "返回值"，可以将其赋给其它变量作其它的用处
- 所有函数都有返回值，如果没有 return 语句，会隐式地调用 return None 作为返回值
- 一个函数可以存在多条 return 语句，但只有一条可以被执行，如果没有一条 reutrn 语句被执行，同样会隐式调用 return None 作为返回值
- 如果有必要，可以显式调用 return None 明确返回一个None(空值对象)作为返回值，可以简写为 return，不过 python 中懒惰即美德，所以一般能不写就不写
- 如果函数执行了 return 语句，函数会立刻返回，结束调用，return 之后的其它语句都不会被执行了

```
def showplus(x):
    print(x)
    return x + 1
    print(x + 1)  #该语句会执行么

print(showplus(6))


输出结果：
6
7


def showplus(x):
    print(x)       # 5
    return x + 1   # 6
    return x + 2   # 该语句也不会被执行

print(showplus(5))


输出结果：
5
6


```



返回值类型

- 无论定义的是返回什么类型，return 只能返回单值，但值可以存在多个元素。
- return [1,3,5] 是指返回一个列表，是一个列表对象，1,3,5 分别是这个列表的元素
- return 1,3,5 看似返回多个值，隐式地被Python封装成了一个元祖返回
-  **函数**多个**返回值** python**的函数**支持返回多个值。返回多个值**时**，**默认以**tuple**的**方式返回

```
def fn():
    return 3   #单值时，返回的是什么类型
    
print(fn())
print(type(fn()))


输出结果：
3
<class 'int'>    #int 整数类型


def fn():
    return 3   #单值时，返回的是什么类型
    
print(fn())
print(type(fn()))


输出结果：
3
<class 'int'>    #int 整数类型


def showlist():
    return (2,4,6)   #多元素，返回的是什么类型

print(type(showlist()))
print(showlist())


输出结果：
<class 'tuple'>    #元祖类型
(2, 4, 6)




```



函数的嵌套

```
def outer():
    def inner():  #可以理解为内部函数
        print("inner")  
    print("outer")
outer()


输出结果：
outer
```

此时如果调用 outer()，只会执行 print("outer")，因为 inner 虽然在 outer 函数内，但它也是一个函数，函数如果要调用，就必须用 '函数名()' 方式。

```
def outer():
    def inner():
        print("inner")
    print("outer")

inner()   #外部无法引用内部函数，内部函数只在本地作用域有效


输出结果，抛出异常：
Traceback (most recent call last):
  File "C:/python/return_value.py", line 6, in <module>
    inner()
NameError: name 'inner' is not defined
```



个数可变的位置参数
定义函数时，可能无法事先确定传递的位置实参的个数时，使用可变的位置参数
使用*定义个数可变的位置形参
结果为一个元组

```
def fun(*arg):
	print(arg)
	
fun(10)
fun(10,20)
```



个数可变的关键字形参
·定义函数时，无法事先确定传递的关键字实参的个数时，使用可变的关键字形参
使用**定义个数可变的关键字形参
结果为一个字典



```
def fun(**arg):
	print(arg)
	
fun(a=10)
fun(a=10,n=20)
```





构造函数

Python是一门面向对象的编程语言，面向对象是一种代码封装的技术，包含了各种功能，让代码能重复利用、高效节能。

我们通过class来定义类，类又包含了属性、方法等，属性是类里面的变量，方法是类里面的函数

而__init__就是其中一种函数，叫做构造函数。

```text
def __init__(self,...):
    代码块
```

### 全局变量：所有函数之外定义的变量

### 局部变量：函数内部定义的变量 或者代码块里的变量

1.函数内部的变量名如果第一次出现，且出现在=前面，即被视为定义了一个局部变量，不管全局域中有没有该变量名，函数中使用的将是局部变量。

(即声明了一个新的局部变量。如果这个变量名字和全部变量名字相同，那么局部变量名字会覆盖全局变量名字。

```
#[demo1]
num = 100  
def func():  
    newValue = 123   #一个全新的局部变量newValue 
    print(newValue)  

func()  #输出局部变量newValue 即新的局部变量


#[demo2]
num = 100  
def func():  
    num= 123  #声明一个全新的局部变量num，虽然名字和外界的全部变量相同 但是是新的一个变量且是局部有效的。屏蔽了外面的同名的全部变量
    print(num)  

func()  #输出局部变量num=123 即新的局部变量。
```

2.如果局部变量用到了一个变量。该变量是全局存在的，但是局部并没有声明这么一个变量。那么此时参与运算的是全局变量。但是这个参与运算是不能被赋值的，因为你赋值的时候按照python的语法那就是新生成一个局部变量，而且你在右侧使用的话。那就是会报错。

```
#[demo1]
num = 100  
def func():  
    x = num+200  #使用值做参数，那么其实是copy一份num全部变量的值
    print(x)
    print(id(num))  #id值

func()  #输出300  即没有局部变量声明 那么使用就是全局变量
print(id(num))  #id值


#[demo2]

list = [100] 
def func():  
    list.append(200) #直接使用变量，那么得到了全局变量 操作全局变量。
    print(list)
    print(id(list))

func()  #输出[100,200]
```

3.如果你想在局部变量修改全局变量。

因为本身是不能的，你修改然后赋值的时候会出现矛盾。即你涉及到赋值var = xxx 修改的时候，那么会被语法解析会声明一个新的局部变量var。当然对象类型除外，你可以直接操作他的元素。

```
#[demo1]
num = 100  
def func():  
    num= 123   #本来你的意图是赋值给全局变量Num,但是此处会被解析为声明一个全新的局部变量num
    print(id(num))  

func()  #输出局部变量newValue 即新的局部变量
print(id(num))

那么怎么办？才能在局部变量赋值修改全局变量
```

### [关键字 global]

```
#[demo1]
Num = 100  
def func():  
    global Num  #声明这个Num是全局的哦。如果全局变量已经有这个Num变量那就是指的它 如果全局没这个Num那就新定义一个全局变量。
    Num  = 200  #此时此刻 凡是在函数内部Num的意思始终是指全局变量。不可能有个局部变量叫Num的。
    print(Num )  

func()  
print(Num ) #输出200 说明修改的就是全局变量啊

#[demo2]
def func():  
    global Num  #声明这个Num是全局的哦。而且恰恰是此时没有一个全局变量是Num。那么如果全局没这个Num那就新定义一个Num的全局变量。
    Num  = 200  
    print(Num )  

func()  
print(Num ) #输出200 说明新定义了一个全局变量Num

```



匿名函数

python 使用 lambda 来创建匿名函数。

    lambda这个名称来自于LISP，而LISP则是从lambda calculus(一种符号逻辑形式)取这个名称的。
    在Python中，lambda作为一个关键字，作为引入表达式的语法。想比较def函数，lambda是单一的表达式，而不是语句块!

所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。

    lambda 只是一个表达式，函数体比 def 简单很多。
    lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。
    lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。
    虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。

语法
lambda 函数的语法只包含一个语句，如下：

lambda [arg1 [,arg2,.....argn]]:expression

#  lambda 参数列表：return [表达式] 变量
#  由于lambda返回的是函数对象（构建的是一个函数对象），所以需要定义一个变量去接收

    1
    2
    3
    4

实例一

# 可写函数说明
sum = lambda arg1, arg2: arg1 + arg2;

# 调用sum函数
print ("相加后的值为 : ", sum( 10, 20 )) # 相加后的值为 :  30
print ("相加后的值为 : ", sum( 20, 20 )) # 相加后的值为 :  40

    1
    2
    3
    4
    5
    6
    7

实例二

对字典排序

infors = [{"name":"wang","age":10},{"name":"xiaoming","age":20},{"name":"banzhang","age":10}]

infors.sort(key=lambda x:x['age']) #根据age对字典排序

print(infors)

＃　排序结果　　[{'name': 'wang', 'age': 10}, {'name': 'banzhang', 'age': 10}, {'name': 'xiaoming', 'age': 20}]

    1
    2
    3
    4
    5
    6
    7

实例三

把lambda当一个变量

def test(a,b,func):
    result = func(a,b)
    return result


num = test(11,22,lambda x,y:x+y)
print(num)

    1
    2
    3
    4
    5
    6
    7

匿名函数优点

    使用Python写一些脚本时，使用lambda可以省去定义函数的过程，让代码更加精简。
    对于一些抽象的，不会被别的地方再重复使用的函数，有时候函数起个名字也是个难题，使用lambda不需要考虑命名的问题
    使用lambda在某些时候然后代码更容易理解

其他高阶函数
map()函数

map()是 Python 内置的高阶函数，它接收一个函数 f 和一个list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。

def f(x):
    return x * x
print map(f,[1,2,3,4,5,6,7]) #list里的每个元素都会走一遍f(x)方法

    1
    2
    3

结果将会是：

[1, 4, 9, 10, 25, 36, 49]

    1

reduce()函数

reduce()函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。

def f(x ,y ):
    return x * y
    print reduce(f,[1,2,3,4]) #1*2*3*4=24

# 给初始值
def f(a,b):
    return a+ b
    print reduce(f,[1,2,3,4],10) #1+2+3+4+10.这里的第三个参数是做为初始值的。

    1
    2
    3
    4
    5
    6
    7
    8

filter()函数

filter()函数是 Python 内置的另一个有用的高阶函数，filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。

def is_odd(x):
    return x%2==1
    print filter(is_odd,[1,2,3,4,5,6,7]) # [1, 3, 5, 7]

    1
    2
    3

sorted()函数

sorted() 函数对所有可迭代的对象进行排序操作。

    sort 与 sorted 区别：
    sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。
    list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。

语法
sorted 语法：

sorted(iterable[, cmp[, key[, reverse]]])

    1

参数说明：

    iterable -可迭代对象。
    cmp -比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。
    key -主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
    reverse -排序规则，reverse = True 降序 ， reverse = False 升序（默认）。

返回值

　　　返回重新排序的列表。

>>>a = [5,7,6,3,4,1,2]
>>>b = sorted(a)       # 保留原列表
>>>a 
>>>[5, 7, 6, 3, 4, 1, 2]
>>>b
>>>[1, 2, 3, 4, 5, 6, 7]

>>> L=[('b',2),('a',1),('c',3),('d',4)]
>>> sorted(L, cmp=lambda x,y:cmp(x[1],y[1]))   # 利用cmp函数
>>> [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
>>> sorted(L, key=lambda x:x[1])               # 利用key
>>> [('a', 1), ('b', 2), ('c', 3), ('d', 4)]


>>> students = [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
>>> sorted(students, key=lambda s: s[2])            # 按年龄排序
>>> [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

>>> sorted(students, key=lambda s: s[2], reverse=True)       # 按降序
>>> [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]



pandas中的两种用来进行数据处理的数据结构是Series和

## 文件操作





**i for i in range(1,100) if i%13==0**



lambda

ls.insert(3,"012")

ls.insert(3,"012")

当作为条件表达式时，空值、空字符串、空列表、空元组、空字典、空集合、空迭代对象以及任意形式的数字0都等价于false





```
class Course:
    def __init__(self,number,name,uin):
        self.number=number
        self.name = name
        self.uin = uin
    def printInfo(self):
        print(f'{self.number} {self.name} {self.uin}')
if  __name__=='__main__':
    python=Course(1,'pyhton程序设置',3.5)
    python.printInfo()
```

```python
#计算三角形的面积

import math

#输入三条边

a=float(input("请输入三角形的第一条边："))

b=float(input("请输入三角形的第二条边："))

c=float(input("请输入三角形的第三条边："))

#计算面积

s=(a+b+c)/2

area=math.sqrt(s*(s-a)*(s-b)*(s-c))

#输出结果

print("三角形的面积是：%f"%area)
```

```python
def clc_fee(no,weight):
    if no == '01':
        if weight <= 2:
            return 13
        fee = 13 + (weight-2)*3
        return fee
    if no == '02':
        if weight <= 2:
            return 12
        fee = 12 + (weight-2)*2
        return fee
    if no == '03':
        if weight <= 2:
            return 14
        fee = 14 + (weight-2)*4
        return fee
zone = {'01':'华东地区','02':'华南地区','03':'华北地区'}

if __name__ == '__main__':
    while True:
        no = input('请输入寄件服务地区的编号(01/02/03，-1退出)：')
        if no == '-1':
            break
        weight = eval(input('请输入快件重量：'))
        fee = clc_fee(no,weight)
        print('fee：',fee)
        with open('data.txt','a') as f:
            f.write('{} {} {}\n'.format(zone[no],weight,fee))

```

```
s=[]
with open("test.txt") as f:
    for line in f:
        n,g=line.split()
        g=g.strip()
        s.append(float(g))
sum =0
average=0
for i in s:
    sum =sum+i
    average=sum/len(s)

print(average)
```

