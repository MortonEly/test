# 软考

# 计算机系统组成

1. 计算机系统的**五大层次结构**：微指令机器、机器语言机器、操作系统机器、汇编语言机器、高级语言机器
2. **三种级别的语言**和对应程序：高级语言、汇编语言、机器语言（编译程序和解释程序）

## 计算机系统概述

计算机硬件是看得见摸得着的物理装置，软件是程序、数据和文档



计算机硬件主要由运算器、控制器、存储器、输入输出设备五大部分组成，集成在一起的运算器和控制器称为中央处理单元（Central processing unit,CPU)。现代计算机大多基于冯.诺依曼结构。





### 计算机类型和应用

- 按工作能力，分为巨型机、大型机、小型机和微型机。微型机有多种形式，如个人计算机(PC)、台式计算机（desktop)、膝上电脑（laptop)、笔记本电脑(notebook)、工作站(workstation)、掌上电脑、个人数字助理(Personal Digital Assistant,PDA).
- 按功能是否专一，分为：通用计算机和嵌入式计算机。
- 按处理指令和数据的方式，分为：SlSD、SlMD(Single Instruction-stream Multiple Data-stream)、MlsD、MlMD.
- 应用领域：数值计算、信息处理、实时控制、人工智能、计算机辅助设计(computer--aided design,CAD)、计算机辅助教学（Computer-.aided instruction,CA)、计算机辅助管理（computer-.aided manage,CAM

### CPU的功能

CPU有如下基本功能：
①程序控制：CPU通过执行指令来控制程序的执行顺序。
②操作控制：CPU根据指令产生操作信号，并将操作信号送往各部件，控制它们协调完成指令要求的操作。
3时序控制：CPU通过时序电路产生的时钟信号进行定时，控制各种操作按照指定的时序进行。
④数据处理：完成对数据的加工处理。异常处理和中断处理：对CPU内部的意外情况进行处理：对于外围设备发出的中断请求进行处理

CPU主要由算术逻辑单元、控制单元(CU)和各种寄存器组成，这些部件通过CPU内总线连接起来。而CPU、存储器和I/O设备则同过系统总线连接起来。



### 运算器

运算器一般包括算术逻辑单元(ALU)、累加器(ACC)、标志寄存器(状态寄存器，亦称程序状态字寄存器PS)、通用寄存器组等部件组成。
ALU用于完成加减乘除算术运算和与、或、非等逻辑运算，以及求补、移位操作。
通用寄存器组用于暂存操作数或者数据地址。标志寄存器用于暂存运算过程中产生的状态信息。
ACC用于暂存运算结果以及向ALU提供运算对象。



### 控制器

控制器主要由程序计数器(PC)、指令寄存器(1R)、指令译码器、状态/条件寄存器(PS渭)、时序部件和微操作形成部件组成。
在程序顺序执行时，每当取出一条指令，P℃的内容自动增加一个值，指向下一条指令。若出现转移，则将转移地址送到℃，PC指向新的地址。
指令寄存器用于存放正在执行的指令。
PSW用于保存指令执行完成之后产生的条件码，例如，运算是否有溢出，结果是正还是负，是否有进位等。此外，其还保存中断和系统工作状态。
微操作形成部件根据指令提供的操作信号、时序信号以及各部件的状态信号等综合成特定的操作序列，形成微操作控制信号送往各处执行。

### 指令格式

一条指令一般包括两个基本组成部分：操作码和地址码。前者用来说明指令的功能及操作性质，后者用来指出操作对象，它指出操作数或操作数地址及指令执行结果的地址。



### 寻址方式

寻址方式就是如何对指令中的地址字段进行解释，以获得操作数或者程序转移地址的方法。
立即寻址：操作数就包含在指令中，不需要到内存去取。比如：ADD,AX,100,其中100为立即数。0
直接寻址：操作数存放在内存中，指令给出操作数所在内存单元的地址。比如：ADD AX,(10)。内存地址为10的存储单元的内容是操作数。
寄存器寻址：操作数存放在寄存器中，指令中给出寄存器的名称。比如，AD0AX,100.
寄存器间接寻址：操作数存放在内存中，操作数的所在内存单元的地址存在寄存器中，指令中给出该寄存器的名称。比如，ADD AX,(BX)

间接寻址：指令中给出操作数的地址的地址，要访问内存两次。比如，ADD AX,((10)),10表示操作数地址的地址。
相对寻址：指令地址码部分给出的是相对本条指令地址的偏移量（可正可负），本条指令的地址可从当前PC中获得。比如，ADD AX,*1O,若PC中内容为5，那么内存地址为105的单元中的内容为该指令的操作数。
变址寻址：操作数地址等于变址寄存器的内容加上偏移量。比如，ADOAX(D1+10),其中，第二个操作数采用的就是变址寻址方式。



算术、逻辑移位指令
操作数各位顺序往某一方向移动称为移位。移位指令主要有三种类型：算术移位、逻辑移位和循环移位。
算术移位指令对带符号数进行移位。逻辑移位指令对无符号操作数进行移位。



循环移位指令
循环移位指令分为带进位循环移位和不带进位循环移位两大类：



接口
接口指两个相对独立的子系统之间的相连部分（转换机构），也常称为界面。用于连接机和输入输出设备的转换机构称为/O接口电路。
按数据传输方式接口可分为：并行接口、串行接口，并行接口同时传输一个字节或者字中的所有位，而串行接口只能一位一位的按顺序传输数据位。并行接口适合传输距离近、速度要求高的场合，后者则适合传输距离远、速度要求低的场合。
按时序控制方式可分为同步接口和异步接口。
按主机访问VO设备的控制方式，可分为程序查询接口、中断接口、DMA接口、通道控制器、VO处理机等。



主机与外设的连接方式及外设编址
常见的主机跟外设的连接模式有总线型、通道方式和O处理机，而总线方式是最基本的互连方式。
I/○接口地址与内存地址的编址方法主要有两种：V○接口与内存单元统一编址：VO接口独立址。
i/O接口与内存单元统一编址的优点在于无须设置专门的/O操作指令，其缺点是地址空间被分成两部分，会导致内存地址不连续，另外不易区分指令是对内存操作还是对接口操作。
I/O接口独立编址的方式缺点在于接口指令太少、功能太弱，优点是不占有
内存空间，容易区分对内存和接口的操作。

### 中央处理器(CPU)

### 指令系统

### 输入输出技术

### 总线



## 存储系统

### 存储器的分类

#### 按在计算机中的作用分类

##### 主存储器   

- CPU可直接随机的对其访问
- 存放计算机运行期间需要的程序和数据
- 容量小，存取速度快，位价高

##### 辅助存储器   

- 其中的内容需要调入主存后才能被CPU访问
- 存放当前暂时不用的程序和数据
- 容量大，存取速度慢，位价低

##### 高速缓冲存储器   

- 位于CPU和主存之间
- 存放当前CPU经常使用的指令和数据
- 容量小，存取速度可和CPU的速度相配，位价高

#### 按存取方式分类

##### 随机访问存储器 RAM   

- 可随机访问任何一个存储单元
- 存取时间和存储单元的物理位置无关
- 读取方便，使用灵活，主要用作主存和cache
- 分为动态RAM 和 静态RAM

##### 只读存储器 ROM   

- 信息一旦写入就固定不变，即使断电信息也不会丢失
- 存取方式为随机存取
- ROM和RAM共同组成主存
- 派生出了可反复重写的ROM，e.g.PROM,EPROM等

##### 串行访问存储器   

- 对存储单元读写时，需按其物理位置的先后顺序寻址
- 顺序存取存储器     
  - 只能按一定的顺序存取
  - 存取时间与信息在存储体上的物理位置有关
  - 存取速度慢



主存一般由RAM、ROM两种形式的存储器构成，RAM占绝大部分空间。

性能指标主要有存储周期、带宽。存储周期指连续两次访问存储器的最小时间间隔，带宽指存储器的每秒传输的数据位数。



## cache

我们都知道，CPU主频的提升会带动系统性能的改善，但系统性能的提高不仅取决于CPU，还与系统架构、指令结构、信息在各个部件之间的传送速度及存储部件的存取速度等因素有关，特别是CPU与主存之间的存取速度有关。
若CPU工作速度特别高，但内存存取速度相对较低，则造成CPU等待，降低处理速度，一定程度上是在浪费CPU的能力。
由以上两点，我们得知要想进一步改善计算机系统的性能，就应该减少CPU与内存之间的速度差异，所以我们可以在慢速的DRAM和快速的CPU之间插入一至多级的速度较快、容量较小的SRAM起到缓冲作用；使CPU既可以较快地存取主存中的数据，又不使系统成本上升过高，这就是Cache法。



### **cache-高速缓存存储器**

在主存与CPU之间插入一级或多级SRAM组成的高速缓存存储器。扩展cache有限，因为SRAM价格昂贵。

cache作用：为了解决CPU和主存之间速度不匹配而采用的一项重要技术。

cache特性：具有空间局部性以及时间局部性。

cache的组成：SRAM和控制逻辑。如果cache在CPU芯片外，它的控制逻辑一般和主存控制逻辑合成在一起，称主存/cache控制器。若cache在CPU内，则由CPU提供它的控制逻辑。

CPU与cache之间的数据交换是以字为单位，而cache与主存之间的数据交换是以块为单位。一个块由若干字组成，是定长的。



### **cache原理图**



**ache的命中率：**为了使主存的平均读出时间尽可能接近cache的读出时间，cache命中率应接近于1.

**地址映射**



含义：为了把主存块放到cache中，必须应用某种方法把主存地址定位到cache中，称作地址映射。

地址映射方式：全相联映射方式、直接映射方式和组相联映射方式。

**全相联映射方式**





## 外存

### 磁盘基本概念

磁盘存储器有两种，一种是软盘，另一种为硬盘。

磁道就是磁盘上的一组同心圆，其宽度与磁头的宽度相同。为了避免减小干扰，磁道与磁道之间要保持一定的间隔(inter-tack gap),沿磁盘半径方向，单位长度内磁道的数目称之为道密度，最外层为0道。
沿磁道方向，单位长磨内存储二进制信息的个数叫位密度。为了简化电路设计，每个磁道存储的位数都是相同的，所以其位密度也随着从外向内而增加。

磁盘的数据传输是以块为单位的，所以磁盘上的数据也以块的形式进行存放。这些块就称为扇区(sector),每个磁道通常包括10~100个扇区。同样为了避免干扰，扇区之间也相互留有空隙。
柱面：各盘片相同的磁道处于同一柱面上，柱面编号跟磁道编号一样。

磁盘参数
磁盘的存取时间包括寻道时间和等待时间。寻道时间为磁头移动到目标磁道所需的时间。等待时间为等待读写的扇区旋转到磁头下方所用的时间。一般选用磁道旋转一周所用时间的一半作为平均等待时间。
磁盘的非格式化容量为Cnw×3.14×d×m×n,其中w为位密度，d为最内9直径，m为记录面数，n为每面磁道数。磁盘格式化后能够存储有用信息的总量。存储容量=n×tXs×b,其中：n为保存数据的总盘面数：t为每面磁道数：s为每道的扇区数：b为每个扇区存储的字节数。
磁盘的数据传输速率是指磁头找到地址后，单位时间写入或读出的字节数。R=QT,其中：T为一个磁道上记录的字节数，T为磁盘每转一圈所需的时间，R为数据传输速率。也可表示为R=每个扇区的字节数X每道扇区数×磁盘的转速。

公式：

    有效储存区域=(外直径-内直径)÷2
    磁道数= 圆柱面数量=有效储存区域×磁道密度
    总磁道数= 记录面数×磁道密度×有效储存区域
    每磁道的信息量=内层位密度×内层周长
    面信息量=磁道数×每磁道信息量
    非格式化盘组总容量=面信息量×面数
    格式化容量=总磁道数×每道扇区数×扇区容量
    平均数据传输速率=最内圈直径×3.14×位密度×盘片转速
     
    平均等待时间 
    eg:
    如果某硬盘的平均等待时间（指需要读／写的扇区旋转到磁头下面
    的平均时间）为10ms，则该硬盘的转速约为? 

解析：

    “有存取方式分类可知，磁盘采取直接存取方式，寻址时间分为两个部分，其一是磁头寻找目标磁道的找道时间t(s),其二是找道磁道后
    磁头等待欲读写的磁道区段旋转到磁头正下方所需要的等待时间t(w).由于从最外磁道找到最里圈磁道和寻找相邻磁道所需时间是不等的，而且磁头等待不同区段所花的时间也不等，因此取其平均值
    称作平均寻址时间T（a），它是平均找道时间t(sa)和平均等待时间t(wa)之和：
    T(a)=t(sa)+t(wa)=[t(s max)+t(s min)]/2+[t(w max)+t(w min)]/2”原文结束。
    老师一顿验算....省略n行（原谅我得无奈吧）。得出结果：
    T(a)=1/2v （v为磁盘转速 单位：转/s）。
    所以10ms=1/(2v) v=50转/s=3000转/分.
# DMA方式



**DMA与主存交换数据的三种工作方式**
**1、停止CPU访问主存**
CPU放弃了对总线的控制权，放弃了对主存的访问。
控制简单
CPU处于不工作状态或保持状态，未充分发挥CPU对主存的利用率



**2、周期挪用（周期窃取）**
周期指访存周期，占用一个或几个内存访问周期完成数据的传输
DMA访问主存有三种可能

- CPU此时不访存
- CPU正在访存
- CPU与DMA同时请求访存：此时CPU将总线控制权让给DMA



**3、DMA与CPU交替访问**
CPU工作周期:C1专供DMA访存，C2专供CPU访存
不需要申请、建立和归还总线的使用权



**DMA接口的功能和组成**

**DMA接口功能**

1. 向CPU申请DMA传送
2. 处理总线控制权的移交
3. 管理系统总线、控制数据传送
4. 确定数据传送的首地址和长度，修正传送过程中的数据地址和长度
5. DMA传送结束后，给出操作完成信号

> 利用DMA方式传送数据时，数据的传送过程完全由DMA接口电路控制

DMA方式的接口电路中有程序中断部件，其作用是向CPU提出传输结束'



**DMA的工作过程**

**DMA传送过程**
预处理、数据传送、后处理
1、预处理
通过几套输入输出指令预置如下信息
通知DMA控制逻辑传送方向（入\出）
设备地址——DMA的DAR
主存地址——DMA的AR
传送字数——DMA的WC

2、DMA传送过程示意







**3、数据传送过程（输入）**





**4、数据传送过程（输出）**





> DMA方式是以数据块为单位传送的。

**5、后处理**
校验送入主存的数是否正确
是否继续用DMA
测试传送过程是否正确，错则转诊断程序

> 由中断服务程序完成

**DMA接口与系统的连接方式**

**具有公共请求线的DMA请求**
串行连接方式







约靠近CPU的DMA接口优先级越高。

**独立的DMA请求**





**DMA方式和程序中断方式的比较**

| 中断方式     | DMA方式      |              |
| ------------ | ------------ | ------------ |
| 数据传送     | 程序         | 硬件         |
| 响应时间     | 指令执行结束 | 存取周期结束 |
| 处理异常情况 | 能           | 不能         |
| 中断请求     | 传送数据     | 后处理       |
| 优先级       | 低           | 高           |

**DMA接口类型**

**选择型**
在物理上连接多个设备
在逻辑上只允许连接一个设备



**多路型**
在物理上连接多个设备
在逻辑上允许连接多个设备同时工作



总线定义和分类

总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线。总线是一种内部结构，它是 cpu、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。

比如输入、输出设备通过总线连接 CPU。

因为早期的计算机大多采用的是分散的连接方式，它是以运算器为中心的结构，内部连线十分复杂（每次新增一个输入设备，都需要单独连接到存储器、运算器和控制器），尤其是当 I/O 与存储器交换信息时，都需经过运算器，致使运算器停止运算,严重影响了 CPU 的工作效率。

而加入总线后，输入、输出设备可以直接连接到总线上，由总线来由 CPU 交互，这样计算机整个线路结构就变得更加清晰，CPU 的效率也更高。

## **2. 总线的分类**

## **2.1 片内总线**

片内总线是指**「芯片内部」**的总线，如在 CPU 芯片内部，寄存器与寄存器之间、寄存器与算逻单元 ALU 之间都由 片内总线连接。

## **2.2 系统总线**

系统总线是指 CPU、主存、IO 设备（通过I/O接口）各大部件之间的信息传输线。由于这些部件通常都安放在主板或各个插件板(插卡)上，故又称板级总线(在一块电路板上各芯片间的连线)或板间总线。



系统总线的分类：

- 数据总线
- 地址总线
- 控制总线



### **2.2.1 数据总线**

数据总线用来传输各功能部件之间的数据信息，它是**「双向传输总线」**，其位数与机器字长、存储字长有关，一般为 8 位、16 位或 32 位。数据总线的位数称为数据总线宽度，它是衡量系统性能的一个重要参数。

### **2.2.2 地址总线**

地址总线主要用来指出数据总线上的源数据或目的数据在主存单元的地址或 I/O 设备的地址。

例如，欲从存储器读出一个数据，则 CPU 要将此数据所在存储单元的地址送到地址线上。

又如，欲将某数据经 I/O 设备输出，则 CPU 除了需将数据送到数据总线外，还需将该输出设备的地址（通常都经 I/O 接口）送到地址总线上。

可见,地址总线上的代码是用来指明 CPU 欲访问的存储单元或 I/O 端口的地址,由 CPU 输出，单向传输。

地址线的位数与存储单元的个数有关，如地址线为 20 根，则对应的存储单元个数为 220。

### **2.2.3 控制总线**

由于数据总线、地址总线都是被挂在总线上的所有部件共享的，如何使各部件能在不同时刻占有总线使用权，需依靠控制总线来完成，因此控制总线是用来发出各种控制信号的传输线。

通常对任一控制线而言，它的传输是单向的。例如，存储器读/写命令或 I/O 设备读/写命令都是由 CPU 发出的。

但对于控制总线总体来说，又可认为是双向的。例如，当某设备准备就绪时，便向 CPU 发中断请求；当某部件（如 DMA 接口）需获得总线使用权时，也向 CPU 发出总线请求。

此外，控制总线还起到监视各部件状态的作用。例如，查询该设备是处于“忙”还是“闲”，是否出错等。因此对 CPU 而言，控制信号既有输出，又有输入。

常见的控制信号如下：

- 时钟：用来同步各种操作。
- 复位：初始化所有部件。
- 总线请求：表示某部件需获得总线使用权。
- 总线允许：表示需要获得总线使用权的部件已获得了控制权。
- 中断请求：表示某部件提出中断请求。
- 中断响应：表示中断请求已被接收。
- 存储器写：将数据总线上的数据写至存储器的指定地址单元内。
- 存储器读：将指定存储单元中的数据读到数据总线上。
- I/O读：从指定的I/O端口将数据读到数据总线上。
- I/O写：将数据总线上的数据输出到指定的I0端口内。
- 传输响应：表示数据已被接收,或已将数据送至数据总线上。
- 

## **2.3 通信总线**

这类总线用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通信等）之间的通信。

由于这类联系涉及许多方面，如外部连接、距离远近、速度快慢、工作方式等，差别极大，因此通信总线的类别很多。

但按传输方式可分为两种**「串行通信」**和**「并行通信」**。

串行通信是指数据在单条 1 位宽的传输线上，一位一位地按顺序分时传送。如 1 字节的数据，在串行传送中，1字节的数据要通过一条传输线分 8 次由低位到高位按顺序逐位传送。

并行通信是指数据在多条并行 1 位宽的传输线上，同时由源传送到目的地。如 1 字节的数据，在并行传送中，要通过 8 条并行传输线同时由源传送到目的地。

**「并行通信适宜于近距离的数据传输，通常小于 30m；串行通信适宜于远距离传送，可以从几米达数千公里。」**

而且，串行和并行通信的数据传送速率都与距离成反比。在短距离内，并行数据传送速率比串行数据传送速率高得多。

随着大规模和超大规模集成电路的发展，逻辑器件的价格趋低，而通信线路费用趋高，因此对远距离通信而言，采用串行通信费用远比并行通信费用低得多。

此外，串行通信还可以利用现有的电话网络来实现远程通信，降低了通信费用。



总线是连接多个设备的信号传送通道，实际上是一组信号线，通过分时复用方式进行共享。
总线不仅仅是一组信号线，从广义上讲，总线是一组传送线路及其相关的协议，要实现分时共享就必须制定相应的规则，称之为总线协议。
总线可分为下面几类：
①芯片内总线：用于集成电路芯片内部各部分的连接，如CPU内部总线。
②元件级总线：用于一块电路板内各元件的连接。
③内总线：用于连接CPU、内存、接口等计算机各组成部分，又称为系统总线，系统总线根据功能又分为数据总线、地址总线、控制总线。
④外总线：用于计算机与外设、计算机之间的连接，又称为通信总线。

内总线
lSA:16位工业标准总线，与更早的PC兼容，在PC上扩展而成，能兼容早期的8位总线，最大传输速率为8Mb/s.
EISA:32位总线，是ISA的扩展，传输速率达到33MB/S.
PCI总线：目前微机上广泛采用的内总线，其有两种标准：适用于32位机的124个信号的标准和适用于64位机的188个信号的标准，其速率分别为133MB/s、266MB/s.

# 例题

构成4M×8bit的存储器，若采用256K×8bit的芯片，需__(25)__片：若采用512K×lbit的芯片，需__(26)__片

25.16片，26，64片。
过程：25，4*1024*8/（256*8）=16
26，4*1024*8/（512*1）=64。

内存按字节编址，单位为(字节)byte，存储器容量按位编址，单位为（比特）bit,要注意单位之间的换算。 

  根据公式：（最高地址-最低地址+1）/单片[存储器](https://www.baidu.com/s?wd=存储器&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)容量=((400FFFFFH-40000000H+1）byte/1024)k*8bit/ 256*8bit=4 



## 第四章 输入输出系统

### 4.1 输入输出概述

### 4.1.1 输入输出系统的组成

输入输出系统由 I/O 软件和 I/O 硬件两部分组成。

> I/O 软件

（1）I/O指令

I/O指令属于CPU，由操作码、命令码、设备码三部分组成。

1. 操作码: I/O 指令标志

- 操作码为真，则代表为I/O指令



1. 命令码: 指令功能，读、写、检测、控制命令
2. 设备码: 地址码，指明 I/O 指令要访问的设备地址



（2）通道指令

- CPU内部的专用处理器，只能进行输入输出操作。通道的级别是处理器的级别，因此有自己的指令集。
- 通道自身的指令，用于执行I/O操作，存放于主存，由通道执行，完成输入输出功能。
- 在具有通道的计算机中，I/O指令不负责数据输入输出，而主要完成启停设备、通道控制，实际数据传输由通道完成。

> I/O 硬件

通道 -> 设备控制器 -> 设备，三级硬件结构。



每一个设备控制器只能够连接同种类型的若干设备。

### 4.1.2 I/O 接口

> I/O 接口在系统中位置

接口可以看做两个系统或部件之间的交接部分，它既是两种硬件设备之间的连接电路，也可以看作两个软件之间的共同逻辑边界。



# 操作系统

定义：操作系统是有效地组织和管理计算机系统中各种软件和硬件资源，合理地组织其工作流程，控制程序运行，并且向用户提供一个良好的工作环境和友好接口的系然软件。

两个重要作用：
通过资源管理提高计算机系统的工作效率
改善人机界面，为用户提供友好的工作环境





研究操作系统的观点
用户观点：操作系统是用户与计算机之间的接口。
资源管理观点：操作系统是计算机资源的管理者，合理地组织的工作流程，使资源能为多个用户共享。
进程观点：操作系统由一个系统核心和若干并发运行的程序组些运行的程序称为"进程”，每个进程完成特定的任务，系统核心则和协调这些进程的运行。
虚拟机观点：操作系统加裸机等于虚拟计算机。

## 操作系统四个特征

并发性：计算机系统中存在许多并发执行的活动。并发是从时间上来说的，指的是同一时间间隔内从宏观上看有多个活动同时在执行：并行性是针对运行逻辑来说的，即各活动可独立运行、互不影响，不是针对时间而言的。
共享性：系统中各个并发活动共享计算机中各种资源。
虚拟性：把物理上的一台设备变成逻辑上的多台设备。
不确定性：由于程序的并发执行，系统内各进程错综复杂，与这些进程相关的事件，比如O请求，发生的时间都不可预测，若处理不当，可能造成错误。

## 操作系统五大功能

- 进程管理：将CPU合理地分配给各进程。

- 文件管理：存放、检索信息。

- 存储管理：对主存进行管理和扩充。

- 设备管理：对输入输出设备的分配、启动、完成和回收。

- 作业管理：包括任务、界面管理、人机交互、图形界面等。

  

  ## 操作系统分类

### 批处理操作系统

批处理操作系统分为单道批处理操作系统和多道批处理操作系统。
所谓单道批处理操作系统指的是次可提交多个作业（而不是单个作业），但某一时候只将一个鬟入闲荐行，当一个作业运行结束后系统自动调入同一批下一个作业运行。其特点是：自动性、顺序性、单道性。
多道批处理操作系统支持同一批中多个作业一起装入内存同时运行。其特点是：多道性、无序性、宏观上并行、调度性。

### 分时操作系统

分时操作系统是指在一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户分时共享主机中的资源的一种操作系统。

分时操作系统将CPU工作时间划分为许多很短的时间片，轮流为各个终端用户服务。UNX就是一个典型的多用户、多任务分时操作系统。
分时操作系统具有如下特点：
多路性：一台主机同时连接多台联机终瑞。
独立性：每个用户占一个终端，彼此独立操作、互不干扰，用户感觉个人独占全机资源。
交互性：通过终端与系统进行人机对话。
及时性：用户的请求要在人能接受的等待时间内获得响应。

### 网络操作系统

网络操作系统是使联网的自主计算机方便而有效地共享网络资源，为网络用户提供各种服务的软件和有关协议的集合。
所谓自主计算机是指计算机具有独立处理能力，而联网则是表示计算机之间能够实现通信和相互合作，可见，计算机网络是计算机技术和通信技术相互结合的产物。
网络操作系统有两种工作模式：客户机U服务器模式(CS模式)：对等模式(Peer-to-peer)。

### 分布式操作系统

处理和控制功能都高度集中在一台主机上，所有的任务都由主机处理，这样的系统称为集中式处理系统。而在分布式处理系统中，系统的处理和控制功能都分散在系统的各个处理单元上。
分布式处理系统的最基本的特征就是处理上的分布，而处理分布的实质是资源、功能和控制的分布。
分布式处理系统中，每个处理单元既具有高度的自治性，又相互协同，能在系统范围内实现资源管理、动态地分配任务，并能并行地运行分布式程序。

### 分布式OS与网络OS的比较

分布性：分布式0S不是集中驻留在某一个站点上，而是均匀地分布在系统各个站点上：计算机网络虽然具有一定的分布处理能力，但控制方式是集中式的。
并行性：分布式处理系统中可将多个任务分配到多个处理单元上并行执行，而计算机网络中，任务通常在自己的（本地）计身机上处理，因此网络OS没有任务分配功能。
透明性：分布式OS很好地隐藏了系统的内部实现细节，如对象的物理位置、并发控制等对用户均透明：网络OS也有一定的透明性，但主要是指操作实现上的透明性。
共享性：分布式系统中，各站点上的资源可供系统中所有用户透明共享，而网络○S虽也能提供资源共享，但共享的资源一般放在服务器上。
健壮性：分布式系统中，某一个站点出现故障并不会给整个系统带来大影响，具有较好的可用性和可靠性，而网络OS的健壮性较差。

### 嵌入式操作系统

嵌入式操作系统运行在嵌入式智能芯片环境中，对整个智能芯片以及它所操作、控制的各个部件进行统一协调的控制和处理。
嵌入式操作系统一般具有占用空间小、执行效率高、易于个性化定制和钦件固化等特点。
嵌入式操作系统都具有下述特点：微型化、易于定制、可靠性高、易于移植。
常见的EOS产品有：3Com公司下属子公司的Palm OS,Microsoft公司的Vindows CE和开放源代码的Linux。

# UNIX/Linux 系统结构

UNIX/Linux 系统可以粗糙地抽象为 3 个层次（所谓粗糙，就是不够细致、精准，但是便于初学者抓住重点理解），如图 3 所示。底层是 UNIX/Linux 操作系统，即系统内核（Kernel）；中间层是 Shell 层，即命令解释层；高层则是应用层。

#### 1) 内核层

内核层是 UNIX/Linux 系统的核心和基础，它直接附着在硬件平台之上，控制和管理系统内各种资源（硬件资源和软件资源），有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。



#### 2) Shell层

Shell 层是与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以我们也把 Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。



#### 3) 应用层

应用层提供基于 X Window 协议的图形环境。X Window 协议定义了一个系统所必须具备的功能（就如同 TCP/IP 是一个协议，定义软件所应具备的功能），可系统能满足此协议及符合 X 协会其他的规范，便可称为 X Window。

现在大多数的 UNIX 系统上（包括 Solaris、HP-UX、AIX 等）都可以运行 CDE （Common Desktop Environment，通用桌面环境，是运行于 UNIX 的商业桌面环境）的用户界面；而在 Linux 上广泛应用的有 Gnome（见图 4）、KDE 等。


![img](http://c.biancheng.net/uploads/allimg/180926/2-1P926161210K7.jpg)
图 4 Gnome图形界面


X Window 与微软的 Windows 图形环境有很大的区别：

- UNIX/Linux 系统与 X Window 没有必然捆绑的关系，也就是说，UNIX/Linux 可以安装 X Window，也可以不安装；而微软的 Windows 图形环境与内核捆绑密切。
- UNIX/Linux 系统不依赖图形环境，依然可以通过命令行完成 100% 的功能，而且因为不使用图形环境还会节省大量的系统资源。

# 一、前驱图

前驱图是一个有向无循环图，记为DAG。用于这种图可以描述多个程序或进程之间的执行顺序关系。

- 〇 表示一个程序、进程或是语句的结点。
- → 表示结点间的执行顺序。

**前趋关系“→ ”的形式化描述**：→ ={<Pi, Pj> | Pi must complete before Pj may start}  

<Pi, Pj>∈→，可写成Pi→Pj，表示在Pj开始执行之前Pi必须完成。此时称 Pi 是 Pj 的直接前驱，而称 Pj 是 Pi 的直接后继。在前驱图中把没有前驱的结点称为初始结点（Initial Node），把没有后继的结点称为终止结点 （Final Node）。此外，每个结点还具有一个重量（Weight），用于表示该结点所含有的程序量或程序的执行时间。

下图举例一个具有9个节点的前驱图：

存在如下前驱关系：

P1→ p2，P1→ p3，P1→ p4，P2→ p5，P3→ p5，P4→ p6，P4→ p7，P5→ p8，P6→ p8，P7→ p9，P8→ p9





**注意：前驱图中不能存在循环，否则必然会产生不可能实现的前驱关系**

例如: 如下关系就不可能实现





# 二、程序的顺序执行及其特征

##  1、程序的顺序执行

### （a）程序间的顺序执行





### （b）程序内部的顺序执行

　　S1: a:=x+y;
			　　S2:  b:=a-5;
			　　S3:  c:=b+1;







## 2、顺序执行时的特征

- 顺序性
- 封闭性
- 可再现性

程序顺序执行的特性，为程序员检测和校正程序的错误带来很大方便。

## 3、程序的并发执行及其特征

在操作系统中引入了多道程序设计技术后，系统中的程序才能并发执行，但是并非所有的程序都能并发执行。

例如：输入、计算、打印三个程序对一批作业进行处理时，存在以下的前趋关系：

① Ii → Ci → Pi

② Ii → Ii+1
   Ci → Ci+1
   Pi → Pi+1 

 



1）对每道程序依然存在这样的关系Ii → Ci → Pi，这是由程序的内在逻辑关系决定

（2）对不同程序之间，存在 Ii → Ii+1，Ci → Ci+1，Pi → Pi+1 的关系，这是由于系统资源的竞争带来的顺序性，这种顺序性是系统资源的前趋关系，非程序逻辑关系。

（3）不同程序之间的 Ii+2，Ci+1，Pi 不存在前趋关系

### （a）程序的并发执行

 定义：一组在逻辑上相互独立的程序或程序段在执行过程中其执行时间相互重叠。

对任意一个程序，存在前趋关系必须顺序执行，不存在前趋关系的可以并发执行。

### （b）并发执行时的特征

-  间断性

　　程序在并发执行过程中由于共享资源而会相互制约，由此导致这些并发执行的程序出现 “执行——暂停——执行” 间断性活动规律。

- 失去封闭性

　　并发执行的程序在共享资源时可能会改变这些资源的状态，致使其他程序在运行时其运行环境被改变，由此失去封闭性。

- 不可再现性

　　程序在并发执行时如果失去封闭性，那么也会失去可再现性。



\一、进程的定义与特征

## 1、进程的定义

进程是具有独立功能的程序关于某个数据集合上一次运行活动，是系统进行资源管理分配和调度的独立单位。

## 2、进程的组成

进程＝程序＋数据＋PCB

- 程序部分：描述了进程所要完成的功能；
- 相关数据：是程序在执行时所需要的数据和工作区，这两部分是进程存在的物质基础。
- PCB：是最重要的，创建进程实际上是指创建进程实体中的进程控制块，而撤销进程也是指将这个进程实体中的进程控制块撤消掉。

## 3、进程的特征

- 动态性

　　是进程实体的执行过程，是进程最基本的特征。动态性还表现在“它由创建而产生，由调度而执行，由撤销而消亡

- 并发性

　　指多个进程实体同时存在于内存中，并能在一段时间内同时运行。

- 独立性

　　指进程实体是一个独立运行，独立获得系统资源和独立接受调度的基本单位。

- 异步性

　　指进程按各自独立、不可预知的速度向前推进。

## 4、进程与程序的区别与联系

（1）进程是程序的一次动态执行活动；程序是进程运行的静态描述文本。比如做菜和菜谱。

（2）一个进程可以执行一个或多个程序，同一个程序也可以被多个进程同时执行。

（3）程序是一种软件资源，可以长期保存；而进程是一次执行过程，是暂时存在的。

（4）程序不具备进程的4个基本特征。

进程和程序是两个截然不同的两个概念，进程具有五个基本特征，而程序则不具备这些特征：

- 动态性：进程是进程实体的执行的过程，动态性是它的最基本的特征而程序是静态的
- 并发性：多个进程实体同时存在于内存中，能在一段时间内同时运行引入进程的目的就是为了使程序能并发执行。而一般的程序本身是不能并发执行的，它必须要符合一定的条件或者建立进程才可以实现并发执行
- 独立性：进程实体是一个能独立运行的基本单位，同时是系统中分配资源和独立调度的基本单位
- 异步性：进程按照各自独立的、不可预知的速度向前推进，即按异步方式运行。
  结构特征：从结构上看，进程实体由程序段、数据和PCB三部分组成，有人称这三部分为进程映像

### 进程的控制

进程的控制就是对系统中所有进程从创建到消亡的全过程实施有效的控制。进程的控制机构是由操作系统内核实现的。
操作系统内核有如下三大支撑功能：
中断处理
时钟管理
原语操作
操作系统内核有如下三大资源管理功能：
进程管理
存储管理
设备管理



### 进程的同步和互斥

把异步环境下的一组并发进程因直接制约而互相发送消息而进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程同步。也就是说，进程之间是异步执行的，同步即是使各进程按一定的制约顺序和速度执行。同步关系是直接制约关系。
临界资源就是指那种在一段时间内只允许一个进程访问的资源，如打印机。互斥就是要保证临界资源在某一时刻只被一个进程访问。互斥关系是间接制约关系。

临界区是进程中使用临界资源的那段程序。



临界区管理四原则
对互斥临界区管理的四个原则是：
有空即进：当没有进程处于临界区时，就允许要进入自己临界区的进程进入自己的临界区，并且只能在临界区运行有限的时间。
无空则等：当某一个进程A处于自己的临界区时，其它任一进程B要进入自己的临界区(亦即B的临界区)都必须等待，以保证进程互斥地访问临界资源。
有限等待：对要求访问临界资源的进程，应保证进程能在有限的时间进入临界区，以免该进程陷入“饥饿”或”死等”状态。
让权等待：当进程不能进入自己的临界区时，那它应当立即释放处理机，以免阻塞其它进程，造成多个进程等待的状态，即忙等状态。

\

信号量是一个整型变量，根据控制对象的不同被赋子不同的值。它分为两类：。
公用信号量：实现进程间的互斥，初值为1或资源的数目
私用信号量：实现进程间的同步，初值为0或某个正整数。
信号量S的物理意义是：当S≥0，表示某类资源可用的数目：S<0时表示，因无法得到该类资源而被阻塞的进程的个数，即阻塞队列中等待该资源的进程数目。





PV操作
PV操作均是原子操作，是低级的进程通信原语，在执行期间不可分割。P操作表示要申请三个资源，V操作表示使用完了一个资源要释放这个资源。
P操作：S:=S-1,若S≥0，表明资源申请合法，即系统有资源可分配给它，则执行P操作的这个进程可进入临界区继续执行：若S<0,表明此时系统已无资源分配，包括当前申请资源的这个进程已经有引S个进程在等待该资源了，该进程申请的资源得不到满足，因此被阻塞，将其插入阻塞队列。
V操作：S:=S+1,若S>0(表明执行V操作的当前这个进程释放的这1个资源加上系统原先空闲的资源总数目大于0)，执行V操作的这个进程继续往下执行：若S≤0，表明在执行"S:=S+1"之前，S<0,即表明当前执行V操作的这个进程在释放它的一个资源之前，系统有进程在等待该资源，所以，此时要从阻塞队列中调出一个进程将该资源"转手”"给它，即唤醒一个进程将其插入就绪队列等待调度执行，接着，执行V操作的当前进程





调度的级别、方式
一个作业从提交到完成需要经历高、中、低三个级别的调度。
高级调度：又称为长调度或作业调度或接纳调度，它决定输入池中的哪个
后备作业可以调入内存做好运行准备。
中级调度：又称中程调度或对换调度，它决定处于静止就绪的进程中哪个可以从外存调入内存，参与CPU竞争。
低级调度：又称为短程调度或进程调度，它决定内存中哪个就绪的进程可以占用CPU.
调度方式：分为可剥夺与不可剥夺两种。

# 二、进程的基本状态与转换

## 1、进程的三种基本状态

- 就绪状态

　　进程获得除CPU以外的所有资源时的状态。由就绪状态的进程排成的队列称为是就绪队列，进程只有进入就绪队列才有权被CPU调度执行。

- 执行状态

　　进程已获得CPU，并且正在执行时的状态。

- 阻塞状态

　　正在执行的进程由于某种原因而被系统停止执行这时停止执行的进程要放弃处理机。

## 2、三种基本状态的转换

进程的三种基本状态及其转换，如下图：





为了满足进程控制块对数据及操作的完整性要求以及增加管理的灵活性，又引入2个常用的状态，创建状态和终止状态。

### （1）创建状态

　　**创建步骤**：先申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所需的资源，最后把该进程转入就绪状态插入就绪队列中。

　　只拥有自己的PCB，但还未拥有一些必须的资源，并且进程还未进入到内存中。创建未完成，进程还不能被调度的状态即为创建状态。

　　处于创建状态的进程不能直接被CPU调度执行。

### （2）终止状态

　　**进程终止步骤**：等待操作系统进行善后处理，将PCB清零，将PCB的空间返还系统。

　　终止状态就是停止执行且进程资源已被系统回收所处的一种状态

 　一个进程正常结束或异常结束后。 进入终止状态的进程，不再有执行资格。它的记录暂时由操作系统保留，其中保存状态码和一些计时统计数据，供其他进程收集。其他进程完成信息提取后，操作系统删除该进程。

　　处于终止状态的进程不能再被CPU直接调度执行。

 进程的五种基本状态及其转换，如下图：







# 三、挂起操作和进程状态的转换

为了系统和用户观察和分析进程的需要，还引入了一个对进程的重要操作，挂起操作。

## 1、挂起状态

- 挂起状态：使原来活动的进程处于静止状态

**引起挂起状态的原因：**

- 父进程请求
- 负荷调节的需要
- 操作系统的需要
- 终端用户的请求

## 2、进程状态的转换

在引入挂起的系统中，进程的就绪状态分为活动就绪和静止就绪状态，而进程的阻塞状态分为活动阻塞和静止阻塞状态。

　　活动就绪（Readya）→→ 静止就绪（Readys） 
　　活动阻塞（Blockeda）→→ 静止阻塞（Blockeds） 
　　静止就绪 →→ 活动就绪 
　　静止阻塞 →→ 活动阻塞

**原语：**

是指完成特定功能的，具有原子性的子程序。其中有原语有挂起原语（Suspend）和激活原语（Active）。

**具有挂起状态的进程状态转换**，如下图：（有活动和静止之分）





**具有创建、终止和挂起状态的进程状态转换**，如下图：





# 四、进程控制块PCB

## 1、PCB的概念与作用

**（1）PCB的概念**

PCB是系统为管理进程设置的一个记录型数据结构，存放用于描述该进程情况和控制进程运行所需的全部信息。系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志。

进程与PCB是一一对应的，PCB经常被系统访问，故常驻内存。

**（2）PCB的作用**

PCB的作用是使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位。

- 作为独立运行基本单位的标识：系统是通过PCB感知进程的存在。
- 能实现间断性运行方式：保存CPU现场信息
- 提供进程管理所需要的信息：根据PCB的资源清单了解进程所需要的资源
- 提供进程调度所需要的信息：进程处于什么状态
- 实现与其他进程的同步通信：实现诸进程的协调运行。设置通信区域和指针

## 2、进程控制块中的信息

**（1）进程标识符（唯一地标识一个进程）**

- 外部标识符

　　由创建者提供，通常由字母、数字组成，可重名。

- 内部标识符

　　系统为每个进程赋予唯一的数字标识符，不可重名。

**（2）处理机状态**

- 通用寄存器

　　用户可以访问的寄存器，因此又称为用户可视寄存器，用于暂存信息。

- 指令计数器

　　存放了程序将要访问的下一条指令的地址。

- 程序状态字PSW

　　包含了正在执行程序的状态信息：条件码、执行方式、中断屏蔽标志等。

- 用户栈指针

　　每个用户都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。

 **（3）进程调度信息**

- 进程状态，指明进程的当前状态， 作为进程调度和对换时的依据；
- 进程优先级，用于描述进程使用处理机的优先级别的一个整数， 优先级高的进程应优先获得处理机；
- 进程调度所需的其它信息，它们与所采用的进程调度算法有关，比如，进程已等待CPU的时间总和、 进程已执行的时间总和等；
- 事件，是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。

 **（4）进程控制信息**

-  程序和数据的地址，即进程的程序和数据所在的内存或外存(首)地址，以便再调度到该进程执行时，能从PCB中找到其程序和数据；
- 进程同步和通信机制，指实现进程同步和进程通信时必需的机制， 如消息队列指针、信号量等，它们可能全部或部分地放在PCB中；
- 资源清单，是一张列出了除CPU以外的、进程所需的全部资源及已经分配给该进程的资源的清单；
- 链接指针，它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址。

## 3、进程控制块的组织方式

为了有效地对进程控制块进行管理，应该采用适当的方式把它们组织起来。

目前常用的组织方式有以下三种：

- 线性方式（适用于进程个数不多的系统）
- 按链接方式组织PCB（队列）





进程高级通信的类型有三种：
共享存储系统：相互通信的进程通过共享某些数据结构或存储区实现通信。
消息传递系统：进程之间的数据交流以消息为单位，程序员直接利用系统提供的一组通信原语（命令）来实现通信。
管道通信：管道是用于连接一个读进程和一个写进程以实现两者之间通信的共享文件。

一个作业从提交到完成需要经历高、中、低三个级别的调度。
高级调度：又称为长调度或作业调度或接纳调度，它决定输入池中的哪个后备作业可以调入内存做好运行准备。
中级调度：又称中程调度或对换调度，它决定处于静止就绪的进程中哪个可以从外存调入内存，参与CPU竞争。
低级调度：又称为短程调度或进程调度，它决定内存中哪个就绪的进程可以占用CPU.
调度方式：分为可剥夺与不可剥夺两种。

进程调度算法
常用的进程调度算法有：
先来先服务(FCFS)：按照进程变为就绪状态的先后次序分配CPU,
时间片轮转：将系统中所有就绪进程按照FCFS原则排成一个队列，每次调用是将CPU分派给队首进程，让其执行一个时间片，时间片到了时，发生时钟中断，将该进程送到就绪队列末尾，并切换执行当前的队首进程。
优先级调度：分为静态有动态两种。
多级反馈调度：是时间片轮转法和优先级算法的综合。

死锁
死锁是指两个以上的进程互相都要求使用对方已经占有的资源而导致无法继续运行的现象。
进程推进顺序不当会引起死锁。比如有一台读卡机A,一台打印机B,为进程P1、P2共享，它们并发执行时按下列顺序请求和释放资源：

死锁通常被定义为：如果一个进程集合中的每个进程都在等待只能由此集合中的其他进程才能引发的事件，而无限期陷入僵持的局面称为死锁。

## **二、死锁产生的条件**

- 互斥条件
  临界资源是独占资源，进程应互斥且排他的使用这些资源。
- 占有和等待条件
  进程在请求资源得不到满足而等待时，不释放已占有资源。
- 不剥夺条件
  又称不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺。
- 循环等待条件
  又称环路条件，存在循环等待链，其中，每个进程都在等待链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。

**死锁只有在这四个条件同时满足时出现。**

## **三、死锁产生的原因**

死锁产生的原因有很多，如：

- 进程顺序不当
- PV操作使用不妥
- 同类资源分配不均
- 对某些资源的使用未加限制

等等。

> 可见，产生死锁的原因不仅与系统拥有的资源数量有关，而且与资源分配策略、进程对资源的使用要求以及进程的推进顺序有关。

## **四、死锁解决的方法**

主要有一下三种方法：

- 死锁防止
- 死锁避免
- 死锁检测和恢复

## **4.1 死锁防止**

**在程序运行之前防止发生死锁。**

前面说了死锁产生的条件有四个，分别是：互斥条件、占有和等待条件、不剥夺条件、循环等待条件。

**而死锁防止的策略就是至少破坏这四个条件其中一项。**



### **4.1.1 破坏互斥条件**

使资源同时访问而非互斥使用，就没有进程会阻塞在资源上，从而不发生死锁。

> 只读数据文件、磁盘等软硬件资源均可采用这种办法管理；
> 但是许多资源是独占性资源，如可写文件、键盘等只能互斥的占有；
> 所以这种做法在许多场合是不适用的。

### **4.1.2 破坏占有和等待条件**

采用静态分配的方式，静态分配的方式是指进程必须在执行之前就申请需要的全部资源，且直至所要的资源全部得到满足后才开始执行。

> 实现简单，但是严重的减低了资源利用率。
> 因为在每个进程占有的资源中，有些资源在运行后期使用，有些资源在例外情况下才被使用，可能会造成进程占有一些几乎用不到的资源，而使其他想使用这些资源的进程等待。

### **4.1.3 破坏不剥夺条件**

剥夺调度能够防止死锁，但是只适用于内存和处理器资源。

方法一：占有资源的进程若要申请新资源，必须主动释放已占有资源，若需要此资源，应该向系统重新申请。

方法二：资源分配管理程序为进程分配新资源时，若有则分配；否则将剥夺此进程已占有的全部资源，并让进程进入等待资源状态，资源充足后再唤醒它重新申请所有所需资源。

### **4.1.4 破坏循环等待条件**

给系统的所有资源编号，规定进程请求所需资源的顺序必须按照资源的编号依次进行。

> 采用层次分配策略，将系统中所有的资源排列到不同层次中

- 一个进程得到某层的一个资源后，只能申请较高一层的资源
- 当进程释放某层的一个资源时，必须先释放所占有的较高层的资源
- 当进程获得某层的一个资源时，如果想申请同层的另一个资源，必须先释放此层中已占有的资源

## **4.2死锁避免**

> 各种死锁防止方法能够防止发生死锁，但必然会降低系统并发性，导致低效的资源利用率。

**在程序运行时避免发生死锁。**



## **4.3 死锁检测和恢复**

> 对资源的分配加以适当限制可防止或避免死锁发生，但不利于进程对系统资源的充分共享。

**不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。**

> 如果进程 - 资源分配图中无环路，此时系统没有发生死锁。
> 如果进程 - 资源分配图中有环路，则可分为以下两种情况：

- 每种资源类中仅有一个资源，则系统发生了死锁。此时，环路是系统发生死锁的**充分必要条件**，环路中的进程就是死锁进程。
- 每种资源类中有多个资源，则环路的存在只是产生死锁的**必要不充分条件**，系统未必会发生死锁。



**下面详细说一下这两种情况：**

### **4.3.1 每种资源类中仅有一个资源的死锁检测**



线程是系统实施调度的基本的、独立的单位。
引入线程的原因：由于在进程的创建、撒消和切换过程中，系统付出的时空代价较天，因此在系统中的进程数目不宜过多，进程切换不能过于频繁，这就限制了并发程度的提高。引入线程之后，将传统的进程的
两个基本属性分开。可以通过创建线程来完成任务，提高了并发。
线程基本不拥有资源，只拥有一点运行必不可少的资源。
线程可以创建另外一个线程，同一个进程中的多个线程可以并发执行。线程也有就绪、运行和阻塞三种基本状态。

### 进程、线程、多线程、并发、并行

>  首先，并行与并发都是程序多线程处理场景，因此，一旦提到并行与并发，那首先想到的是多线程。 

## #1 进程

>  狭义理解就是操作系统中一段程序的执行过程。那么广义上，进程是指一个具有一定独立功能的程序操作系统中关于某个数据集合进行的一次运行活动。是操作系统程序动态执行的基本单元。在传统的操作系统中，进程既是一个操作系统的基本分配单元，也是操作系统的基本执行单元。 

**进程共有三种状态：就绪、阻塞和运行**

- 就绪态

>  就绪状态是指程序已达到可以运行的状态，只等CPU分配资源就可以运行的状态。 

- 阻塞态

>  当程序运行条件没有满足时，需要等待条件满足时候才能执行时所处的状态，如等待i/o操作时候，此刻的状态就叫阻塞态。 

- 运行态

>  进程占用CPU，并在CPU上运行。即程序正在运行时所处的状态。 

## #2 线程

>  线程是进程中执行运算的最小单元，是操作系统执行处理机制的基本单位。每个进程至少有一个线程，线程可以利用进程所拥有的资源执行调度和运算。 

**进程与线程的对比**

- 进程是操作系统资源分配的基本单位，所有与该进程有关的资源，均会被记录在进程控制块PCB中，以表示该进程所拥有的资源。同一进程下的所有线程共享该进程下的所有资源。
- 线程是分配处理机的基本单位，与系统资源分配无关。事实上，正在在处理机上运行的是线程，并非进程。
- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。
- 线程在执行的时候需要协作同步，不同进程的线程间要利用消息通信方法实现同步。

**进程与线程的关系**

- 进程将CPU资源分给线程，即真正在CPU上运行的是线程。
- 操作资源分配给进程，同一进程的所有线程共享该进程的所有资源。

**进程与线程的区别**

- 同一个进程中的线程共享同一内存空间，但是进程之间是独立的。
- 同一个进程中的所有线程的数据是共享的（进程通讯），进程之间的数据是独立的。
- 对主线程的修改可能会影响其他线程的行为，但是父进程的修改（除了删除以外）不会影响其他子进程。
- 线程是一个上下文的执行指令，而进程则是与运算相关的一簇资源。
- 同一个进程的线程之间可以直接通信，但是进程之间的交流需要借助中间代理来实现。
- 创建新的线程很容易，但是创建新的进程需要对父进程做一次复制。
- 一个线程可以操作同一进程的其他线程，但是进程只能操作其子进程。
- 线程启动速度快，进程启动速度慢（但是两者运行速度没有可比性）。

## #3 多进程

>  在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多任务（多进程）。现代的操作系统几乎都是多进程操作系统，能够同时管理多个进程的运行。 多进程带来的好处是明显的。但是多进程对于系统的资源要求甚高，资源浪费也比较严重。应用多进程场景最多的是windows系统，例如同时打开运行软件，每个软件打开相当于运行一个进程。 

## #4 多线程

>  在一段完整的代码中，往往会有需要独立的代码模块，而这些独立运行的程序片段叫作“线程”（Thread），利用多个线程编程的概念就叫作多线程处理(多线程编程)，多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。多线程是在程序在同一时间需要完成多项任务的时候实现的。多线程的目的仅仅是为了提高资源利用效率。各个线程执行自己的任务，这些线程可以”同时进行“。同时进行并非同一时刻进行，而是在某一时间段内，完成所有任务，任务的运行有先后顺序。 

地址空间
名空间：程序中由符号名组成的空间称之为名空间。
逻辑地址空间：指地址的集合。程序经编译连接之后的编址是相对地址，以0为基址。相对地址也称为辑地址或虚拟地址，逻辑地址的集合称为逻辑地址空间，简称地址空间。
存储空间：计算机系统实际的内存地址是绝对地址，亦称为物理地址或者实地址。地址的集合称为物理地址空间，亦称为存储空间。



产生死锁的4个必要条件为：
互斥条件：进程对其所要求的资源进行独占性控制。
请求保持条件：进程已经保持了至少一个资源，但又提出新的资源申请，而该资源又得不到满足，于是该进程阻塞，但其原先获得的资源保持不放。
不可剥夺条件：进程已获得的资源在未使用完之前，不能被剥夺，只能在使用完事由自己释放。
环路条件：当发生死锁时，在进程资源有向图中存在环路。

按索引方式组织PCB（表）

## 存储管理

### 地址空间

名空间：程序中由符号名组成的空间称之为名空间。
逻辑地址空间：指地址的集合。程序经编译连接之后的编址是相对地址，以0为基址。相对地址也称为逻辑地址或虚拟地址，逻辑地址的集合称为逻辑地址空间，简称地址空间。
存储空间：计算机系统实际的内存地址是绝对地址，亦称为物理地址或者实地址。地址的集合称为物理地址空间，亦称为存储空间。

### 地址重定位

地址重定位：将程序的逻辑地址转化为主存的物理地址。该工作由操作系统中的装入程序Loader和地址重定位机构来完成。分为静态重定位、动态重定位。

## ***\*1. 绝对地址\****

计算机中，存储器是按字组织，每个字由若干”位“组成（**不同计算机子长不同**），**每个字分配一个地址**

目前以多字节为单位进行编址

系统对存储器中的单元进行统一编号，这些编号就是**绝对地址**

寻址容量与地址线长度有关，n 条地址线可寻址空间为：2n

**绝对地址是内存的真实地址——物理地址**

**存储空间（物理地址空间）**：绝对地址集合

## ***\*2. 虚拟地址（相对地址）\****

**虚拟地址**：相对于某个基准量（通常是 0）编址时所使用的地址，用户程序编写和编译过程中使用相对地址

**名空间**：程序员所写符号名组成名空间

**地址空间**：一个目标程序所限定的地址集合

**名空间 ==> 地址空间 ==> 存储空间**

# ***\*二、地址转换\****

程序执行时，必须将地址空间变为绝对地址才能访问系统分配的内存

**地址重定位**：操作系统把用户程序指令中的相对地址变换成为所在存储中的绝对地址的过程

***\*地址重定位实现了：从逻辑地址到物理地址的转换\****

按照重定位时机**分类**：静态重定位、动态重定位

## ***\*1. 地址的静态重定位\****

**定义**：在程序运行之前，为用户程序实行了地址重定位工作

一般由操作系统中的**重定位装入程序**完成

重定位装入程序的**输入**：用户把自己的作业链接装配成一个相对于 0 编址的目标程序

***\*过程：\****

重定位装入程序根据当前内存的分配情况，按照分配区域的起始地址逐一调整目标程序指令中的地址部分。目标程序在经过重定位装入程序加工之后，不仅进入到分配给自己的绝对地址空间中，而且程序指令中的地址部分全部进行了修正，反映出了自己正确的存储位置，保证了程序的正确运行

***\*特点：\****

在装入前实现调整

地址要有标识

每次装入都要进行定位

装入后地址不再改变（静态）

## ***\*2. 地址的动态重定位\****

**定义**：在程序执行寻址时进行重定位，访问地址时，通过地址变换机构改变为内存地址

用户程序**原封不动**的装入内存，运行时再完成地址的定位工作

动态重定位需要硬件的支持，要求系统中配备**定位寄存器**和**加法器**

***\*特点：\****

程序可装入任意内存区域（不要求占用连续的内存区）

只装入部分程序代码即可运行

改变系统时不需要改变程序（程序占用的内存空间动态可变，只需要改变定位寄存器中的值即可）

程序可方便共享



### 分页存储管理

在分页存储管理系统中，将逻辑地址划分为若干大小相等的片，称为页面或页，相应地，主存空间也分为跟页一样大小的片，称为物理块或者页框。

## 页面与页表

### 页面

相对物理块来说，页是[逻辑地址](https://so.csdn.net/so/search?q=逻辑地址&spm=1001.2101.3001.7020)空间（虚拟内存空间）的划分，是逻辑地址空间顺序等分而成的一段逻辑空间，并依次连续编号。页的大小一般为 `512B~8KB`。

例如：一个 32 位的操作系统，页的大小设为

2^^12=4kb



分段存储管理



局部性原理
局部性原理：程序在执行时，在一段时间内，程序的执行仅局限于某个特定的部分：相地，其所访问的存储空间也局限与某个区域内。程序的局限性表现在时间局限性和空间局限性两个方面。
时间局限性：如果程序中的某一条指令一旦执行，则不久以后该指令可能再次执行：如果某个数据结构被访问，则不久以后它可能再次被访问。
空间局限性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也被访问。即程序在一段时间内所访问的地址，可能集中在一定范围之内，其典型情况是程序顺序执行。

虚拟存储器的定义
基于局部性原理，一个作业在运行之前，没有必要全部装入内存，而仅将那些当前要运行的那部分页面或段装入内存便即可启动，其余部分可暂时留在磁盘上。
程序运行时，若要访问的页（段）已在内存，则继续执行下去：若不在，则要利用OS的请求调页（段）的功能将领（段）调入主存。。若在调入过程中，发现内存已满，就得利用页（段）的置换功能，将主存中暂时不用的页（段）调出到外存，腾出空间将需要的页（段）装入。
这样，就可以使一个大的用户程序在较小的内存空间中运行：也可使内存中同时装入更多的进程并发执行。从用户的角度来看，该系统所具有的主存容量比实际容量大得多，因此，称其为虚拟存储器。

分页虚拟存储器

## 设备管理

按数据交换的单位分类
块设备(Block Device):这种设备以块为单位组织数据和传送数据，用于存储信息，属于有结构设备。
磁盘是典型的块设备，每个块的大小为512B4KB,其基本特征是：传输速率高，通常每秒几兆位：可寻址，即可按地址随机地访问任意一块：其输入输出方式是采用DMA方式，
字符设备(Character Device):指以单个字符为单位来传送数据的设备。这类设备一般用于数据的输入输出，如交互式终端（键盘）打印机。
字符设备的基本特征是：传输速率低：不可寻址，即不能指定输入时的源地址或输出时的目标地址：输入输出方式采用中断方式。

 设备管理概述
一、设备管理基本功能

外设管理：是指计算机系统中除了CPU和内存以外的所有输入、输出设备的管理。

主要功能包括：缓冲管理、设备分配与回收、设备处理和虚拟设备。

除了进行实际I/O操作的设备外，也包括：设备控制器、DMA控制器、中断控制器、通道。

早期，计算机设计者没有将CPU的执行与I/O操作分开，甚至大多数人认为，输入输出与计算的时间应该是同一数量级。
后来，他们意识到，CPU要比I/O操作速度高几个数量级。于是，硬件和软件设计师开始寻找一种技术：CPU计算可以不用等待I/O操作而持续执行。
二、操作系统设备管理的3个目标

1）向用户提供使用外部设备的方便、统一的接口，按照用户的要求和设备的类型，控制设备工作，完成用户的输入输出请求。方便是指用户能独立于具体设备的复杂物理特性而方便地使用设备；统一是指对不同设备尽量能统一操作方式。方便和统一要求对用户屏蔽实现具体设备I/O操作的细节，呈现给用户的是一种性能理想化的、操作简便的逻辑设备。系统的这种性能亦称为设备的独立性（设备无关性）。
2）充分利用中断技术、通道技术和缓冲技术，提高CPU与设备、设备与设备间的并行工作能力，充分利用设备资源，提高外部设备的使用效率。
3）设备管理就是要保证在多道程序环境下，当多个进程竞争使用设备时，按照一定的策略分配和管理设备，以使系统能有条不紊地工作。

设备管理的任务
记录和监控设备状态。
为用户提供设备使用的接口。
设备的分配和释放。
设备的访问和控制。
管理缓冲区。
输入输出缓冲和调度。
实现/O设备的物理操作。

引入缓冲的原因
缓冲技术可提高外设利用率，尽可能使外设处于忙状态。缓冲技术根据实现方式分为硬件缓冲和软件缓冲，硬件缓冲是利用专门的硬件寄存器作为缓冲，而软件缓冲则是通过操作系统来实现的。
引入缓冲技术的主要原因有：
缓和CPU与/O设备之间速度不匹配的矛盾
减少对CPU的中断频率，放宽对中断响应时间的限制
提高CPU和I/O设备之间的并行性

一、缓冲区管理
（一）什么是缓冲区？有什么作用？
缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。
使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）
一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区。

二）单缓冲
假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。
注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。双缓冲

　　为了加快输入和输出的速度，提高设备利用率，人们又引入了双缓冲区机制，称为缓冲对换，在设备输入时，先将数据送入第一个缓冲区，装满后便转向第二个缓冲区，此时操作系统可以从第一缓冲区中移出数据，并送入用户进程，接着由CPU对数据进行计算，在双缓冲时，系统处理一块数据的时间可以粗略地认为是**Max(C，T)**，如果C<T，可使块设备连续输入，如果C>T，则可使CPU不必等待设备输入。对于字符设备，若采用行输入方式，则采用双缓冲通常能消除用户的等待时间，即用户在输入完第一行后，在CPU执行第一行中的命令时，用户可继续向第二缓冲区输入下一行数据。



循环缓冲

　　当输入与输出或生产者与消费者的速度基本相匹配时，采用双缓冲能获得较好的效果，可使生产者和消费者基本上能并行操作，但若两者速度相差甚远，双缓冲的效果则不够理想，因此，引入了多缓冲机制，可将多个缓冲组织成循环缓冲形式。对于用作输入的循环缓冲，通常是提供给输入进程或计算进程使用，输入进程不断向空缓冲去输入数据，而计算进程则从中提取数据进行计算。

　　循环缓冲区的组成如下

　　① 多个缓冲区，在循环缓冲区中包括多个缓冲区，每个缓冲区的大小相同，作为输入的多缓冲区可分为三种类型，用于装输入数据的空缓冲区R、已装满数据的缓冲区G以及计算进程正在使用的先行工作缓冲区C

　　② 多个指针，作为输入的缓冲区可设置三个指针，用于指示计算进程下一个可用缓冲区G的指针Nextg、指示输入进程下次可用的空缓冲区R的指针Nexti、以及用于指示计算进程正在使用的缓冲区C的指针Current。



缓冲池

　　上述的缓冲区仅适用于某特定的I/O进程和计算进程，因而它们属于专用缓冲，当系统较大时，将会有许多这样的循环缓冲，这样会消耗大量的内存空间，而且利用率不高，为了提高缓冲区的利用率，引入缓冲池，在池中设置了多个可供若干个进程共享的缓冲区。

 　对于既可以用于输出的共用缓冲池，其中至少包含有一下三种类型的缓冲区。

　　① 空（闲）缓冲区。

　　② 装满输入数据的缓冲区。

　　③ 装满输出数据的缓冲区。

　　为了管理方便，将相同类型的缓冲区链成一个队列，形成了空缓冲队列emq、输入队列inq、输出队列outq。还具有四种工作缓冲区，用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区、用于提取输出数据的工作缓冲区。

　　缓冲区可以工作在收容输入、提取输入、收容输出、提取输出四种工作方式下





- 文件系统基础：包括文件概念、文件的逻辑结构（顺序文件，索引文件，索引顺序文件）、目录结构（文件控制块和索引结点，单级目录结构和两级目录结构，树形目录结构，图形目录结构）、文件共享和文件保护（访问类型，访问控制）。
- [文件系统实现](https://www.cnblogs.com/peterYong/p/6556613.html)：包括文件系统层次结构、目录实现、文件实现。
- [磁盘组织与管理](https://www.cnblogs.com/peterYong/p/6556612.html)：包括磁盘的结构、磁盘调度算法、磁盘的管理。

## 4.1 文件的概念和定义

文件(File)是操作系统中的一个重要概念。在系统运行时，计算机以进程为基本单位进行资源的调度和分配；而在用户进行的输入、输出中，则以文件为基本单位。大多数应用程序的输入都是通过文件来实现的，其输出也都保存在文件中，以便信息的长期存及将来的访问。当用户将文件用于应用程序的输入、输出时，还希望可以访问文件、修改文件和保存文件等，实现对文件的维护管理，这就需要系统提供一个文件管理系统，操作系统中的文件系统(File System)就是用于实现用户的这些管理要求。

 从用户的角度看，文件系统是操作系统的重要部分之一。用户关心的是如何命名、分类和查找文件，如何保证文件数据的安全性以及对文件可以进行哪些操作等。而对其中的细节，如文件如何存储在辅存上、如何管理文件辅存区域等关心甚少。

 文件系统提供了与二级存储相关的资源的抽象，让用户能在不了解文件的各种属性、文件存储介质的特征以及文件在存储介质上的具体位置等情况下，方便快捷地使用文件。

 用户通过文件系统建立文件，提供应用程序的输入、输出，对资源进行管理。首先了解文件的结构，我们通过自底向上的方式来定义。

#### 1) 数据项

数据项是文件系统中最低级的数据组织形式，可分为以下两种类型：

- 基本数据项：用于描述一个对象的某种属性的一个值，如姓名、日期或证件号等，是数据中可命名的最小逻辑数据单位，即原子数据。
- 组合数据项：由多个基本数据项组成。

#### 2) 记录

记录是一组相关的数据项的集合，用于描述一个对象在某方面的属性，如一个考生报名记录包括考生姓名、出生日期、报考学校代号、身份证号等一系列域。

#### 3) 文件

文件是指由创建者所定义的一组相关信息的集合，逻辑上可分为有结构文件和无结构文件两种。在有结构文件中，文件由一组相似记录组成，如报考某学校的所有考生的报考信息记录，又称记录式文件；而无结构文件则被看成是一个字符流，比如一个二进制文件或字符文件，又称流式文件。

 虽然上面给出了结构化的表述，但实际上关于文件并无严格的定义。通常在操作系统中将程序和数据组织成文件。文件可以是数字、字母或二进制代码，基本访问单元可以是字节、 行或记录。文件可以长期存储于硬盘或其他二级存储器中,允许可控制的进程间共享访问，能够被组织成复杂的结构。



定义：文件是具有文件名称、在逻辑上具有完整意义的一组相关信息项的集合，例如一个源程序、一个目标程序。
信息项是构成文件内容的基本单位，可以是一个字符，也可以是一个记录，记录可以等长也可以不等长。
一个文件包括文件体和文件说明。文件体是文件的真实内容：文件的说明是操作系统为了管理文件而所附加的一些信息。
文件是一种抽象机制，它隐藏了硬件和物理实现细节。

## 4.2 文件的属性、基本操作以及文件的打开和关闭

**文件的属性**

文件有一定的属性，这根据系统的不同而有所不同，但是通常都包括如下属性：

 ①名称：文件名称唯一，以容易读取的形式保存。

 ②标识符：标识文件系统内文件的唯一标签,通常为数字，它是对人不可读的一种内部名称。

 ③类型：被支持不同类型的文件系统所使用。

 ④位置：指向设备和设备上文件的指针。

 ⑤大小：文件当前大小（用字节、字或块表示），也可包含文件允许的最大值。

 ⑥保护：对文件进行保护的访问控制信息。

 ⑦时间、日期和用户标识：文件创建、上次修改和上次访问的相关信息，用于保护、 安全和跟踪文件的使用。

 所有文件的信息都保存在目录结构中，而目录结构也保存在外存上。文件信息当需要时再调入内存。通常，目录条目包括文件名称及其唯一标识符，而标识符定位其他属性的信息。

**文件的基本橾作**

文件属于抽象数据类型。为了恰当地定义文件，就需要考虑有关文件的操作。操作系统提供系统调用，它对文件进行创建、写、读、定位和截断。.

 ①创建文件：创建文件有两个必要步骤，一是在文件系统中为文件找到空间；二是在目录中为新文件创建条目，该条目记录文件名称、在文件系统中的位置及其他可能信息。

 ②写文件：为了写文件，执行一个系统调用，指明文件名称和要写入文件的内容。对于给定文件名称，系统搜索目录以查找文件位置。系统必须为该文件维护一个写位置的指针。每当发生写操作，便更新写指针。

 ③读文件：为了读文件，执行一个系统调用，指明文件名称和要读入文件块的内存位置。同样，需要搜索目录以找到相关目录项，系统维护一个读位置的指针。每当发生读操作时，更新读指针。一个进程通常只对一个文件读或写，所以当前操作位置可作为每个进程当前文件位置指针。由于读和写操作都使用同一指针，节省了空间也降低了系统复杂度。

 ④文件重定位（文件寻址）：按某条件搜索目录，将当前文件位置设为给定值，并且不会读、写文件。

 ⑤删除文件：先从目录中找到要删除文件的目录项，使之成为空项，然后回收该文件所占用的存储空间。

 ⑥截断文件：允许文件所有属性不变，并删除文件内容，即将其长度设为0并释放其空间。

 这6个基本操作可以组合执行其他文件操作。例如，一个文件的复制，可以创建新文件、 从旧文件读出并写入到新文件。

**文件的打开与关闭**

因为许多文件操作都涉及为给定文件搜索相关目录条目，许多系统要求在首次使用文件时，使用系统调用open，将指明文件的属性（包括该文件在外存上的物理位置）从外存拷贝到内存打开文件目录表的一个表目中，并将该表目的编号（或称为索引）返回给用户。操作系统维护一个包含所有打开文件信息的表（打开文件表，open-file  table）。当用户需要一个文件操作时，可通过该表的一个索引指定文件，就省略了搜索环节。当文件不再使用时，进程可以关闭它，操作系统从打开文件表中删除这一条目。

 大部分操作系统要求在文件使用之前就被显式地打开。操作open会根据文件名搜索目录，并将目录条目复制到打开文件表。如果调用open的请求（创建、只读、读写、添加等）得到允许，进程就可以打开文件，而open通常返回一个指向打开文件表中的一个条目的指针。通过使用该指计（而非文件名）进行所有I/O操作，以简化步骤并节省资源。

 整个系统表包含进程相关信息，如文件在磁盘的位置、访问日期和大小。一个进程打开一个文件，系统打开文件表就会为打开的文件增加相应的条目。当另一个进程执行open时，只不过是在其进程打开表中增加一个条目，并指向整个系统表的相应条目。通常，系统打开文件表的每个文件时，还用一个文件打开计数器(Open  Count)，以记录多少进程打开了该文件。每个关闭操作close则使count递减，当打开计数器为0时，表示该文件不再被使用。系统将回收分配给该文件的内存空间等资源，若文件被修改过，则将文件写回外存，并将系统打开文件表中相应条目删除，最后释放文件的文件控制块(File Control Block, FCB)。

 每个打开文件都有如下关联信息：

- 文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的，因此必须与磁盘文件属性分开保存。
- 文件打开计数：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间会不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。该计数器跟踪打开和关闭的数量，当该计数为0 时，系统关闭文件，删除该条目。
- 文件磁盘位置：绝大多数文件操作都要求系统修改文件数据。该信息保存在内存中以免为每个操作都从磁盘中读取。
- 访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等)。该信息保存在进程的打开文件表中以便操作系统能允许或拒绝之后的I/O请求。







## 4.3 文件的逻辑结构：无结构文件(流式文件)和有结构文件(记录式文件)

文件的逻辑结构是从用户观点出发看到的文件的组织形式。文件的物理结构是从实现观点出发，又称为文件的存储结构，是指文件在外存上的存储组织形式。文件的逻辑结构与存储介质特性无关，但文件的物理结构与存储介质的特性有很大关系。

 按逻辑结构，文件有无结构文件和有结构文件两种类型：无结构文件和有结构文件。

**无结构文件（流式文件）**

无结构文件是最简单的文件组织形式。无结构文件将数据按顺序组织成记录并积累保存，它是有序相关信息项的集合，以字节(Byte)为单位。由于无结构文件没有结构，因而对记录的访问只能通过穷举搜索的方式，故这种文件形式对大多数应用不适用。但字符流的无结构文件管理简单，用户可以方便地对其进行操作。所以，那些对基本信息单位操作不多的文件较适于釆用字符流的无结构方式，如源程序文件、目标代码文件等。

**有结构文件（记录式文件）**

有结构文件按记录的组织形式可以分为：

#### 1) 顺序文件。

文件中的记录一个接一个地顺序排列，记录可以是定长的或变长的，可以顺序存储或以链表形式存储，在访问时需要顺序搜索文件。顺序文件有以下两种结构：

 第一种是串结构，记录之间的顺序与关键字无关。通常的办法是由时间决定，即按存入时间的先后排列，最先存入的记录作为第1个记录，其次存入的为第2个记录，依此类推。

 第二种是顺序结构，指文件中的所有记录按关键字顺序排列。

 在对记录进行批量操作时，即每次要读或写一大批记录，对顺序文件的效率是所有逻辑文件中最高的；此外，也只有顺序文件才能存储在磁带上，并能有效地工作，但顺序文件对查找、修改、增加或删除单个记录的操作比较困难。

#### 2) 索引文件。

如图4-1所示。对于定长记录文件，如果要查找第i个记录，可直接根据下式计算来获得第i个记录相对于第一个记录的地址：

https://www.cnblogs.com/peterYong/p/6556614.html#:~:text=%E6%96%87%E4%BB%B6%20%28File%29%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E3%80%82,%E5%9C%A8%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%A5%E8%BF%9B%E7%A8%8B%E4%B8%BA%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D%E8%BF%9B%E8%A1%8C%E8%B5%84%E6%BA%90%E7%9A%84%E8%B0%83%E5%BA%A6%E5%92%8C%E5%88%86%E9%85%8D%EF%BC%9B%E8%80%8C%E5%9C%A8%E7%94%A8%E6%88%B7%E8%BF%9B%E8%A1%8C%E7%9A%84%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E4%B8%AD%EF%BC%8C%E5%88%99%E4%BB%A5%E6%96%87%E4%BB%B6%E4%B8%BA%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D%E3%80%82%20%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BE%93%E5%85%A5%E9%83%BD%E6%98%AF%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E5%85%B6%E8%BE%93%E5%87%BA%E4%B9%9F%E9%83%BD%E4%BF%9D%E5%AD%98%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E4%BB%A5%E4%BE%BF%E4%BF%A1%E6%81%AF%E7%9A%84%E9%95%BF%E6%9C%9F%E5%AD%98%E5%8F%8A%E5%B0%86%E6%9D%A5%E7%9A%84%E8%AE%BF%E9%97%AE%E3%80%82



文件管理概述

一、文件管理基本功能

    在现代计算机系统中，要用到大量的程序和数据，因内存容量有限，且不能长期保存，所以把它们以文件的形式存放在外存中，需要时再随时将它们调入内存。所以在操作系统中又增加了文件管理功能，即构成一个文件系统，负责管理在外存上的文件，并把对文件的存取、共享和保护等手段提供给用户。这不仅方便了用户，保证了文件的安全性，还可有效地提高系统资源的利用率。
    
    在现代OS中，是通过文件系统来组织和管理在计算机中存储的大量程序和数据；即文件系统的管理功能，是通过把它所管理的程序和数据组织成一系列文件的方法来实现的。
    
    文件管理系统，简称文件系统。
        文件系统 = 文件管理程序 + 它所管理的全部文件 + 文件管理所需的数据结构
        文件管理五大功能（用户角度 + 系统角度）：
        1）文件存储空间管理（即外存管理），分配与回收；
        2）文件目录管理；
        3）实现逻辑文件到物理文件的转换和映射；
        4）实现对文件的各种控制操作和存取操作；
        5）实现文件信息的共享，以及文件保密和保护措施。

二、文件系统中的一些概念

    1、文件：简单说文件是指具有文件名的若干相关元素的集合。详细说文件是具有符号名的、在逻辑上具有完整意义的一组相关信息项的集合，保存在外存上并具有长期保存性。
    2、文件系统的核心：是实现对文件的按名存取。
    3、文件的属性：文件类型、长度、建立时间、存取控制等
    4、文件的访问单位：位、字节、数据项、记录等
    5、数据项：数据项是最低级的数据组织形式，分为两种：
        1）基本数据项。这是用于描述一个对象的某种属性的字符集，是数据组织中可以命名的最小逻辑数据单位，即原子数据，又称为数据元素或字段。它的命名通常和其属性一致。例如，用于描述一个学生的基本数据项有学号、姓名、年龄、班级等。
        2）组合数据项。它是由若干个基本数据项组成的，简称组项。例如，班长便是一个组项，它由正班长和副班长两个基本项组成。又如，工资也是一个组项，它可由基本工资、绩效工资和补助组成。
        基本数据项除了数据名外，还应有数据类型。因为基本项仅是描述某个对象的属性，根据属性的不同，需要用不同的数据类型来描述。

6、记录：记录是一组相关数据项的集合，用于描述一个对象在某方面的属性。一个记录应包含哪些数据项，取决于需要描述对象的哪些方面。而一个对象由于他所处的环境不同可把他作为不同的对象。

    例如，一个14岁的青少年，把他作为一个学生时，对他的描述应使用学号、姓名、年龄、班级等数据项。但若把他作为一个医疗对象，对他描述的数据项应使用病例号、姓名、性别、身高、体重及病史等项。
    在诸多记录中，为了能唯一的标识一个记录，必须在一个记录的各个数据项中，确定出一个或几个数据项，把它们的集合称为关键字（key）。或者说，关键字是唯一能标识一个记录的数据项。通常，只需用一个数据项作为关键字。

7、文件、记录和数据项之间的层次关系：



文件1

三、文件类型

    根据不同角度，可以将文件划分为不同类别。
    1、按性质和用途可分为：
        1）系统文件：如内核，系统应用程序，数据；只允许用户执行，不能读写和修改。
        2）库文件：只允许读和执行，如C子程序库。
        3）用户文件：由用户建立的文件，如源程序、目标程序和数据文件等。只允许文件所有者和所有者授权用户使用。

2、按信息的保存期限可分为：

    1）临时文件：即记有临时性信息的文件。用于系统在工作过程中产生的中间文件，一般有暂存的目录。正常工作情况下，工作完毕会自动删除，一旦有异常情况往往会残留不少临时文件。
    2）永久性文件：其信息需要长期保存的文件。指一般受系统管理的各种系统和用户文件，经过安装或编辑、 编译生成的文件，存放在软盘、硬盘或光盘等外存上。
    3）档案文件：系统或一些实用工具软件包在工作过程中记录在案的文档资料文件，以便查阅历史档案。

3、按文件中数据的形式可分为：

    1）源文件：由源程序和数据构成的文件。通常由终端或输入设备输入的源程序和数据所形成的文件都属于源文件。
    2）目标文件：把源程序经过相应语言的编译程序编译过，但尚未经过链接程序链接的目标代码所构成的文件。它属于二进制文件。通常，目标文件所使用的后缀名是“.obj”。
    3）可执行文件：把编译后所产生的目标代码再经过链接程序链接后所形成的文件。

4、按存取控制属性可分为：

    1）只执行文件：只允许被核准的用户调用执行，既不允许读，更不允许写。
    2）只读文件：只允许文件主及被核准的用户去读，但不允许写。
    3）读写文件：允许文件主和被核准的用户去读或写的文件。
    4）无保护文件。
    各个操作系统的保护方法和级别有所不同：DOS操作系统有系统、隐藏、可写三种保护；UNIX或Linux操作系统有九个级别的保护。

5、按文件的逻辑结构可分为：

    1）有结构文件（记录式文件）：由若干个记录所构成的文件，如大量的数据结构和数据库。
    2）无结构文件（流式文件）：直接由字符序列所构成的文件，文件长度为所含字符数。如大量的源程序，可执行程序，库函数。

6、按文件的物理结构可分为：

    1）顺序文件（连续文件）：文件中的记录，顺序地存储到连续的物理盘块中，顺序文件中所记录的次序，与它们存储在物理介质上存放的次序是一致的。
    2）链接文件：文件中的记录可存储在并不相邻接的各个物理块中，通过物理块中的链接指针组成一个链表管理。
    3）索引文件：文件中的记录可存储在并不相邻接的各个物理块中，记录和物理块之间通过索引表项按关键字存取文件，通过物理块中的索引表管理，形成一个完整的文件。
    4）Hash文件：通过散列函数实现存储的文件。

7、按文件的内容形式和系统处理方式可分为：

    1）普通文件：由ASCII码或二进制码组成的文件。一般用户建立的源程序文件、数据文件、目标代码文件及操作系统自身代码文件、库文件等都是普通文件，它们通常存储在外存储设备上。
    2）目录文件：由文件目录组成的，用来管理和实现文件系统功能的系统文件，通过目录文件可对其它文件的信息进行检索。目录文件也是由字符序列构成，可进行与普通文件一样的各种操作。
    3）特殊文件（设备文件）：特指系统中的各类I/O设备。为了便于统一管理，系统将所有的输入/输出设备都视为文件，按文件方式提供给用户使用。


四、文件扩展名与文件属性

1、用户对文件是“按名存取”的。很多操作系统支持的文件名都由两部分构成：文件名和扩展名，二者间用圆点分开。

文件系统的逻辑结构



2、常用图像文件类型

    BMP格式：Bitmap（位图），Windows操作系统中的标准图像文件格式，包含的图像信息较丰富，几乎不进行压缩，缺点是占用磁盘空间过大
    GIF格式：图形交换格式，压缩比高，磁盘空间占用较少，支持简单2D动画
    JPEG格式（扩展名为.jpg或.jpeg）：高度压缩，图像的颜色质量有所降低，设计师不会选用这种格式，但报业用户使用的较多
    JPEG2000格式：与JPEG相比，它具备更高压缩率以及更多新功能的新一代静态影像压缩技术。
    TIFF格式：是Mac中广泛使用的图像格式，特点是图像格式复杂、存贮信息多，非常有利于原稿的复制
    PSD格式：Photoshop的专用格式，在Photoshop所支持的各种图像格式中，PSD的存取速度比其它格式快很多，功能也很强大
    PNG格式：PNG是目前最不失真的格式，汲取了GIF和JPG二者的优点，存贮形式丰富，能把图像文件压缩到极限，利于网络传输，又能保留与图像品质有关的信息，缺点是不支持动画应用效果
    SWF格式：Flash制作出一种后缀名为SWF（Shockwave Format）的动画，适合网络传输，放大不失真

3、常用声音文件类型

    CD格式：天籁之音，近似无损的，基本上是忠于原声，*.cda
    WAV：无损的音乐，微软公司开发，WAV格式的声音文件质量和CD相差无几
    MP3：流行的风尚，诞生于八十年代的德国，文件尺寸小，音质好
    MIDI：作曲家的最爱
    WMA：最具实力的敌人，音质要强于MP3格式，更远胜于RA格式

4、常用视频文件类型

    AVI格式：最清晰的、最常用的
    DV-AVI格式：摄像机采集常用
    MPEG格式：MPEG－1 、MPEG－2 、MPEG－4
    DivX格式（DVDrip）
    RM格式：用的少了
    RMVB格式：比RM清晰些，一部大小为700MB左右的DVD影片，转录成同样视听品质的RMVB格式，最多也就400MB左右，具有内置字幕和无需外挂插件支持

5、文件属性：描述文件特征的属性



五、文件系统模型

- 文件系统模型：模型分为三个层次，最底层是对象及其属性说明；中间层是对对象进行操纵和管理的软件集合，最高层是文件系统提供给用户的外文件系统接口



https://blog.csdn.net/diviner_s/article/details/112253441





## 文件系统

文件系统（文件管理系统的简称）就是操作系统中实现文件统一管理的一组软件和相关数据的集合，专门负责管理和存取文件信息的软件机构。
文件系统的五个功能：
按名存取
统一用户接口
并发访问和控周
安全性控制
差错恢复

## 文件系统的类型

常见的文件系统的类型有：FAT、VFAT、FAT32、NTFS、EXT2、HPFS、HFS
FAT是File Allocation Table（文件分配表）的缩写，最早用于DOS操作系统中。
在windows95中，FAT系统获得了一个新名称一VFAT(Virtual File Allocation Table,虚拟文件分配表）。VFAT与FAT的主要区别在于：
VFAT允许更长的文件名和更快的VO.VFAT支持32位体系结构。
FAT32是FAT系统的增强版本，也支持32位体系结构。
NTFS即NT File System,它具有类似事务日志的高级功能，以防磁盘出现故障，并允许您为不同的目录设置权限。
EXT2是Liux系统中标准的文件系统。HPFS是OS/2操作系统上使用的文件系统，而HFS是苹果电脑使用的的文件系统。



## 文件系统的逻辑结构

文件的结构是指文件的组织形式。从用户角度看到的文件组织形式称为文件的逻辑结构，从物理实现的角度看文件在存储器上的存放方式称为文件的物理结构。
文件的逻辑结构有两类：有机构的记录式文件：无结构的流式文件。
无结构的流式文件：文件体为字节流，不划分记录，通常采用顺序访问方式，并且每次可访问任意长度的数据，其长度以字节为单位。
在UNX中，所有的文件都被看做流式文件。

文件的逻辑结构就是用户所看到的文件的组织形式。

文件划分为三类逻辑结构：无结构的字符流式文件、定长记录文件和不定长记录文件构成的记录树。

定长记录文件和不定长文件可以统称为记录式文件。

#### 流式文件

流式文件是有序字符的集合，其长度为该文件所包含的字符个数，所以又称为字符流文件。

源程序、目标代码等文件属于流式文件。UNIX内系统采用流式文件结构。

#### 记录式文件

定长记录文件：各个记录长度相等。在检索时，可以根据记录号i及记录长度L就可以确定该记录的逻辑地址。

不定长记录文件：各个记录的长度不等，在查找时，逐条查找，直到找到所需要的记录。

## 文件系统的物理结构

常见的文件系统的物理结构有三种：连续结构、链接结构和索引结构：

### 顺序结构

#### 顺序结构原理

顺序结构又称为连续结构，这是一种最简单的文件物理结构，他把逻辑上连续的文件信息依次存放在连续编号的物理快中。

在顺序结构中，一个文件的目录项中只要指出该文件占据的总块数和起始块号即可。

#### 顺序结构的优缺点

**优点：**只要是知道了文件在[文件存储](https://cloud.tencent.com/product/cfs?from=10680)设备上的起始块号和文件长度，就能很快地进行存取。

**缺点：**文件不能动态增长。

### 链接结构

#### 链接结构原理

为每个文件构造所使用的磁盘块的链表。使用这种链接结构的文件，将逻辑上连续的文件分散存放在若干个不连续的物理块中。

间接索引是在索引表所指的物理快中不存放在文件信息，而是装有存在这些信息的物理快地址。

在索引结构文件中要存取文件时，需要至少访问存储设备两次以上，其中，一次是访问索引表，另一次是根据索引表访问在存储设备上的文件信息。

**索引表的链接模式：**一个索引表通常就是一个物理盘快。对大文件就用多个索引连接在一起。

**多级索引：**将一个大文件的所有索引表（二级索引）的地址存放在另一个索引表（一级索引）中。

### 索引结构的示例–I节点

**基本思想**：给每个文件赋予一张称为I节点的小表，在这张小表中列出了文件属性及文件中个块在磁盘上的地址。

文件数据盘快，称为直接盘快。

该索引指向文件数据盘快，称为一重间接盘快。

二级索引表，称为二重间接盘快。

三级索引表，称为三重间接盘快。

## 文件的存储介质

### 存储介质的特点

外存储设备同内存相比较，一般有容量大、断电后仍可保存信息、速度快慢、成本较低等特点。 外存储设备通常由驱动部分和存储介质两部分组成。存储介质又常称为卷。 驱动器的作用是是计算机能够实现读写（及保存、控制、测试）存储介质上的内容。 存储设备有很多种类。如磁盘、磁带、磁鼓、纸带、光盘和内存等。一个计算机系统中可同时连接说中存储设备。 磁盘空间由盘面、柱面、磁道和扇区组成。 外存设备存取的过程大致由：读状态-》置数据-》置地址-》置控制-》读状态。

### 用户对外存储设备的要求

用户对外存设备的要求是：方便、效率、安全。

1. 在读写外存储设备时不涉及硬件细节，用户直接使用逻辑地址和逻辑操作。
2. 外存储设备存取速度尽可能快，容量大切空间利用率高。
3. 外存储设备上存放的信息安全可靠，防止来自硬件的故障和他人的侵权。
4. 可以方便的共享，存储空间可以动态扩大、缩小，携带，拆卸便捷，可随时了解存储设备及使用情况。
5. 以尽可能小的代价完成上述要求。

### 文件在存储设备中的存取

#### 顺序存储设备

磁带就是典型的顺序存储介质。 优点：存储容量大； 缺点：存取速度比较慢。

#### 随机存取设备

磁盘是典型的随机存储设备。

磁盘一般由若干个磁盘片组成，每个磁盘片对应两个读写磁头，分别对磁盘片的上下两面进行读写。各个磁头与磁头臂之间相连。系统在对磁盘初始化时，将盘片上划分出一些同心圆，作为存储信息的介质，称为磁道。对每个磁道又分为若干段，称为扇区。每个扇区就构成了一个物理快，整个磁盘上所有扇区（物理块）统一编号，从零开始，所有磁盘片的相同磁道称为柱面。

磁盘上每个物理快的位置可用柱面号、磁头号、扇区号。

1. 已知物理号，则磁盘地址： 
   - 柱面号 = [ 物理块号/(磁头数 X 扇区数) ]
   - 磁头号 = [(物理块号 mod (磁头数 X 扇区数)) / 扇区数]
   - 扇区号 = (物理块号 mod (磁头数 X 扇区数)) mod 扇区数
2. 已知磁盘地址： 
   - 物理块号 = 柱面号 X（磁头数 X 扇区数）+ 磁头号 X 扇区数 + 扇区号。

磁头臂只能沿半径方向移动。在访问磁盘时，首先要把磁头臂移动到相应柱面的磁道上，称为寻道。然后等待盘片旋转，使指定的扇区转到磁头之下，实现了对磁道和扇区的定位。最后控制磁头对扇区中的数据进行读写。

一次访问磁盘的时间由寻道时间、旋转定位时间和数据传输时间所组成，寻道时间是机械动作的时间，因而需要花费的时间最长。

## 文件控制块和目录文件

为了实现按名存取文件，系统必须为每个文件设置用于描述和控制文件的数据结构，它至少要包括文件名和存放文件的物理地址，这个数据结构别称为文件控制块FCB,而FCB的有序集合就称为文件目录。
FCB中包含下列三类信息：

- 基本信息：文件名、文件物理地址、文件长度等：
- 存取控制信息：文件的存取权限：
- 
- 
- 信息：文件建立的日期、最后一次修改日期等：

文件目录通常以文件形式存放，通常称这种特殊的文件为目录文件。

文件控制块

为了实现按名存取，文件系统会为每个文件设置一个文件控制块 (FCB)。它是一种用于存放控制文件需要的各种信息的数据结构。通常包含以下信息：

    基本信息 (文件名、物理地址、逻辑结构)
    存取控制信息 (文件权限相关)
    使用信息 (文件建立、修改信息)

FCB的有序集合叫做文件目录，一个FCB就是一个文件目录项。

创建一个新文件，实际上是系统分配一个FCB，存放在文件目录中的一个目录项。



# 作业控制

作业是系统为完成一个用户的计算任务或一次事物处理所做的所有工作的总和。
控制用户作业运行有两种方式：脱机方式和联机方式。
在脱机控制方式中，作业运行的过程无须人工干预，于是，用户必须用作业控制语言(CL)编写作业说明书，指示计算机按自己的意图工作。
在联机控制方式中，操作系统向用户提供一组联机命令，用户通过终端键入相应命令指示计算机做相应的工作，整个作业的运行过程需要人工干预。
作业由程序、数据和作业说明书三部分组成。

作业有四种状态：提交、后备、执行和完成，操作系统通过作业控制块来实现状态的转换。作业控制块JCB是记录用户名、作业名、状态标志等信息的登记表。

## 选择调度算法的目标和准则

选择的调度算法应与系统的设计目标一致。
均衡使用资源。
提高系统吞吐量。
响应时间短、周转时间短。
优先权准则。
平衡系统和用户的要求。

1、计算机作业的概念

计算机中的作业是为了完成某个用户的计算任务所做工作的总和。

作业管理程序：操作系统中用来控制作业进入、执行、撤销的一组程序。

2、作业与作业的控制方式

脱机控制方式：用户需要把自己需要计算机完成的任务用作业控制语言编写成作业说明书，连同作业一并交给操作系统。作业的执行过程是不需要人为干预的。

联机控制方式：操作系统向用户提供一组联机命令，用户通过 终端输入命令将自己需要计算机干什么的意图高速计算机，用来控制作业的运行过程，这个是需要人机交互配合的。

作业的组成：程序、数据、作业说明书。

作业说明书组成：作业基本情况、作业控制、作业资源要求描述。

作业基本情况：用户名、作业名、编程语言、最大处理时间。

作业控制描述：作业控制方式、作业步骤的操作顺序、作业执行出错处理

作业资源要求描述：处理时间、优先级、主存空间、外设类型、数量。

3、作业状态及转换

1、提交：通过输入设备送入计算机系统的过程状态称为提交状态。

2、后备：通过Spooling系统将作业输入到计算机系统的后备存储器中、随时等待作业调度程序调度时的状态。

3、执行：当作业被作业调度程序选中，为其分配需要的资源、并建立相应的进程后，作业就进入了执行状态。

4、完成：作业正常结束或异常终止时，作业就会进入完成状态。作业调度程序会对该作业进行后续处理，比如撤销作业的控制块、回收作业占用的系统资源等。

4、作业控制块和作业后备队列

作业控制块（JCB）：记录与该作业有关的各种信息的登记表。它是作业的唯一标识，包括用户名、作业名、状态标志等信息。

作业后备队列：作业控制块排成一个或多个队列称为作业后备对了。是由若干个JCB组成的。

5、作业调度

作业调度算法：

1、先来先到：按照作业到达的先后进行调度。优先启动等待时间最长的作业。

2、短作业有限：优先运行时间最短的的作业。

3、响应比高优先：响应比高的作业优先启动。

公式：R=作业响应时间/作业执行时间

作业响应时间为作业进入系统后的等候时间与作业的执行时间之和。R=1+(作业等待时间)/作业执行时间

特点：算法负责，系统开销大。

4、优先级调度算法：由用户指定作业优先级，优先级高的作业先启动。也可以由系统根据作业要求的紧迫程度决定优先启动。

5、均衡调度算法：根据系统的运行情况和作业本身的特性对作业进行分类。作业调度程序轮流地从这些不同类别的作业挑选对应的作业执行。

6、作业调度算法性能的衡量指标

在批处理为主的系统中，通常用平均周转时间或平均带权周转时间来衡量调度性能的优劣。

一、处理机调度相关基本概念
1、调度方式和调度算法的若干准则
1)面向用户的准则：周转时间短（CPU执行用时Ts、周转时间T=Ts+Tw、带权周转时间W= T/Ts）、响应时间快、均衡性、截止时间的保证、优先权准则
2)面向系统的准则：系统吞吐量高、处理机利用率好、各类资源的平衡利用
3)批处理系统为照顾为数众多的短作业，应采用短作业优先的调度算法；分时系统为保证系统具有合理的响应时间，应采用轮转法进行调度
二、常用调度算法
**1、先来先服务调度算法FCFS**
（1）按照作业提交，或进程变为就绪状态的先后次序分派CPU；
（2）新作业只有当当前作业或进程执行完或阻塞才获得CPU运行
（3）被唤醒的作业或进程不立即恢复执行，通常等到当前作业或进程出让CPU。（所以，默认即是非抢占方式）
（4）有利于CPU繁忙型的作业，而不利于I/O繁忙的作业（进程）。

| 名称         | 式子                             |
| ------------ | -------------------------------- |
| 响应比       | (等待时间 + 运行时间) / 运行时间 |
| 周转时间     | 完成时间 - 到达时间              |
| 带权周转时间 | 周转时间 / 运行时间              |
| 完成时间     | 开始时间 + 运行时间              |





| 作业 | 到达时间/h | 运行时间/h | 开始时间 | 完成时间 | 周转时间 | 带权周转时间 | 平均周转时间 | 平均带权周转时间 |
| ---- | ---------- | ---------- | -------- | -------- | -------- | ------------ | ------------ | ---------------- |
| 1    | 8.0        | 2.0        | 8.0      | 10.0     | 2.0      | 1.0          | 2.075        | 4.73             |
| 2    | 8.6        | 0.6        | 10.0     | 10.6     | 2.0      | 2.0/0.6      |              |                  |
| 3    | 8.8        | 0.2        | 10.6     | 10.8     | 2.0      | 2.0/0.2      |              |                  |
| 4    | 9.0        | 0.5        | 10.8     | 11.3     | 2.3      | 2.3/0.5      |              |                  |

平均周转时间为：所有作业的周转时间之和/作业数量

(2.0 + 2.0 + 2.0 + 2.3) / 4 = 2.075

平均带权周转时间为：所有作业的带权周转时间之和/作业数量

(1.0 + 2.0/0.6 + 2.0/0.2 + 2.3/0.5) / 4 = 4.73

短作业优先（SJF）

短作业优先会先运行运行时间短的作业，比如上面的作业中，运行时间最短的是作业3，有人会问那是不是先运行作业3呢？答案是不对的，因为作业3的到达时间比较晚，在作业3到达之前作业1是第一个到达的，所以还是先运行作业1，作业1的完成时间是10.0，这时所有的作业都已经到达了，按照短作业优先算法，接下来运行作业3，然后是作业4，最后是作业2

运行作业1：

    开始时间为：8.0
    完成时间为： 8.0+2.0=10.0
    周转时间为：10.0-8.0=2.0
    带权周转时间为：2.0/2.0=1.0

运行作业3：

    开始时间为：10.0
    完成时间为： 10.0+0.2=10.2
    周转时间为：10.2-8.8=1.4
    带权周转时间为：1.4/0.2=7

其他作业也是相同的原理，就不一一都写出来了，所有作业计算如下：

| 作业 | 到达时间/h | 运行时间/h | 开始时间 | 完成时间 | 周转时间 | 带权周转时间 | 平均周转时间 | 平均带权周转时间 |
| ---- | ---------- | ---------- | -------- | -------- | -------- | ------------ | ------------ | ---------------- |
| 1    | 8.0        | 2.0        | 8.0      | 10.0     | 2.0      | 1.0          | 1.95         | 3.975            |
| 2    | 8.6        | 0.6        | 10.7     | 11.3     | 2.7      | 2.7/0.6      |              |                  |
| 3    | 8.8        | 0.2        | 10.0     | 10.2     | 1.4      | 1.4/0.2      |              |                  |
| 4    | 9.0        | 0.5        | 10.2     | 10.7     | 1.7      | 1.7/0.5      |              |                  |



# 数据库

数据库系统(DataBase System,DBS)从广义上看，是指由数据库、硬件、软件和人员组成的一个系统。
数据库指的是长期储存在计算机内的，有组织的，可共享的数据集合。
硬件指的是计算机系统的各种物理设备。
软件包括操作系统、数据库管理系统及应用程序。
人员包括：系统分析员和数据库设计人员、应用程序员、最终用户和数据库管理员。

数据库管理技术发展的三个阶段
人工管理阶段，其特点是：数据量少、数据和应用程序一一对应（导致数据不共享、数据冗余、独立性差）、数据不保存、没有软件系统来专门管理数据而由应用程序来管理。
文件系统阶段，其特点是：数据可长期保存、数据跟应用程序不再直接对应、数据共享性差、数据冗余大、数据不一致、数据联系弱。
数据库系统阶段，其显蕾特点是：数据结构化、数据共享性高冗余度低且易扩充、数据独立性高。



摸型就是对现实世界特征的抽象和模拟，数据摸型就是对现实世界数据特征的抽象。
从事物的客观特征到计算机里数据的具体表示经历三个阶段：

数据模型三要素：数据结构、数据操作和数据约束条件。



实体是现实世界中可以相互区别的事物。实体集是具有相同属性的实体集合。ER模型用来表述人对现实世界的抽象，是一种概念模型表达方法。
实体的联系分为实体内部的联系和实体间的联系。实体内部的联系反映数据在同一记录内部各字段的联系：实体集间的联系有三种类型：

## 层次模型

常见的三种数据模型是层次模型、网状模型和关系模型。
层次模型采用树型结构来表示数据之间的关系。

### 网状模型

采用网络结构表示实体类型及实体间联系的数据模型称为网状模型，它允许多个结点无双亲，也允许一个结点有多个双亲。

关系模型
在关系模型中用表结构来表示实体集以及实体之间的联系，其最大的特色是描述的一致性。
比如有关系模式S(Sno,Sname,SD,Sage,Sex),它的一个实例为：

E-R模型如何向关系模型转化？
候选码：若关系中某一属性或属性组能唯一的标识一个元组，且没有多余属性，则称该属性（组）为候选码。由数据库设计者选定的自前正在使用的候选码称为主码。
E-R模型向关系模型的转换规则有6条：
(1)一个实体型转换为一个关系模式，实体的属性就是关系的属性，实体的码就是关系的码：
(2)一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换为一个独立的模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选键：

E-R模型如何向关系模型转化？（续）
(3)一个1:n联系可以转换为一个独立的关系模式，也可以与任意端对应的关系模式合并。如果转换为一个独立的模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为端实体的码。
(4)一个m:n联系转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。
(5)三个以上实体间的一个多元联系可以转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。
(6)具有相同码的关系模式可以合并。

数据定义功能：DBMS提供数据定义语言DDL,用户使用DDL对数据库的结构进行描述。
数据库操作功能：DBMS向用户提供数据操作语言DML,实现对数据的操作。
数据库运行管理：对数据库进行并发控制、安全性检查和存取控制等。
数据组织、存储和管理：DBMS分类组织和管理各种数据，包括数据字典、存取路径等。
数据库的建立和维护：包括数据库的初始建立、数据转换、数据库的转储和恢复和数据库的重构等。

数据结构化并且统一管理。
有较高的数据独立性。
数据控制功能：
数据库的安全性保护
数据的完整性
并发控制
故障恢复

数据库的三级模式结构

数据库系统的三级模式结构是指模式、外模式和内模式。
1、模式

 模式也称为
 逻辑模式或概念模式，是数据库中
 全体数据的逻辑结构和特征的描述，是
 所有用户的公共数据视图。一个数据库只有一个模式，
 模式位于三级结构的中间层。
2、外模式

 外模式也称为
 用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的
 局部数据的逻辑结构和特征的描述，是
 数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。
 外模式是模式的子集，一个数据库可以有多个外模式。
3、内模式

 内模式也称为
 存储模式，
 一个数据库只有一个内模式，它是数据
 物理结构和存储方式的描述，是数据在
 数据库内部的表示方式。
二、三级模式之间的映射

 数据库管理系统在三级模式之间提供了
 两层映射，分别为外模式/模式映射、模式/内模式映射。
1、外模式/模式映射

 对于
 同一个模式可以有任意多个外模式。对于每一个外模式，数据库系统都有一个外模式/模式映射。当模式被改变时，数据库管理员对各个外模式/模式映射做相应的改变，可以使外模式保持不变。这样，依据数据外模式编写的应用程序就不用修改，
 保证了数据与程序的逻辑独立性。
2、模式/内模式

 数据库中只有一个模式和一个内模式，所以
 模式/内模式的映射是唯一的，它定义了数据库的全局逻辑结构与存储结构之间的对应关系。当数据库的存储结构被改变时，数据库管理员对模式/内模式映射做相应的改变，可以使模式保持不变，应用程序相应地也不做变动。这样，
 保证了数据与程序的物理独立性。

分布式数据库系统包括物理上分布、逻辑上集中的分布式结构和物理上逻辑上都分布的分布式数据库两种。
前者的指导思想是：把企业整体的数据模式按数据来源和用途，合理分布在系统的多个结点上，使大部分数据就地或者就近存取。数据在物理上分布后，由系统统一管理，使用户感觉不到数据的分布。
后者一般由两部分组成：一是本结点的数据模式，二是本结点共享其他结点上有关的数据模式。

## 数据库语言



SQL程序语言有四种类型，对数据库的基本操作都属于这四类，它们分别为；数据定义语言(DDL)、数据查询语言（DQL）、数据操纵语言（DML）、数据控制语言（DCL）

数据定义语言DDL以：用于定义、删除、修改关系模式及视图：
数据操作语言DML:用于查询、插入和修改等。
事务控制：控制事务的开始及结束的命令。
完整性：限制数据库中的数据必须满足的完整性约束条件的命令。
权限管理：对关系和视图访问权限的命令。

## 数据定义语言（DDL）

DDL全称是Data Definition Language，即数据定义语言，定义语言就是定义关系模式、删除关系、修改关系模式以及创建数据库中的各种对象，比如表、聚簇、索引、视图、函数、存储过程和触发器等等。

数据定义语言是由SQL语言集中负责数据结构定义与数据库对象定义的语言，并且由CREATE、ALTER、DROP和TRUNCATE四个语法组成。比如：

综合统一：
高度非过程化：
面向集合的操作方式：
两种使用方式：
语言简洁、易学易用。



事务
数据库管理系统运行的基本工作单位是事务，事务是用户定义的一个数据库操作序列，这些操作序列要么全做，要么全不做，是一个不可分割的工作单位。事务具有以下特性：
原子性(Atomicity):数据库的逻辑工作单位：
一致性(Consistency):使数据库从一个一致性状态变到另一个-致性状态：
一隔离性(Isolation)：不能被其他事务千扰：
持续性（永久性）(Durability):一旦提交，改变就是永久性的。
事务通常以BEGIN TRANSACTION（事务开始）语句开始，以COMMIT或ROLLBACK语句结束。

数据库的并发操作带来的三个问题：丢失修改：读脏数据：不可重复读：

排它型封锁(简称X封锁、Xlock)：其含义是如果事务T对数据A实现了X封锁，那么只允许事务T读取和修改数据A,其他事务要等事务T解除X封锁以后，才能对数据A实现任何类型的封锁。可见X封锁只允许一个事务独锁某个数据，具有排他性。又称为写锁。
共享型封锁(简称S封锁、Slock):如果事务T对数据A实现了S封锁，那么允许事务T读取数据A,但不能修改数据A,在所有S封锁解除之前决不允许任何事务对数据A实现X封锁，但其他事务可以再对A加S锁。又称为读锁。

封锁协议
在运用X锁和S锁这两种基本锁对数据进行加锁时，还要规定一些规则，例如何时申请封锁、持锁时间、何时释放，这些规则的集合称为封锁协议。
一级封锁协议：事务T在修改数据R之前必须先对其加X封锁，直到事务结束才释放。一级封锁协议可防止丢失修改，并保证务T是可恢复的。但不能保证可重复读和不读脏数据。
二级封锁协议：一级封锁协议加上事务T在读取数据R之前先对其加S锁，读完后即可释放S锁。二级封锁协议可防止丢失修改，还可防止读"脏"数据但不能保证可重复读
三级封锁协议：一级封锁协议加上事务T在读取数据R之前先对其加S锁，直到事务结束才释放。三级封锁协议可防止丢失修改、防止读脏数据与防止数据重复读。

事务内部故障的恢复
事务故障的恢复是由系统自动完成的，对用户是透明的，步骤如下：
(1)反向扫描文件日志，查找该事务的更新操作：
(2)对该事务的更新操作执行逆操作：
(3)继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理：
(4)如此处理下去，直至读到此事务的开始标记，事务故障恢复完成。

系统故障
系统故障是指造成系统停止运行的任何事件，使得系统重新启动，包括硬件错误、操作系统错误、DBMS代码错误和突然停电等。
系统故障的恢复在重新启动时自动完成，不需要用户干预，步骤如下：
（1）正向扫描日志文件，找出在故障发生前已经提交的事务，将其事务标识记入重做(Rdo)队列。同时找出故障发生时尚未完成的事务，将其事务标识记入撒销(Undo)队列：
(2)对撒销队列中的各个事务进行撒销处理：反向扫描日志文件，对每个Undo事务的更新操作执行逆操作：
(3)对重做队列中的各个事务进行重做处理：正向扫描日志文件，对每个Redo事务重新执行日志文件登记的操作。

介质故障、计算机病毒
系统故障常称为软故障，介质故障称为硬故障，即外存故障，如磁盘损坏、磁头碰撞。
计算机病毒是一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序。
介质故障与病毒破坏的恢复步骤如下：
(1)装入最新的数据库后备副本，使数据库恢复到最近一次转储时的一致性状态：
(2)从故障点开始反向读日志文件，找出已提交事务标识将其记入重做队列：
(3)从起始点开始正向阅读日志文件，根据重做队列中的记录，重做所有已完成事务，将数据库恢复至故障前某一时刻的一致状态。

用户标识和鉴别
用户标识和鉴别是系统提供的最外层的安全保护措施。其方法是每次用户要进入系统时由系统提供一定的方式让用户标识自己的名字或身份，系统对用户身份进行鉴定核实后才提供系统使用权，常用的方法有下列几种：
(1)用户名或用户标识号：在定义外模式时为每个用户提供一个用户代号存放在数据字典中。用户使用系统时，系统鉴别此用户是否是合法用户，若是，则可进入下一步的核实，否则不能使用系统。
(2)口令：为了进一步核实用户，系统常常要求用户输入口令。为保密起见，用户在终端上输入的口令不显示在屏幕上，系统核对口令以鉴别用户身份。以上的方法简单易行，但用户名、口令容易被人窃取，因此还可以用更可靠的方法。
(3)随机数检验：用户根据预先约定好的计算公式求出一个数值作为动态口令送入计算机，当这个值与系统算出的结果一致时，才允许进入系统。

存取控制
在数据库系统中，为了保证用户只能存取有权存取的数据，系统要求对每个用户定义存取权限。存取权限包括两方面的内容：一方面是要存取的数据对象：另一方面是对此数据对象进行操作的类型。
对一个用户定义存取权限就是要定义这个用户可以在哪些数据对象上进行哪些类型的操作。在数据库系统中对存取权限的定义称为授权”，这些授权定义经过编译后存放在数据库中。
对于获得使用权又进一步发出存取数据库操作的用户，系统就根据事先定义好的存取权限进行合法权检查，若用户的操作超出了定义的权限，系统拒绝执行此操作，这就是存取控制。
在SQL中授权和收回就是通过GRANT和REVOKE语句来实现的。

审计的主要任务是对用户（包括应用程序）使用系统资源（包括软硬件和数据）的情况进行记录和审查，旦发现问题，审计人员通过审计跟踪，可望找出原因，追查责任，防止类似问题再度发生。因此，审计往往作为保证数据库安全的一种补救措施。
数据库系统中的审计工作包括如下几种：
设备安全审计
操作审计
应用审计
攻击审计

事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撒操作
请求，即这些操作要么同时成功，要么同时失败。

完整性约束条件一般指的是对数据库中数据本身的某些语法、语义限制，数据间的逻辑约束及数据变化时应遵守的规则等。

完整性规则的五元组(D,O,A,C,P)
D:约束作用的数据对象：O:触发完整性检查的数据库操作：A:数据对象必须满足的断言或语义约束：C:选择A作用的数据对象值的谓词：P:违反完整性规则时触发的过程。如学号不能为空可表示为：
D:约束作用的数据对象为Sno属性。
O:插入或修改元组时。
A:Sno定义为Not Null.
C:无。
P:拒绝执行该操作。

参照完整性
在被参照关系中别除元组时，有三种删除方式：
级联别除(Cascades)：将参照关系中所有外码值与被参照关系中要别除元组主码值相同的元组一起删除。如果参照关系同时又是另一个关系的被参照关系，则这种删除操作会继续级联下去。
受限别除(Restrict默认)：仅当参照关系中没有任何元组的外码值与被参照关系中要别除元组的主码值相同时，系统才可以执行制除操作，否则拒绝执行别除操作。
置空别除(Set Null)：删除被参照关系的元组时，并将参照关系中相应元组的外码值置为空值。
在参照关系中插入元组时有两种处理方式：一受限插入：仅当被参照关系中存在相应的元组时，其主码值与参照关系插入元组的外码值相同时，系统才执行插入操作，否则拒绝此操作。
递归插入：首先向被参照关系中插入相应的元组，其主码值等于参照关系插入元组的外码值，然后向参照关系插入元组。





数据库几乎是所有系统的核心模块，它将数据有条理地保存在储存介质(磁盘）中，
并在逻辑上，将数据以结构化的形态呈现给用户。支持数据的增、删、改、查，并在过程中保障数据的正确且可靠。

要做到这点并非易事，常见的例子就是银行转账，A账户给B账户转账一个亿(T1)，买一块地盖房子。在这种交易的过程中，有几个问题值得思考：

- 如何**同时保证**上述交易中，A账户总金额减少一个亿，B账户总金额增加一个亿？ A
- A账户如果同时在和C账户交易(T2)，如何让这两笔交易互不影响？ I
- 如果交易完成时数据库突然崩溃，如何保证交易数据成功保存在数据库中？ D
- 如何在支持大量交易的同时，保证数据的合法性(没有钱凭空产生或消失) ？ C

要保证交易正常可靠地进行，数据库就得解决上面的四个问题，这也就是`事务`诞生的背景，它能解决上面的四个问题，对应地，它拥有四大特性：

- 原子性（**A**tomicity）: 事务`要么全部完成，要么全部取消`。 如果事务崩溃，状态回到事务之前（事务回滚）。
- 隔离性（**I**solation）: 如果2个事务 T1 和 T2 同时运行，事务 T1 和 T2 最终的结果是相同的，不管 T1和T2谁先结束。
- 持久性（**D**urability）: 一旦事务提交，不管发生什么（崩溃或者出错），数据要保存在数据库中。
- 一致性（**C**onsistency）: 只有合法的数据（依照关系约束和函数约束）才能写入数据库。

## 数据库封锁协议

## 1.什么是封锁

- 封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁
- 加锁后事务T就对该数据对象有了一定的控制，在事务T释 放它的锁之前，其它的事务不能更新此数据对象

封锁就是事务T在对某个数据对象（例如表、记录等）操 作之前，先向系统发出请求，对其加锁

加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。

封锁是实现并发控制的一个非常重要的技术

## 2.基本封锁类型

- 一个事务对某个数据对象加锁后究竟拥有什么样 的控制由封锁的类型决定。
- 基本封锁类型
   \- 排它锁（Exclusive Locks，简记为X锁）
   \- 共享锁（Share Locks，简记为S锁）

排它锁 || X锁

目录

    若事务T对数据对象A加上X锁，则只允许T读取 和修改A，其它任何事务都不能再对A加任何类型 的锁，直到T释放A上的锁
    保证其他事务在T释放A上的锁之前不能再读取和 修改A
    排它锁又称为写锁

共享锁 || S锁

    若事务T对数据对象A加上S锁，则事务T可以读A 但不能修改A，其它事务只能再对A加S锁，而不 能加X锁，直到T释放A上的S锁
    保证其他事务可以读A，但在T释放A上的S锁之 前不能对A做任何修改
    共享锁又称为读锁

锁的相容矩阵







1.     
数据库的事务故障指的是什么，发生事务故障后，DBMS如何恢复数据库?

事务故障指某个事务在运行过程中由于种种原因未运行至正常终止点就夭折了。

恢复方法：撤销事务。即清除该事务对数据库的所有修改，使得这个事务像根本没有启动过一样。（需要从后到前撤销，最新完成的操作的更新影响要先消失。因此，需要从后到前扫描日志文件。）

2.     
数据库的系统故障指的是什么，发生系统故障后，DBMS如何恢复数据库?

系统故障是指造成系统停止运转的任何事件，使得系统需要重新启动。

恢复方法：①清除尚未完成的事务对数据库的所有修改，UNDM（撤销）所有未完成的十五（从后往前）。

②将缓冲区中已完成事务提交的结果写入数据库，REDO（重做）所有已提交的事务（从前往后）。

3.     
数据库的介质故障指的是什么，发生介质故障后，DBMS如何恢复数据库？

介质故障是指硬件故障使存储在硬盘上的数据丢失。（破坏性大于前两个故障）

恢复方法：①在新磁盘上，导入最新的数据库备份文件。

②根据日志文件，找出来从该最新备份后开始，到故障发生时，哪些事务已经完成。

REDO(重做)所有已提交的事务。（从前往后）。

4.     
数据库的事务故障和系统故障的恢复技术有何相同之处和不同之处？

相同点：都需要UNDO(撤销)所有未完成的事务（从前往后）。

不同点：系统故障需要对还没有写入到磁盘的已经完成的事务进行REDO(重做)。

5.     
数据库的介质故障和系统故障的恢复技术有何相同之处和不同之处？

①  介质故障需要用到数据库的备份，把备份文件导入到新的介质上。

②  两种故障都需要重做，但是重做的范围不一样。

③  系统故障需要对还没有写入到磁盘的已经完成的事务进行REDO(重做)。

③介质故障需要从上一次最新的备份开始到发生故障中间所有已经完成的事物进行REDO（重做）。





## 事务内部故障的恢复

⊙事务故障的恢复是由系统自动完成的，对用户是透明的，步骤如下：
(1)反向扫描文件日志，查找该事务的更新操作：
(2)对该事务的更新操作执行逆操作：
(3)继续反向扫揽日志文件，查找该事务的其他更新操作，并做同样处理；
(4)如此处理下去，直至读到此事务的开始标记，事务故障恢复完成。

系统故障
系统故障是指造成系统停止运行的任何事件，使得系统重新启动，包括硬件错误、操作系统错误、DBMS代码错误和突然停电等。
系统故障的恢复在重新启动时自动完成，不需要用户干预，步骤如下：
正向扫描日志文件，找出在故障发生前已经提交的事务，将其事务标识记入重做(R©do)队列。同时找出故障发生时尚未完成的事务，将其事务标识记入撤销(Undo)队列：
对撤销队列中的各个事务进行撤销处理：
反向扫描日志文件，对每个Undo事务的更新操作执行逆操作：
对重做队列中的各个事务进行重做处理：正向扫描日志文件，对每个Redo事务重新执行日志文件登记的操作

用户标识和鉴别
用户标识和鉴别是系统提供的最外层的安全保护措施。其方法是每次用户要进入系统时由系统提供一定的方式让用户标识自己的名字或身份，系统对用户身份进行鉴定核实后才提供系统使用权，常用的方法有下列几种：
(1)用户名或用户标识号：在定义外模式时为每个用户提供一个用户代号存放在数据字典中。用户使用系统时，系统鉴别此用户是否是合法用户，若是，则可进入下一步的核实，否则不能使用系统。
(2)口令：为了进一步核实用户，系统常常要求用户输入口令。为保密起见，用户在终端上输入的口令不显示在屏幕上，系统核对口令以鉴别用户身份。以上的方法简单易行，但用户名、口令容易被人窃取，因此还可以用更可靠的方法。
(3)随机数检验：用户根据预先约定好的计算公式求出一个数值作为动态口令送入计算机，当这P值与系统算出的结果一致时，才允许进入系统。

存取控制
在数据库系统中，为了保证用户只能存取有权存取的数据，系统要求对每个用户定义存取权限。存取权限包括两方面的内容：一方面是要存取的数据对象：另一方面是对此数据对象进行操作的类型。
对一个用户定义存取权限就是要定义这个用户可以在哪些数据对象上进行哪些类型的操作。在数据库系统中对存取权限的定义称为"授权”，这些授权定义经过编译后存放在数据库中。
对于获得使用权又进一步发出存取数据库操作的用户，系统就根据事先定义婷的存取权限进行合法权检查，若用户的操作超出了定义的权限，系统拒绝执行此操作，这就是存取控制。
O在SQL中授权和收回就是通过GRANT和REVOKE语句来实现的。

# 数据结构

数据结构的定义
数据结构是指数据元素的集合及其元素之间的相互关系。
数据结构中，元素之间的相互关系称为数据的逻辑结构，元素及元素之间关系在计算机中的存储形式称为数据的存储结构或物理结构
数据结构按逻辑结构不同分为线性结构和非线性结构两大类，常见的线性结构有线性表、栈和队列，常见的非线性结构有树、图等。

## 线性表

一、线性表的定义
线性表（List）：零个或多个数据元素的有限序列。

线性表的数据集合为{a1,a2,…,an}，假设每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。

在较复杂的线性表中，一个数据元素可以由若干个数据项组成。在这种情况下，常把数据元素称为**记录**，含有大量记录的线性表又称为**文件**

线性表的顺序存储结构
一、顺序表
1、顺序表的基本概念
概念：用一组地址连续的存储单元依次存储线性表的数据元素，这种存储结构的线性表称为顺序表。

特点：逻辑上相邻的数据元素，物理次序也是相邻的。

只要确定好了存储线性表的起始位置，线性表中任一数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的储存结构，因为高级语言中的数组类型也是有随机存取的特性，所以通常我们都使用数组来描述数据结构中的顺序储存结构，用动态分配的一维数组表示线性表。



## 树

一、树的基本概念
1、树的定义
树是n（n>=0）个结点的有限集。当n = 0时，称为空树。在任意一棵非空树中应满足：

有且仅有一个特定的称为根的结点。
当n>1时，其余节点可分为m（m>0）个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一棵树，并且称为根的子树。
显然，树的定义是递归的，即在树的定义中又用到了自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：

树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。
树中所有结点可以有零个或多个后继。
因此n个结点的树中有n-1条边。

2、基本术语
下面结合图示来说明一下树的一些基本术语和概念。

考虑结点K。根A到结点K的唯一路径上的任意结点,称为结点K的祖先。如结点B是结点K的祖先,而结点K是结点B的子孙。路径上最接近结点K的结点E称为K的双亲,而K为结点E的孩子。根A是树中唯一没有双亲的结点。有相同双亲的结点称为兄弟,如结点K和结点L有相同的双亲E,即K和L为兄弟。
树中一个结点的孩子个数称为该结点的度,树中结点的最大度数称为树的度。如结点B的度为2,结点D的度为3,树的度为3。
度大于0的结点称为分支结点(又称非终端结点);度为0(没有子女结点)的结点称为叶子结点(又称终端结点)。在分支结点中,每个结点的分支数就是该结点的度。
结点的深度、高度和层次。
结点的层次从树根开始定义,根结点为第1层,它的子结点为第2层,以此类推。双亲在同一层的结点互为堂兄弟,图中结点G与E,F,H,I,J互为堂兄弟。
结点的深度是从根结点开始自顶向下逐层累加的。
结点的高度是从叶结点开始自底向上逐层累加的。
树的高度(或深度)是树中结点的最大层数。图中树的高度为4。
有序树和无序树。树中结点的各子树从左到右是有次序的,不能互换,称该树为有序树,否则称为无序树。假设图为有序树,若将子结点位置互换,则变成一棵不同的树。
路径和路径长度。树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的,而路径长度是路径上所经过的边的个数。
注意:由于树中的分支是有向的,即从双亲指向孩子,所以树中的路径是从上向下的,同一双亲的两个孩子之间不存在路径。
森林。森林是m (m≥0)棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给m棵独立的树加上一个结点，并把这m棵树作为该结点的子树，则森林就变成了树。



3、树的性质

树具有如下最基本的性质：

    树中的结点数等于所有结点的度数加1.
    度为 m m m的树中第 i i i层上至多有 m i − 1 m^{i-1} mi−1个结点（ i > = 1 i>=1 i>=1）
    高度为 h h h的 m m m叉树至多有 ( m h − 1 ) / ( m − 1 ) (m^h-1)/(m-1) (mh−1)/(m−1)个结点。
    具有 n n n个结点的 m m m叉树的最小高度为 [ l o g m ( n ( m − 1 ) + 1 ) ] [log_m(n(m-1)+1)] [logm(n(m−1)+1)]。



## 二、树的存储结构

在介绍以下三种存储结构的过程中，我们都以下面这个树为例子。









二叉树
一、二叉树的概念
1、二叉树的定义

二叉树是另一种树形结构，其特点是每个结点至多只有两棵子树( 即二叉树中不存在度大于2的结点)，并且二叉树的子树有左右之分，其次序不能任意颠倒。
与树相似，二叉树也以递归的形式定义。二叉树是n (n≥0) 个结点的有限集合:

    或者为空二叉树，即n=0。
    或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。

二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分它是左子树还是右子树。二叉树的5种基本形态如图所示。

2、几个特殊的二叉树
（1）斜树

所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。
（2）满二叉树

一棵高度为 h h h，且含有 2 h − 1 2^h-1 2h−1个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点。满二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为 2 2 2。可以对满二叉树按层序编号:约定编号从根结点(根结点编号为 1 1 1)起，自上而下，自左向右。这样，每个结点对应一个编号,对于编号为i的结点，若有双亲，则其双亲为 i / 2 i/2 i/2,若有左孩子，则左孩子为 2 i 2i 2i;若有右孩子，则右孩子为 2 i + 1 2i+1 2i+1。

在这里插入图片描述

    若 i ≤ n / 2 i≤n/2 i≤n/2, 则结点 i i i为分支结点，否则为叶子结点。
    叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。
    若有度为 1 1 1的结点，则只可能有一个，且该结点只有左孩子而无右孩子(重要特征)。
    按层序编号后，一旦出现某结点(编号为 i i i)为叶子结点或只有左孩子，则编号大于 i i i的结点均为叶子结点。
    若 n n n为奇数，则每个分支结点都有左孩子和右孩子;若 n n n为偶数，则编号最大的分支结点(编号为 n / 2 n/2 n/2)只有左孩子，没有右孩子，其余分支结点左、右孩子都有。

（4）二叉排序树

左子树上所有结点的关键字均小于根结点的关键字;右子树上的所有结点的关键字均大于根结点的关键字;左子树和右子树又各是一棵二叉排序树。
（5）平衡二叉树

树上任一结点的左子树和右子树的深度之差不超过1。
3、二叉树的性质

    任意一棵树，若结点数量为 n n n,则边的数量为 n − 1 n-1 n−1。
    非空二叉树上的叶子结点数等于度为 2 2 2的结点数加 1 1 1，即 n o = n 2 + 1 n_o=n_2+ 1 no=n2+1。
    非空二叉树上第 k k k层上至多有 2 k − 1 2^{k-1} 2k−1个结点 ( k ≥ 1 ) (k≥1) (k≥1)。
    高度为 h h h的二叉树至多有 2 h − 1 2^h-1 2h−1个结点 ( h ≥ 1 ) (h≥1) (h≥1)。
    对完全二叉树按从上到下、从左到右的顺序依次编号 1 , 2.. ∗ , n 1,2..*,n 1,2..∗,n,则有以下关系:
        i > 1 i>1 i>1时，结点 i i i的双亲的编号为 i / 2 i/2 i/2,即当 i i i为偶数时， 它是双亲的左孩子;当i为奇数时，它是双亲的右孩子。
        当 2 i ≤ n 2i≤n 2i≤n时，结点 i i i的左孩子编号为 2 i 2i 2i, 否则无左孩子。
        当 2 i + 1 ≤ n 2i+1≤n 2i+1≤n时，结点 i i i的右孩子编号为 2 i + 1 2i+1 2i+1，否则无右孩子。
        结点 i i i所在层次(深度)为 { l o g 2 i } + 1 \{log_2i\}+ 1 {log2i}+1。
    具有 n n n个 ( n > 0 ) (n>0) (n>0)结点的完全二叉树的高度为 { l o g 2 n } + 1 \{log_2n\}+1 {log2n}+1。
4、二叉树的存储结构
（1）顺序存储结构

二叉树的顺序存储是指用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为 i i i的结点元素存储在一维数组下标为 i − 1 i-1 i−1的分量中。
依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。
但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。然而，在最坏情况下，一个高度为 h h h且只有 h h h个结点的单支树却需要占据近 2 h − 1 2h-1 2h−1个存储单元。二叉树的顺序存储结构如图所示，其中0表示并不存在的空结点。



#### 2）链式存储结构

既然顺序存储适用性不强，我们就要考虑链式存储结构。**二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表**。

其中data是数据域，lchild 和rchild都是指针域，分别存放指向左孩子和右孩子的指针。
以下是我们的二叉链表的结点结构定义代码。

```
/*二叉树的二叉链表结点构造定义*/
/*结点结构*/
typedef struct BiTNode{
	TElemType data;	//结点数据
	struct BiTNode *lchild, *rchild;	//左右孩子指针
} BiTNode, *BiTree;
```



容易验证，在含有 n n n个结点的二叉链表中，含有 n + 1 n + 1 n+1个空链域。

栈

##   栈的基本概念

###   定义

  只允许在一端进行插入或删除操作的线性表。首先，栈是一种线性表，但限定这种线性表只能在某一段进行插入和删除操

  栈顶（Top）：线性表允许进行插入和删除的一端。

  栈底（Bottom）：固定的，不允许进行插入和删除的另一端。

  空栈：不含任何元素。

  如上图：a1为栈底元素，an为栈顶元素。由于栈只能在栈顶进行插入和删除操作，故进栈次序依次为a1，a2，... ,an 而出栈次序为an，...，a2，a1。栈的明显的操作特征为后进先出（Last In First Out，LIFO）,故又称 后进先出的线性表。

###   栈的基本操作

  1）InitStack（&S）：初始化空栈S

  2）StackEmpty（S）：判断一个栈是否为空

  3）Push（&S，x）：进栈，若栈未满，则将x加入使之成为新栈顶

  4）Pop（&S，&x）：出栈，若栈非空，则将栈顶元素，并用x返回

  5）GetTop(S，&x)：读栈顶元素，若栈顶元素非空，则用x返回栈顶元素

  6）DestroyStack(&S)：销毁栈，并释放栈S占用的存储空间

##   栈的顺序存储结构

###   顺序栈的实现

  采用顺序存储的栈称为**顺序栈**，它是利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶的位置。

  栈的顺序存储类型可以用以下表示：

# 计算机网络

| OSi中的层  | 功能                                   | TCP/IP协议族                                  |
| ---------- | -------------------------------------- | --------------------------------------------- |
| 应用层     | 文件传输，电子邮件，文件服务，虚拟终端 | TFTP，HTTP，SNMP，FTP，SMTP，DNS，RIP，Telnet |
| 表示层     | 数据格式化，代码转换，数据加密         | 没有协议                                      |
| 会话层     | 解除或建立与别的接点的联系             | 没有协议                                      |
| 传输层     | 提供端对端的接口                       | TCP，UDP                                      |
| 网络层     | 为数据包选择路由                       | IP，ICMIP，OSPF，BGP，IGMP，ARP，RARP         |
| 数据链路层 | 传输有地址的帧以及错误检测功能         | SLIP，CSLIP，PPP，MTU，ARP，RARP              |
| 物理层     | 以二进制数据形式在物理媒体上传输数据   | S02110，EEE802，EEE802.2                      |

# 软件工程

## *2.1 软件开发生命周期模型*

### **2.1.1 软件开发和软件测试**

为了能够进行适当的测试活动，熟悉常见的软件开发生命周期模型是测试人员职责的重要组成部分。

在任何软件开发生命周期模型中，好的测试都有以下特点：

- 每个开发活动都有对应的测试活动
- 每个测试级别都有与该级别对应的特有测试目标
- 在相应的开发活动中开始对给定的测试级别进行测试分析和设计
- 测试人员参加讨论，以确定和完善需求和设计，并在初稿完成后立即参与评审工作产品(如需求、设计、用户故事等)

无论选择哪种软件开发生命周期模型，测试活动都应该在生命周期的早期阶段开始，以遵循测试尽早介入的原则。

这里将常见的软件开发生命周期模型分类如下：

- 顺序开发模型
- 迭代增量开发模型

顺序开发模型将软件开发过程描述为线性且按照顺序的活动次序。这意味着开发过程的任何阶段都应在前一阶段完成时开始。理论上阶段没有重叠，但在实践中，从下一阶段得到早期反馈是有益的。

**2.1.1.1 顺序开发模型**

**1.瀑布模型**

瀑布模型最早由Winston W. Royce在1970年提出，在软件工程中占有重要的地位，它提供了软件开发的基本框架。从测试的角度而言，瀑布模型最大的缺点是，测试是软件开发过程中的一个阶段，测试被看做是对软件产品的最终检查，类似于制造业中将产品交付给客户之前的检查。

图2.1.1-1显示了一个传统的瀑布模型，它将软件开发生命周期划分为系统需求(System Requirment)、软件需求(Software Requirement)、分析(Analysis)、程序设计(Program Design)、编码(Coding)、测试(Testing)和运行(Operations)七个基本阶段，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。从本质来说，它是一个软件开发架构，开发过程是通过一系列阶段顺序展开的，只有当一个开发阶段完成后，下一个开发阶段才会开始。



尽管瀑布模型由于存在一些缺点而招致很多的批评，但是它对很多类型的项目而言依然是有效的。如果瀑布模型能够正确使用，可以节省大量的时间和金钱。是否采用瀑布模型，主要取决于是否能够充分理解客户的需求，以及在项目开发过程中这些需求是否经常发生变更。对于需求经常发生变更的项目，采用瀑布模型是不合适的，这时候就需要考虑其他类型的软件开发生命周期模型。



**2.V模型**

与瀑布模型不同，V模型在整个开发过程中集成了测试过程，践行了尽早测试的原则。此外，V模型还包括与每个相应开发阶段对应的测试级别，这进一步支持了尽早测试（关于测试级别的讨论见第2.2节）。在此模型中，与每个测试级别相关联的测试的执行按照顺序方式进行，但在某些情况下会发生重叠。

V模型是瀑布模型的变种，它体现的主要思想是：开发任务和测试任务是相互对等的活动且同等重要。V模型的左右两侧组成字母V的两个边，形象地体现了这一点。V模型的左侧代表软件开发过程，在软件开发过程中，系统是逐步设计完善的，编码是最后一步。V模型的右侧描述了集成和测试的过程，通过不断组合程序组件，形成更大的子系统（集成），并对它们的功能和非功能进行测试。根据这个模型，开发得到的整个系统将以验收测试作为系统集成和测试活动的结束点。

图2.1.1-2显示了由开发活动和测试活动共同组成的一个V模型，V模型主要的开发活动有需求规格说明、系统功能设计、系统技术设计、组件规格说明和编码，相应的测试级别有组件测试、集成测试、系统测试和验收测试。在不同资料中，V模型的左边各个活动可能略有不同，但是其思想都是一致的。其中，构成V模型左侧的活动就是人们熟知的瀑布模型中的活动：

- 需求规格说明：从客户或将来的系统用户中收集，并对它们进行详细描述，最终得到批准的要求和需求。需求规格说明定义了开发系统的目的和需要实现的特性和功能。
- 系统功能设计：将需求映射到系统的功能和框图上。
- 系统技术设计：设计系统的具体实现方式。这个阶段包括定义系统环境的接口，同时将整个系统分解成更小且容易理解的子系统（系统架构），从而可以对每个子系统进行独立的开发。
- 组件规格说明：定义每个子系统的任务、行为、内部结构以及与其他子系统的接口。
- 编码：通过编程语言实现所有已经定义的组件（例如：模块、单元、类）。

在V模型中，随着整个构建阶段的进行，软件系统的描述越来越详细。通常来说，在某个构建中引入的错误最容易在本构建阶段中发现。因而，对于每个构建阶段，V模型的右边定义了相应的测试级别。在每个测试级别，都要检查开发的输出是否满足具体的要求，或者是否满足这些特定阶段相关的要求。

- 组件测试：验证软件组件是否按照组件规格说明（详细设计说明）正确执行，即保证每个最小的单元能够正常运行。组件测试一般由开发人员来执行，首先设定最小的测试单元，然后通过设计相应的测试用例来验证各个组件功能的正确性。
- 集成测试：检查多个组件是否按照系统技术设计描述的方式协同工作。集成测试的主要关注点是系统能够成功编译，实现了主要的业务功能，系统各个模块之间数据能够正常通信等。
- 系统测试：验证整个系统是否满足需求规格说明。
- 验收测试：从用户的角度检查系统是否满足合同中定义的需求或者用户需求。

> ANDREAS SPILLNER，TILO LINZ，HANS SCHAEFER，SOFTWARE TESTING FOUNDATIONS，人民邮电出版社，2008-4-1

2.1.1.2 增量开发模型

顺序开发模型交付的软件包含了全套的功能，但通常需要几个月或几年的时间才能交付给利益相关者和用户。增量开发涉及到建立需求、设计、构建和测试部分系统，这意味着软件的特性逐渐增加。这些特性逐步增加的大小各不相同，有些方法增加的大一些，有些方法小一些。增加的特性可以小到对一个用户接口界面的修改或者一个新的查询选项。

这里面首先要说一下“增量”和“迭代”的区别。迭代，就是在实现软件的每一功能时反复求精的过程，是提升软件质量的过程，是从模糊到清晰的过程；而增量，则是强调软件在发布不同的版本时，每次都多发布一点点，是软件功能数量渐增地发布的过程。二者的对比如图2.1.1-3所示。



迭代开发发生在多个特性在一系列周期中一起被指定、设计、构建和测试的时候，通常是固定的时间周期。迭代可能涉及到对早期迭代中开发的特性的更改，以及项目范围的更改。每次迭代都交付工作软件，这是整个特性集中不断增长的一个子集，直到最终软件交付或开发停止。

迭代开发的例子包括：

- Rational统一过程RUP：每次迭代相对较长（例如：两到三个月），特性增加相应较大，例如两组或三组相关特性
- SCRUM：每次迭代都较短（例如：几个小时、几天或几个星期），相应的特性增加较小，例如一些增强和（或）两三个新特性
- 看板：实现时使用或不使用固定长度的迭代，这种迭代可以在完成时交付单个增强或特性，也可以将特性组合在一起立即发布
- 螺旋式（或原型）：包括创造实验性增量，其中一些可能被大量返工，甚至在后续的开发工作中被放弃

下面介绍一下螺旋模型。螺旋模型由Barry W.Boehm于1988年提出。螺旋模型是增量迭代开发模型的一种，如图2.1.1-4所示，它兼顾了快速原型迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的系统级的软件应用。



螺旋模型。螺旋模型由Barry W.Boehm于1988年提出。螺旋模型是增量迭代开发模型的一种，如图2.1.1-4所示，它兼顾了快速原型迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的系统级的软件应用。

图2.1.1-4 螺旋模型

螺旋模型中一个典型的迭代包括以下步骤：

\1. 明确本次迭代的目标、备选方案以及应用备选方案的限制；

\2. 对备选方案进行评估，明确并解决存在的风险，建立原型；

\3. 当风险得到很好的评估与解决后，应用瀑布模型进行本次迭代的开发与测试；

\4. 对下一迭代进行计划与部署；

\5. 项目利益相关者对本次迭代的交付物进行评审，同时检查下一阶段的计划。

螺旋模型的优点是它在引入了风险驱动方法的同时，兼顾了原型开发和瀑布模型等开发模型的优点。在一定条件下，螺旋模型能够演变成其他的开发模型，例如：如果项目获得错误用户接口或无法满足性能需求等方面的风险很低，而同时它在控制成本和进度方面的风险很高的情况，螺旋模型将会演化成瀑布模型。除了这个优点以外，螺旋模型还具有以下优点：

- 可以在项目前期考虑对已经存在的软件进行重用；
- 在软件产品开发过程中考虑了软件质量目标；
- 关注于缺陷预防，并能够尽早的发现缺陷；
- 更好的控制项目活动的资源和相关成本；

螺旋模型在很多领域得到了广泛的引用，但是螺旋模型也存在一定的不足，包括：

- 过分依赖风险评估，一旦在风险管理过程中出现偏差将造成重大损失；
- 过于灵活的开发过程不适合开发者和客户之间有明确合同约定的情况；

该模型本身的文档化和推广需要大量的工作量。



# 计算机网络

## TCP/IP分层模型

## **一、TCP/IP分层模型**

TCP/IP模型分为5层：应用层、传输层、[网络层](https://so.csdn.net/so/search?q=网络层&spm=1001.2101.3001.7020)、数据链路层以及 物理层。分层就类似接口的定义，定义了每个层的行为职责。这样的分层抽象提供了更多实现的自由。

二、分层结构

1、应用层

应用层是我们经常接触使用的部分，比如常用的http协议、ftp协议（文件传输协议）、snmp（网络管理协议）、telnet （远程登录协议 ）、smtp（简单邮件传输协议）、dns（域名解析），这次主要是面向用户的交互的。这里的应用层集成了osi分层模型中 的应用、会话、表示层三层的功能。

    1

2、传输层

传输层的作用就是将应用层的数据进行传输转运。比如我们常说的tcp（可靠的传输控制协议）、udp（用户数据报协议）。传输单位为报文段。
tcp（Transmission Control Protocol）
    面向连接（先要和对方确定连接、传输结束需要断开连接，类似打电话）、复杂可靠的、有很好的重传和查错机制。一般用与高速、可靠的通信服务
udp（user datagram protocol）
    面向无连接（无需确认对方是否存在，类似寄包裹）、简单高效、没有重传机制。一般用于即时通讯、广播通信等

    1
    2
    3
    4
    5

3、网络层

网络层用来处理网络中流动的数据包，数据包为最小的传递单位，比如我们常用的ip协议、icmp协议、arp协议（通过分析ip地址得出物理mac地址）。

    1

4、数据链路层

数据链路层一般用来处理连接硬件的部分，包括控制网卡、硬件相关的设备驱动等。传输单位数据帧。

    1

5、物理层

物理层一般为负责数据传输的硬件，比如我们了解的双绞线电缆、无线、光纤等。比特流光电等信号发送接收数据。

    1

三、数据传递



# 程序设计语言

程序设计风格是指编写程序所表现出的特点、习惯和逻辑思路
形成良好的程序设计风格，应考虑如下几点：

1.源程序文档化
（1）符号名的命名
（2）程序注释
（3）视觉组织

2.数据说明的方法
（1）数据说明的次序规范化
（2）说明语句中变量安排有序化
（3）使用注释来说明复杂数据的结构

3.语句的结构
（1）在一行内只写一条语句
（2）程序编写优先考虑清晰性
（3）首先保证程序正确，在提高速度
（4）清晰第一、效率第二
（5）避免使用临时变量是程序可读性下降
（6）避免不必要的转移
（7）尽可能使用库函数
（8）避免采用复杂的条件语句
（9）尽量减少使用“否定”条件的语句
（10）要模块化，使模块的功能尽可能单一化
（11）数据结构要有利于程序的简化
（12）利用信息隐蔽，确保每一块模块的独立性
（13）从数据出发构造程序
（14）不要修补不好的程序，要重新编写

4.输入和输出
（1）检验数据合法性
（2）检查输入项各项重要组合的合理性
（3）输入格式要简单，以使得输入的步骤和操作尽可能简单
（4）输入数据时，应允许使用自由格式
（5）应允许默认值
（6）以交互式输入输出，屏幕要有提示并显示内容
（7）输入一批数据时，最好使用输入结束标识
（8）输入输出的一致性，给所有的输出加注释，设计输出报表格式

# [计组——编译程序、解释程序和汇编程序的区别](https://www.cnblogs.com/zhengmq2010/p/12620006.html)

共同点：三者都是属于要把高级语言翻译成机器语言的翻译程序，是不同的执行方式。

区别：

1.编译程序是先将高级语言程序先编译成低级语言（汇编语言或机器语言），形成一个目标文件后在进行执行操作。但是翻译完成后的目标文件（汇编语言或机器语言）并不能直接被机器识别，还需要经过微程序进一步将机器语言解释为计算机可识别的微指令。

2.汇编程序是将汇编语言翻译成机器语言。源文件与编译程序不同。

上述两种程序都分为两个阶段：编译（汇编）阶段和执行阶段。

3.解释程序是将高级语言程序边翻译边执行，不会产生目标文件（与另外两种程序的区别），只有一个阶段。

编译程序和解释程序是程序执行的两种不同执行方式。

编译程序：编译程序的功能是把用高级语言书写的源程序翻译成与之等价的目标程序。编译过程划分成词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成6个阶段。目标程序可以独立于源程序运行。（编译程序是一个语言处理程序，它可以把高级语言程序给语言翻译成某个机器的汇编语言程序或者是二进制代码程序，这个阶段叫做编译阶段。需要注意的是编译和运行是分两个阶段进行的，也就是说程序必须要全部编译完成后，才能运行。即编程方式执行程序会把源代码翻译成二进制文件的目标代码。）

 

解释程序：解释程序是一种语言处理程序，在词法、语法和语义分析方面与编译程序的工作原理基本相同，但在运行用户程序时，它是直接执行源程序或源程序的内部形式（中间代码）。因此，解释程序并不生成目标程序，这是它和编译程序的主要区别。（解释程序的工作模式是一个个的获取、分析并且去执行源程序的语句，一旦第一个语句分析结束后，源程序就会开始运行并且去生成结果，它比较适合以交互方式来进行工作的情况。即解释程序不会生成目标代码。）

编译程序不参与用户程序的运行控制，而解释程序则参与

解释程序是一种语言处理程序，在词法、语法和语义分析方面与编译程序的工作原理基本相同，但在运行用户程序时，它直接执行源程序或源程序的内部形式(中间代码)。因此，解释程序并不产生目标程序，这是它和编译程序的主要区别。

解释程序它逐条地取出源程序中的语句，边解释，边执行。编译的话就是只要编译一次，下次再执行就不用再解释了。
解释程序运行效率低，程序的运行依赖于开发环境，不能直接在操作系统下运行

常见解释程序对应的高级语言：python BASIC

常见编译程序对应的高级语言：C&C++，C#，Java





软件测试基础
软件测试的目标：
以尽可能少的时间和人力发现软件产品中尽可能多的错误。
测试用例：
测试用例是由测试数据和预期结果构成的。

如何衡量一个测试用例的好坏？

成功的测试
发现了至今为止尚未发现的错误的测试。

高效的测试
用少量的测试用例，发现被测软件尽可能多的错误

软件测试原则

所有测试的标准都是建立在用户需求之上的，测试的目的在于发现系统是否满足规定的需求；
“尽早地和不断地测试”，越早进行测试，缺陷的修复成本就会越低；
程序员应避免检查自己的程序，由第三方进行测试更客观有效；
穷举测试是不可能的；
充分注意测试中的群集现象，一段程序中一发现的错误数越多，其中存在的错误概率越大，因此对发现错误较多的程序段，应进行更深入的测试；
设计测试用例时应包括合理输入和不合理输入，以及各种边界条件、特殊情况下要制造极端状态和意外状态；
注意回归测试的关联性，往往修改一个错误会引起更多错误；
测试应从“小规模”开始，逐步转向“大规模”；
测试用例式设计出来，不是写出来的，应根据测试的目的，采用相应的方法设计测试用例，从而提高测试的效率，更多的发现错误，提高程序的可靠性；
重视并妥善保存一切测试过程文档（测试计划，测试用例，测试报告等）；
对测试错误结果一定要有一个确认的过程1. 软件测试基本原则
所有测试的标准都是建立在用户需求之上的，测试的目的在于发现系统是否满足规定的需求；
“尽早地和不断地测试”，越早进行测试，缺陷的修复成本就会越低；
程序员应避免检查自己的程序，由第三方进行测试更客观有效；
穷举测试是不可能的；
充分注意测试中的群集现象，一段程序中一发现的错误数越多，其中存在的错误概率越大，因此对发现错误较多的程序段，应进行更深入的测试；
设计测试用例时应包括合理输入和不合理输入，以及各种边界条件、特殊情况下要制造极端状态和意外状态；
注意回归测试的关联性，往往修改一个错误会引起更多错误；
测试应从“小规模”开始，逐步转向“大规模”；
测试用例式设计出来，不是写出来的，应根据测试的目的，采用相应的方法设计测试用例，从而提高测试的效率，更多的发现错误，提高程序的可靠性；
重视并妥善保存一切测试过程文档（测试计划，测试用例，测试报告等）；
对测试错误结果一定要有一个确认的过程
2. 软件测试的定义
在规定的条件下对程序进行操作，从而发现错误，对软件质量进行评估的一个过程。
使用人工和自动手段来运行或测试某个系统的过程，其目的在于它是否满足规定的需求或是弄清预期结果和实际结果之间的差别。

3. 软件测试的目的
以最少的人力，物力和时间找出软件中潜在的各种错误与缺陷，通过修正各种错误和缺陷提高软件质量，回避软件发布后由于潜在的软件缺陷和错误造成的隐患以及带来的商业风险。

单元测试（模块测试）
单元测试也称模块测试，一般是在编程阶段完成，由程序员对自己编写的模块自行测试，检查模块是否实现了详细设计说明书中规定的功能和算法。
单元测试计划应该在详细设计阶段制定
单元测试期间着重从：模块接口、局部数据结构、重要的执行通路、出错处理、边界条件这几个方面对模块进行测试。

集成测试（组装测试）
主要目标是发现模块间的接口和通信问题。
集成测试主要发现设计阶段产生的错误，通常采用黑盒测试。
集成测试计划应该在概要设计阶段制定

集成的方式可分为非增殖式和增殖式

增殖式方式
(1)自项向下的增殖方式
(2)自底向上的增殖方式：
(3)混合增殖式方式
(4)衍变的自顶向下的增殖方式
(5)自底向上-自顶向下的增草方式

确认测试
确认测试的任务是检查软件的功能、性能和其他特征是否与用户
需求一致。
它是以需求规格说明书作为依据的测试，通常采用黑盒测试。
软件确认测试首先要进行有效性测试以及软件配置审查，然后进
验收测试。
确认测试一般有三个步骤：
(1)有效性测试。
(2)软件配置审查。
(3)验收测试。
▣测试与B测试（当一个软件是尽为产品被客户使用时需要用这种测试

系统测试
系统测试的任务是把软件放在实际的硬件和网络环境中进行测试，主要测试软件的非功能需求和质量属性是否得到满足。系统测试是根据系统方案说明书来设计测试用例，通常采用通常采用黑盒测试。常见的系统测试主要有恢复测试、安全性测试、强度测试、性能测试、可常性测试和安装测试。
(1)恢复测试
(2)安全性测试
(3)强度测试
(4)性能测试
(5)可靠性测试
(6)安装测试

调试
调试的任务是根据测试时所发现的错误，我出原因和具体的位置，进行改正。
调试工作主要由程序开发人员来进行，谁开发的程序就由谁来进行调试。
常用的调试方法有以下几种：
(1)试探法。
(2)回潮法。
(3)对分查找法。
(4)归纳法。
(5)演绎法。

>软件维护
>注意：
>1、只有在软件生命周期的各个阶段都充分考虑维护问题，才能有效提高软件的可维护性。
>2、应用面向对象方法学能提高软件的可维护性。
>3、结构化设计中注意模块化、信息隐蔽、高内聚、低耦合等问愿，对于提高软件的可理解性、可测试性和可修改性也都有重要的作用。
>4、编写程序开发文档以及形成良好的编程风格，有助于提高软件的可维护性。

面向对象的基本概念
对象：对象(objoct)是系统中用来描述客观事物的一个实体，它是构成系统的个基本单位。
对象三要素：对象标识、属性和服务。
封装(encapsulation)是对象的一个重要原则。它有两层含义：
第一，对象是其全部属性和全部服务紧密结合而形成的一个不可分割的整体：
第二，对象是一个不透明的黑盒子，表示对象状态的数据和实现操作的代码都被封装在黑盒子里面。

多态性与重载：多态（即多种形式）性则是指一般类中定义的属性或服务被特殊类继承后，可以具有不同的数据类型或表现出不同的行为，通常是使用重载和改写两项技术来实现的。

方法的重载、重写与多态性（方法的重载是多态性的一种体现？NO）*

从编译和运行的角度看：
重载，是指允许存在多个同名方法，而这些方法的参数不同。 编译器根据方法不同的参数表， 对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。 它们的调用地址在编译期就绑定了。 Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。

所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定” ；

而对于多态，只有等到方法调用的那一刻， 解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定” 。
引用一句Bruce Eckel的话： “不要犯傻，如果它不是晚绑定， 它就不是多态。”

所以说，方法的重载并不是多态性的一种体现。

下面来看看多态性
多态性
如何理解多态性？

可以理解为一个事物的多种形态。
何为多态性？

对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）

    可以直接应用在抽象类和接口上

多态性的作用

提高了代码的通用性，常称作接口重用
多态性的使用

虚拟方法调用

有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。

总结：编译，看左边；运行，看右边。

查找概论
一、查找的基本概念
查找(Searching)：就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素( 或记录)。

查找表(Search Table)：是由同一类型的数据元素(或记录)构成的集合。

关键字(Key)：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在由一个学生元素构成的数据集合中，学生元素中“学号”这一数据项的值唯一地标识一名学生。

静态查找表(Static Search Table)：只作查找操作的查找表。

主要操作
查询某个“特定的”数据元素是否在查找表中。
检索某个“特定的”数据元素和各种属性。
动态查找表(Dynamic Search Table)： 在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。

主要操作
查找时插入不存在的数据元素。
查找时删除已存在的数据元素。
平均查找长度：在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度，则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为

# 网络安全

1、信息系统安全的五个基本需求：
机密性
完整性
可用性
可控性
可审计性

## 数据安全与保密

### 对称加密技术

常见对称密钥加密算法：

DES 的功能是：给定一个 64 位的明文和一个 64 位的密钥，输出一个 64 位的密文。这个密文可以用相同的密钥解密。所谓“64位的密钥”，其实里面只有54位在起作用。剩余的位可以直接丢弃，或者当作奇偶校验位。

　　虽然 DES 一次只能加密 8 个字节，但我们只需要把明文划分成每 8 个字节一组的块，就可以实现任意长度明文的加密。如果明文长度不是 8  个字节的倍数，还得进行填充。现在流行的填充方式是 PKCS7 / PKCS5，都是很简单的思路，用于把任意长度的文本填充成 8  字节的倍数长，也能方便地恢复原文，这里不再赘述。此外，独立地对每个块加密，最后直接拼起来是不行的（这种方式称为“电子密码本”，ECB  模式。它会导致明文中重复的块，加密结果也重复，这对于图片之类的数据来说几乎是致命的）。这个问题我们将在以后的博文中探讨。

　　DES 有一个非常不平凡的性质——加密与解密算法几乎一模一样。这大大简化了软件和硬件的设计。写完了加密算法，给它加上一行（倒转子密钥的顺序），就是一个解密算法了。这将给我们的编程带来帮助。

　　在这篇文章中，我们只关注一个核心任务——如何把 64 位的明文，用 64 位的密钥，加密成 64 位的密文，并执行解密。



一、3DES加密算法简析：

3DES，也称为 3DESede 或 TripleDES，是三重数据加密算法，相当于是对每个数据库应用三次DES的对称加密算法。

由于DES密码长度容易被暴力破解，所以3DES算法通过对DES算法进行改进，增加DES的密钥长度来避免类似的攻击，针对每个数据块进行三次DES加密；因此，3DES加密算法并非什么新的加密算法，是DES的一个更安全的变形，它以DES为基本模块，通过组合分组方法设计出分组加密算法。。

3DES是DES向AES过渡的加密算法，它使用2个或者3个56位的密钥对数据进行三次加密。相比DES，3DES因密钥长度变长，安全性有所提高，但其处理速度不高。因此又出现了AES加密算法，AES较于3DES速度更快、安全性更高。


二、3DES加密过程：

该算法的加解密过程分别是对明文/密文数据进行三次DES加密或解密，得到相应的密文或明文。

假设EK（）和DK（）分别表示DES的加密和解密函数，P表示明文，C表示密文，那么加解密的公式如下：

加密：C = EK3（ DK2（ EK1（P）） ），即对明文数据进行，加密 --> 解密 --> 加密的过程，最后得到密文数据；

解密：P = DK1（ EK2（ DK3（C）） ），即对密文数据进行，解密 --> 加密 --> 解密的过程，最后得到明文数据；

其中：K1表示3DES中第一个8字节密钥，K2表示第二个8字节密钥，K3表示第三个8字节密钥，K1、K2、K3决定了算法的安全性，若三个密钥互不相同，本质上就相当于用一个长为168位的密钥进行加密。多年来，它在对付强力攻击时是比较安全的。若数据对安全性要求不那么高，K1可以等于K3。在这种情况下，密钥的有效长度为112位，即K1对应KL（左8字节），K2对应KR（右8字节），K3对应KL（左8字节）。

### 非对称加密技术

### 信息摘要

### 数字签名

### 数字时间戳

### SSL安全协议