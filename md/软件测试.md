#  软件测试

20 世纪60年代以前，计算机刚刚投入实际使用，软件设计往往只是为了一个特定的应用而在指定的计算机上设计和编制，采用密切依赖于计算机的机器代码或汇编语言，软件的规模比较小，文档资料通常也不存在，很少使用系统化的开发方法，设计软件往往等同于编制程序。

60年代中期，大容量、高速度计算机的出现，使计算机的应用范围迅速扩大，软件开发急剧增长。高级语言开始出现；操作系统的发展引起了计算机应用方式的变化；大量数据处理导致第一代数据库管理系统的诞生。

软件系统的规模越来越大，复杂程度越来越高，软件可靠性问题也越来越突出。原来的个人设计、个人使用的方式不再能满足要求，迫切需要改变软件生产方式，提高软件生产率，软件危机开始爆发 。

1968年，北大西洋公约组织（NATO）在联邦德国的国际学术会议创造软件危机（Software crisis）一词。而1960年代中期开始爆发众所周知的软件危机，为了解决问题，在1968、1969年连续召开两次著名的NATO会议，并同时提出软件工程的概念。

## 软件危机与软件生存周期

### 1-软件危机

#### 软件危机的定义

在计算机软件开发和维护过程中遇到的一系列严重的问题。这些问题**主要体现在两个方面**：

1. 如何开发软件，以满足对软件日益增长的需求。
2. 如何维护数量不断膨胀的已有软件。

#### 软件结构的变化加剧了软件危机

20世纪80年代是软件迅猛发展的年代，此年代最主要的表现为：软件架构发生了变化：由传统的集中式主机[1](https://blog.csdn.net/hufuzhi1146231094/article/details/105150478#fn1)变为了现在的 客户机-服务器模式[2](https://blog.csdn.net/hufuzhi1146231094/article/details/105150478#fn2)；客户机-服务器模式有发展为 浏览器-服务器模式[3](https://blog.csdn.net/hufuzhi1146231094/article/details/105150478#fn3)。

#### 典型表现：

对软件开发成本和进度的估计常常很不准确。
用户对“已完成的”软件系统不满意的现象经常发生。
软件产品的质量往往靠不住。
软件常常是不可维护的。
软件通常没有适当的文档资料。
软件成本在计算机系统总成本中所占的比例逐年上升。
软件开发生产率提高的速度，既跟不上硬件的发展速度，也远远跟不上计算机应用迅速普及深入的趋势

#### 软件危机的原因

产生软件危机的原因： 除了软件本身的特点，其原因主要有以下几个方面：

(1) 缺乏软件开发的经验和有关软件开发数据的积累，使得开发工作计划很难制定。

(2) 软件人员与用户的交流存在障碍，使得获取的需求不充分或存在错误。

(3) 软件开发过程不规范。如，没有真正了解用户的需求就开始编程序。

(4) 随着软件规模的增大，其复杂性往往会呈指数级升高。需要很多人分工协作，不仅涉及技术问题，更重要的是必须有科学严格的管理。

(5) 缺少有效的软件评测手段，提交给用户的软件的质量不能完全保证。


### 软件生存周期过程

#### 软件生存周期

   软件生存周期(software life circle)又称软件生命期，生存期。它是指从形成软件开发概念开始，到软件投入使用，再到软件失去价值而消亡的整个过程。

#### 软件生存周期过程

   软件生存周期过程，是规定了获取，供应，开发，操作和维护软件时，要实施的过程，活动和任务（见下文）。它旨在提供一个公共的框架，方便使用“相同的语言”（可理解为相同的标准，规则）在自己的环境中创作和管理软件。

#### 国标软件生存周期过程

   国标将软件生命周期可能执行的活动分为5个基本过程，9个支持过程，7个组织过程。每个过程可能会划分出若干活动，每个活动又可能划分出若干任务。
   其中基本过程是不可或缺的，支持过程是支持基本过程的，而组织过程可以简单地理解为组织管理人财物

软件生命周期又称为软件生存周期或系统开发生命周期，是软件的产生直到报废的生命周期，周期内有问题定义、可行性分析、总体描述、系统设计、编码、调试和测试、验收与运行、维护升级到废弃等阶段，这种按时间分程的思想方法是软件工程中的一种思想原则，即按部就班、逐步推进，每个阶段都要有定义、工作、审查、形成文档以供交流或备查，以提高软件的质量。但随着新的面向对象的设计方法和技术的成熟，软件生命周期设计方法的指导意义正在逐步减少。

软件生存周期（software life cycle）又称为软件生命期，生存期。是指从形成开发软件概念起，所开发的软件使用以后，直到失去使用价值消亡为止的整个过程。一般来说，整个生存周期包括计划（定义）、开发、运行（维护）三个时期，每一个时期又划分为若干阶段。每个阶段有明确的任务，这样使规模大、结构复杂和管理复杂的软件开发变得容易控制和管理。

### 软件生存周期过程

又叫软件过程，软件生存周期中的一系列相关过程。当开发产品或构建系统时，遵循一系列可预测的步骤(路线图)是非常重要的，它有助于及时交付高质量的产品。软件开发中所遵循的路线图就是软件生存周期过程。

为了表述软件开发需要做"什么活"，引入三个概念：过程是活动的集合，活动是任务的集合，任务是把输入转换成输出的操作。

### 软件生存周期过程的重要性

软件过程提高了软件工程活动的稳定性、可控性和有组织性，如果没有过程约束，软件活动将失控并变得混乱。但是，现代软件工程方法必须是灵活的，也就是要求软件工程活动、控制以及文档的编制适合于项目团队和要开发的产品。。

## 软件缺陷

### 软件缺陷的定义

IEEE 1983 of IEEE Stardard 729中软件缺陷做了一个标准的定义：
从产品内部看，软件缺陷是软件产品开发或维护过程中所存在的错误、毛病等各种问题；从外部看，软件缺陷是系统所需要实现的某种功能的失效或违背。
因此软件缺陷就是软件产品中所存在的问题，最终表现为用户所需要的功能没有完全实现，没有满足用户的需求。

缺陷不是bug,缺陷包含bug，缺陷的范围更大。

软件缺陷是指存在与软件（程序、数据、文档）中那些不符合用户需求的问题

软件未达到需求规格说明书表明的功能
软件出现了需求规格说明书指明的范围
软件的功能超出了需求规格说明书指明的范围
软件未达到需求规格说明书虽未指明而应该达到的目标
软件测试人员认为软件难以理解、不易使用、运行速度慢、或者最终用户认为不好

### 软件缺陷的表现形式

功能、特性没有实现或部分实现
设计不合理，功能特性不明确，逻辑不清楚或存在矛盾。
产品实际结果和所期望的结果不一致。
没有达到需求规格说明书所规定的性能指标等
运行出错，包括运行中断、系统崩溃
界面混乱等。
数据不正确、精度不够、不完整或格式不统一。
用户不能接受的其他问题，如存取时间过长、界面不美观。
硬件或系统软件上存在的其他问题。

### 软件缺陷产生的原因

软件缺陷是不可避免的，造成软件缺陷产生的原因主要归纳如下：

- 需求解释或纪录错误
- 用户需求定义错误
- 设计说明存在错误
- 编码说明、程序代码有误
- 硬件或软件系统上存在错误
- 其他，如文档错误、内容不正确或拼写错误

# 软件缺陷的根源

**交流不充分**

- 客户与开发人员、开发人员与测试人员等

**软件的复杂性**

- 功能复杂、开发复杂、测试复杂

**开发人员的错误理解**

- 对需求的理解、开发压力、能力与经验

**需求的变化**

- 需求说明书、设计文档、程序的变更

**进度压力**

- 项目周期比较紧

# 软件缺陷的信息

为了便于缺陷的定位、跟踪和修改，要对所发现的缺陷，按照缺陷的严重程度、优先级、发现阶段、修复阶段、缺陷的性质、所属功能模块、系统环境等方面进行分类和统计。

**软件缺陷分类----缺陷状态**

| 编号 | 缺陷状态         | 描述                                                         |
| ---- | ---------------- | ------------------------------------------------------------ |
| 1    | 提交（Submited） | 已提交的缺陷                                                 |
| 2    | 打开（Open）     | 确认“提交的缺陷”，等待处理                                   |
| 3    | 拒绝（Rejected） | 拒绝“提交的缺陷”，不需要修复或不是缺陷、、重复缺陷、无法重现 |
| 4    | 修复（Resolved） | 已提交的缺陷                                                 |
| 5    | 关闭（Closed）   | 确认修复的缺陷，将其关闭                                     |
| 6    | 推迟（Later）    | 可在以后解决，但要确定修复日期或版本                         |

软件缺陷的分类——严重程度

| 严重等级   | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 5-Critical | 系统瘫痪、异常退出、死循环、严重的计算错误等                 |
| 4-VeryHigh | 频繁的死机，系统大部分功能不可用                             |
| 3 -High    | a.功能点没有实现，或不符合用户需求 ；b.数据丢失              |
| 2-Medium   | a.影响一个相对独立的功能 b.仅仅在特定条件上发生 c.与产品需求定义不一致 d.断断续续的出现问题 |
| 1-Low      | 表面性错误（如错别字）                                       |

**软件缺陷的分类——优先级**

| 严重等级   | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 5-Urgent   | 最高优先级。在这个错误影响下，系统几乎不可用                 |
| 4-VeryHigh | 高优先级。错误对这套系统的能力产生严重的影响                 |
| 3 -High    | 中优先级。如果这个错误存在于系统中，会制约开发和测试的活动的进行，如果先前没有修复它，那么需要在发布前修复它。 |
| 2-Medium   | 低优先级。不会延迟发布，但是会在以后修正这个错误。           |
| 1-Low      | 最低优先级。时间和资源允许时修正。                           |

**软件缺陷分类------BUG类型**

| 缺陷等级   | 内容说明                                                     | 备注                                                   |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------ |
| 系统缺陷   | 1.由于程序所引起的,异常退出 2.程序死循环 3.程序错误，不能执行正常工作或重要功能，使系统崩溃或资源不足 | 不能执行正常工作或主要功能，使系统崩溃或资源不足       |
| 数据缺陷   | 1.数据计算错误 2.数据约束错误 3.数据输入、输出错误           | 严重地影响系统要求或基本功能的实现，且没有办法更正     |
| 数据库缺陷 | 1.数据库发生思索 2.数据库的表、缺省值未加约束条件 3.数据库连接错误 4.数据库中的表有过多的空字段 |                                                        |
| 接口缺陷   | 1.数据通信错误 2.程序接口错误                                |                                                        |
| 功能缺陷   | 1.功能无法实现 2.功能实现错误                                | 严重地影响系统要求或基本功能的实现，但有合理的办法更正 |

## 软件质量模型

测度与度量：在软件质量中用于测量的一种量化的标度和方法即为测度，而名词的度量即用来指测量的结果。

1. McCail质量模型
这是由McCall和他的同事在早期提出的软件质量模型，指出了影响软件质量因素的分类，其主要集中在以下三个方面：

操作特性(产品运行)
承受可改变的能力(产品修订)
新环境适应的能力(产品变迁)

McCall认为软件的质量模型应该包括 产品的修正、产品的转移，产品的运行
而产品的修正又包括 可维护性、可测试性、灵活性等子特点。
产品的转移包括 可移植性、可复用性、互连性等。
产品的运行包括 正确性、可靠性、效率、可使用性和完整性

| 正确性   | 在预定环境下，软件满足设计规格说明及用户预期目标的程度。它要求软件本身设有错误 |
| -------- | ------------------------------------------------------------ |
| 可靠性   | 软件按照设计要求，在规定时间和条件下不出故障，持续运行的程度 |
| 效率     | 为了完成预定功能，软件系统所需的计算机资源的多少             |
| 完整性   | 为某一目的而保护数据，避免它受到偶然的或有意的破坏、改动或遗失的能力 |
| 可使用性 | 对于一个软件系统，用户学习、使用软件及为程序准备输入和解释输出所需工作量的大小 |
| 可维护性 | 为满足用户新的要求，或当环境发生了变化，或运行中发现了新的错误时，对一个已投入运行的软件进行相应诊断和修改所需工作量的大小 |
| 可测试性 | 测试软件以确保其能够执行预定功能所需工作量的大小灵活性修改或改进一个已投入运行的软件所需工作量的大小将一个软件系统从一个计算机系统或环境移植到另一个计算机 |
| 可移植性 | 系统或环境中运行时所需工作量的大小                           |
| 可复用性 | 一个软件或软件的部件）能再次用于其他应用该应用的功能与此软件或软件部件的所完成的功能有关）的程度 |
| 互连性   | 又称相互操作性。连接一个软件和其它系统所需工作量的大小。如果这个软件要联网成与其它系统通信或要把其它系统纳入到自己的控制之下，必须有系统间的接口，使之可以联结 |



1.功能性：软件所实现的功能满足用户需求的程度．功能性反映了所开发的软件满足用户称述的或蕴涵的需求的程度，即用户要求的功能是否全部实现了。


2.可靠性：在规定的时间和条件下，软件所能维持其性能水平的程度。可靠性对某些软件是重要的质量要求，它除了反映软件满足用户需求正常运行的程度，且反映了在故障发生时能继续运行的程度。


3.易使用性：对于一个软件，用户学习、操作、准备输入和理解输出时，所做努力的程度。易使用性反映了与用户的友善性，即用户在使用本软件时是否方便。


4.效率：在指定的条件下，用软件实现某种功能所需的计算机资源（包括时间）的有效程度。效率反映了在完成功能要求时，有没有浪费资源，此外"资源";这个术语有比较广泛的含义，它包括了内存、外存的使用，通道能力及处理时间。 


5.可维护性：在一个可运行软件中，为了满足用户需求、环境改变或软件错误发生时，进行相应修改所做的努力程度。可维修性反映了在用户需求改变或软件环境发生变更时，对软件系统进行相应修改的容易程度。一个易于维护的软件系统也是一个易理解、易测试和易修改的软件，以便纠正或增加新的功能，或允许在不同软件环境上进行操作。

6.可移植性：从一个计算机系统或环境转移到另一个计算机系统或环境的容易程度

软件测试的定义
软件测试的经典定义是在规定条件下对程序进行操作，以发现错误，对软件质量进行评估。因为软件是由文档、数据以及程序组成的，所以软件测试的对象也就不仅仅是程序本身，而是包括软件形成过程的文档、数据以及程序。
随着软件工程化越来越被重视以及软件规模的不断扩大，软件分析、设计的作用越来越突出，而在实践中，越来越多的错误是在刚开始的分析与设计阶段就已经存在，所以对于软件需求和设计阶段的测试就显得非常重要，这就是测试概念的扩大化以及软件全生命周期测试的理念。

软件质量有下面几个定义：

1991年，ISO 9126中定义软件质量是软件满足规定的或潜在用户需求特性的总和
1999年，ISO 14598定义软件质量是软件特性的总和，软件满足规定或潜在用户需求的能力。
一般对质量的理解是一个实体的“属性”，“属性”好就是质量好，但是这不够全面，因为“属性”是内部特性，而内部特性好不代表一定能够完成好用户的任务，所以软件质量也是关于软件特性具备“能力”的体现。
软件质量包括“内部质量”、“外部质量”、“使用质量”三个部分，也就是说，软件满足规定的或潜在的用户需求的能力要这三个方面去衡量。

软件测试与质量保证的区别
质量保证： 质量保证的工作是通过预防、检查和改进来保证软件质量。QA使用“全面质量管理”和“过程改进”的原理开展质量保证工作。所关注的是软件质量的管理与测量。虽然QA活动也有些测试活动，但所关注的主要是软件质量的检查与测量。
软件测试： 测试和质量保证同样都是与软件的开发过程紧密相关，但不同的是其并不关心软件开发过程的活动，而是对过程的产物以及开发出的软件进行剖析。测试活动必须假设软件中存在潜在问题，测试中所有的操作都是为了找出更多的问题，而不仅仅是为了验证每一件事是正确的。对测试中发现的问题的分析、追踪与回归测试也是软件测试中的重要工作，所以说软件测试是保证其质量的重要一环。

软件测试的目的
在早期，软件定义指出软件测试的目的是寻找错误，并且尽可能找出更多的错误。后面，有人提出了以下几个目的：

测试是程序的执行过程，目的在于发现错误
一个好的测试用例在于能够发现至今为止未发现的错误
一个成功的测试是发现了至今未发现的错误的测试
也有人提出软件测试不仅仅是为了发现缺陷，更重要的是要通过对软件质量的度量以提高软件的质量。
综上所述，软件测试的目的可以概括如下：软件测试是想以最少的人力、物力和时间找出软件中潜在的各种错误和缺陷，通过修正各种错误和缺陷提高软件质量，回避软件发布后由于潜在的软件缺陷和错误造成的隐患所带来的商业风险。 同时，测试是以评价一个程序或者系统属性为目标的活动，测试是对软件质量的度量与评估，以验证软件的质量满足用户的需求的程度，为用户选择和接收软件提供有力依据。
备注： 测试是为了证明软件是否可以使用，即是符合用户的需求的。

软件测试的原则
原则一： 所有的测试都应追溯到用户需求
由于软件设计和开发的目的就是使用户完成预定的任务，并满足用户的需求，而软件测试所揭示的缺陷和错误使软件达不到用户的目标，满足不了用户的需求。
原则二： 应该尽早地和不断地进行软件测试
因为软件生命周期的各个阶段都有可能产生错误，所以不能把软件测试仅仅看作为软件开发活动中的一个独立阶段的工作，而应该将其贯穿于开发的各个阶段中。同时还应尽可能早的开始测试，只要测试在生命周期中进行得足够早，就能够提高被测软件的质量，这就是预防性测试的基本原则。
原则三： 完全测试是不可能的，测试需要终止
在有限的时间和资源条件下，找出所有的软件缺陷是不可能的，主要有三个方面的原因：

、输入量太大
输出结果太多
路径组合太多
原则四： 测试不能显示软件潜在的缺陷
也就是说测试只能证明软件中存在缺陷而不能证明软件中没有缺陷。
原则五： 充分注意测试中的集群现象
经验表明，测试后程序中残存的错误数目与该程序中已发现的错误数目或检错率成正比。根据这个规律，应对错误集群的程序段进行重点测试，以提高测试效益。
原则六： 程序员应避免检查自己写的程序
这有两个原因，一个是心理原因，一个是思维定式原因，一个使人不大愿意承认自己的错误以及思维定式导致难以发现自己的错误，因此为达到测试目的，应该避免这种情况出现。
原则七： 尽量避免测试的随意性
应该从工程的角度去理解软件测试，他是有组织、有计划、有步骤的活动



软件测试的基本流程：
需求分析阶段：阅读需求，理解需求，分析需求点，参与需求评审会议。

测试计划阶段：主要任务就是编写测试计划，参考软件需求规格说明书，项目总体计划，内容包括测试范围，进度安排，人力物力分配，整体测试策略的制定。

编写测试用例：适当的了解设计，搭建测试用例框架，根据需求和设计编写测试用例。

测试执行阶段：搭建环境准备数据，执行冒烟测试（预测试）然后进入正式测试（系统测试、回归测试、交叉测试、自由测试），bug管理直到测试结束。

输出测试报告：输出测试报告，确认是否可以上线。

 软件测试基本原则
所有测试的标准都是建立在用户需求之上的，测试的目的在于发现系统是否满足规定的需求；
“尽早地和不断地测试”，越早进行测试，缺陷的修复成本就会越低；
程序员应避免检查自己的程序，由第三方进行测试更客观有效；
穷举测试是不可能的；
充分注意测试中的群集现象，一段程序中一发现的错误数越多，其中存在的错误概率越大，因此对发现错误较多的程序段，应进行更深入的测试；
设计测试用例时应包括合理输入和不合理输入，以及各种边界条件、特殊情况下要制造极端状态和意外状态；
注意回归测试的关联性，往往修改一个错误会引起更多错误；
测试应从“小规模”开始，逐步转向“大规模”；
测试用例式设计出来，不是写出来的，应根据测试的目的，采用相应的方法设计测试用例，从而提高测试的效率，更多的发现错误，提高程序的可靠性；
重视并妥善保存一切测试过程文档（测试计划，测试用例，测试报告等）；
对测试错误结果一定要有一个确认的过程
2. 软件测试的定义
在规定的条件下对程序进行操作，从而发现错误，对软件质量进行评估的一个过程。
使用人工和自动手段来运行或测试某个系统的过程，其目的在于它是否满足规定的需求或是弄清预期结果和实际结果之间的差别。

3. 软件测试的目的
以最少的人力，物力和时间找出软件中潜在的各种错误与缺陷，通过修正各种错误和缺陷提高软件质量，回避软件发布后由于潜在的软件缺陷和错误造成的隐患以及带来的商业风险。


软件质量的特性
软件的质量特性主要有六个大的特性，其中每个特性中又有一些子特性，分别如下所述。

1. 功能性
定义：软件在指定条件下使用时，满足用户明确或隐含需求的能力。
子特性：

适合性：软件为指定的任务和用户目标提供一组合适功能的能力
互操作性：软件与一个或更多的规定系统进行交互的能力。
安全性：软件保护信息和数据的能力，以使未授权的人员或系统不能阅读或修改这些信息和数据，而不拒绝受权
依从性：软件遵循与各种特性相关的标准、约定或法规以及类似规定的能力。这些标准要考虑国际标准。
准确性
2. 可靠性
定义：软件在指定条件下使用时，维护规定的性能级别的能力。
子特性：

成熟性：软件为避免由软件中错误而导致失效的能力。
容错性：在软件出现故障或者违反指定接口的情况下，软件维持规定的性能级别的能力。
易恢复性：在失效发生的情况下，软件重建规定的性能级别并恢复受直接影响的数据的能力。
3. 易用性
子特性：

易理解性：软件使用户能理解软件是否合适，以及如何能将软件用于特定的任务和使用环境的能力。
易学性：软件使用户能操作和控制它的能力。
易操作性：软件使用户能操作和控制它的能力。
4. 效率
定义：在规定条件下，相对于所用资源的数量，软件可提供适当性能的能力。
子特性：

时间特性：在规定条件下，软件执行其功能时，提供适当的响应和处理时间以及吞吐率的能力，即完成用户
资源利用性：在规定条件下，软件执行其功能时，使用合适的资源数量和类别的能力。
5. 可维护性
易分析性
易更改性
稳定性
易测试性
6. 可移植性
适应性
易安装性
一致性
易替换性



## 软件测试过程模型

V模型
RAD（Rap Application Development，快速应用开发）模型是软件开发过程中的一个重要模型，由于其模型构图形似字母V，所以又称软件测试的V模型。

阶段步骤
V模型大体可以划分为以下几个不同的阶段步骤：需求分析、概要设计、详细设计、软件编码、单元测试、集成测试、系统测试、验收测试。





缺陷及解决
缺陷：V模型仅仅把测试过程作为在需求分析、系统设计及编码之后的一个阶段，忽视了测试对需求分析,系统设计的验证，需求的满足情况一直到后期的验收测试才被验证。
解决：当一个软件开发的时候，研发人员和测试人员需要同时工作，测试在软件做需求分析的同时就会有测试用例的跟踪，这样，可以尽快找出程序错误和需求偏离，从而更高效的提高程序质量，最大可能的减少成本，同时满足用户的实际软件需求。

W模型
W模型，由Evolutif公司提出，相对于V模型，W模型增加了软件开发各阶段中同步进行的验证和确认活动。
如图所示，由两个V字型模型组成，分别代表测试与开发过程，图中明确表示出了测试与开发的并行关系。

W模型强调
测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等开发输出的文档同样要测试（这里针对设计文档，一般可以划分为需求设计文档、概要设计文档、详细设计文档和代码文档）， [1] 也就是说，测试与开发是同步进行的。
从这个角度来说，一个完整合格的测试人员对软件各方面把握程度应该比开发人员更高，一个测试人员要能胜任软件研究任何一个岗位。
W模型有利于尽早地全面的发现问题。例如，需求分析完成后，测试人员就应该参与到对需求文档的验证和确认活动中，以尽早地找出缺陷所在。同时，对需求的测试也有利于及时了解项目难度和测试风险，及早制定应对措施，这将显著减少总体测试时间，加快项目进度



局限性
在W模型中，需求、设计、编码等活动被视为串行的，同时，测试和开发活动也保持着一种线性的前后关系，上一阶段完全结束，才可正式开始下一个阶段工作。这样就无法支持迭代的开发模型。对于当前软件开发复杂多变的情况，W模型并不能解除测试管理面临的困惑。

优点
测试的活动与软件开发同步进行
测试的对象不仅仅是程序，还包括需求和设计
尽早发现软件缺陷可降低软件开发的成本
H模型
相对于V模型和W模型，H模型将测试活动完全独立出来，形成了一个完全独立的流程，将测试准备活动和测试执行活动清晰地体现出来。





优点
开发的H模型揭示了软件测试除测试执行外，还有很多工作；
软件测试完全独立，贯穿整个生命周期，且与其他流程并发进行；
软件测试活动可以尽早准备、尽早执行，具有很强的灵活性；
软件测试可以根据被测物的不同而分层次、分阶段、分次序的执行，同时也是可以被迭代的。
缺点
管理型要求高：由于模型很灵活，必须要定义清晰的规则和管理制度，否则测试过程将非常难以管理和控制；
技能要求高：H模型要求能够很好的定义每个迭代的规模，不能太大也不能太小；
测试就绪点分析困难：测试很多时候，你并不知道测试准备到什么时候是合适的，就绪点在哪里，就绪点的标准是什么，这就对后续的测试执行的启动带来很大困难；
对于整个项目组的人员要求非常高：在很好的规范制度下，大家都能高效的工作，否则容易混乱。例如：你分了一个小的迭代，但是因为人员技能不足，使得无法有效完成，那么整个项目就会受到很大的干扰。
X模型
X模型也是对V模型的改进,X模型提出针对单独的程序片段进行相互分离的编码和测试,此后通过频繁的交接,通过集成最终合成为可执行的程序。

X模型的左边描述的是针对单独程序片段所进行的相互分离的编码和测试，此后将进行频繁的交接，通过集成最终成为可执行的程序，然后再对这些可执 行程序进行测试。己通过集成测试的成品可以进行封装并提交给用户，也可以作为更大规模和范围内集成的一部分。多根并行的曲线表示变更可以在各个部分发生。 由图中可见，X模型还定位了探索性测试，这是不进行事先计划的特殊类型的测试，这一方式往往能帮助有经验的测试人员在测试计划之外发现更多的软件错误。但这样可能对测试造成人力、物力和财力的浪费，对测试员的熟练程度要求比较高。


- **静态测试**是不运行程序本身而寻找程序代码中可能存在的错误或评估程序代码的过程。 
- **动态测试**是实际运行被测程序，输入相应的测试实例，检查运行结果与预期结果的差异，判定执行结果是否符合要求，从而检验程序的正确性、可靠性和有效性，并分析系统运行效率和健壮性等性能。
- **黑盒测试**一般用来确认软件功能的正确性和可操作性,目的是检测软件的各个功能是否能得以实现,把被测试的程序当作一个黑盒,不考虑其内部结构,在知道该程序的输入和输出之间的关系或程序功能的情况下,依靠软件规格说明书来确定测试用例和推断测试结果的正确性。
- **白盒测试**根据软件内部的逻辑结构分析来进行测试,是基于代码的测试，测试人员通过阅读程序代码或者通过使用开发工具中的单步调试来判断软件的质量，一般黑盒测试由项目经理在程序员开发中来实现。
- **α测试**是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由程序员或测试员完成。
- **β测试**是软件的多个用户在一个或多个用户的实际使用环境下进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。



## 黑盒测试







黑盒测试也称功能测试或数据驱动测试，它是在已知产品所应具有的功能，通过测试来检验每个功能都是否能够正常使用。

在测试时，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，测试人员进行直接测试，检查系统功能是否按照需求规格说明书的规定正常使用、是否能适当的接收输入数据而输出正确的结果等，检查相应的文档是否采用了正确的模板、是否满足规范需求。



## “黑盒”的两种基本方法 

黑盒测试有两种基本方法，即“通过测试”和“失败测试”。

在进行“通过测试”时，实际上是确认软件能做什么，而不会考验其能力如何。软件测试员只运用最简单、直观的测试案例。

在设计和执行测试案例时，总是先进行通过测试。在进行破坏性试验之前，看一看软件基本功能是否能够实现。

在确信了软件正确运行之后，就可以采取各种手段通过搞垮软件来找出缺陷。纯粹为了破坏软件而设计和执行的测试案例，被称为失败测试或迫使出错测试。

## 3.黑盒测试的优、缺点

### （1）优点

a.比较简单，不需要了解程序内部的代码以及实现。

b.与软件内部实现无关。

c.从用户角度出发，很容易的知道用户会用到哪些功能，会遇到哪些问题。

d.在做软件自动化测试时较为方便。

e.基于软件开发文档，所以也能知道软件实现了文档中的哪些功能。

### (2)缺点

a.不可能覆盖所有代码，覆盖率较低，大概只能达到总代码量的30%。

b.自动化测试的复用性较低。

## 4.黑盒测试的测试用例设计方法

（1）等价类划分法

（2）边界值分析法

（3）错误推测法

（4）因果图法

（5）判定表

（6）功能图法

## 4.1等价类划分法

**（1）概念**

等价类划分法就是解决如何选择适当的数据子集来代表整个数据集的问题，通过降低测试的数目去实现“合理的”覆盖，覆盖了更多的可能数据，以发现更多的软件缺陷。

等价类是指某个输入域的一个特定的子集合，在该子集合各个输入数据对于揭露程序中的错误都是等效的。

**（2）等价类划分的过程**

a.分类：即将输入域按照具有相同特性并用实例来表征这个特性。

b.抽象：即在各个子类中去抽象出相同特性并用实例来表征进行分类。

**（3）等价类划分的优缺点**

a.优点：基于相对较少的测试用例，就能够进行完整覆盖，很多程度上减少了重复性。

b.缺点：缺乏特殊用例的考虑，同时需要深入的系统知识，才能选择有效的数据。

（**4）有效等价类和无效等价类**

（1）有效等价类是指输入完全满足程序输入的规格说明、有意义的输入数据所构成的集合，利用有效等价类，可以检验程序是否满足规格说明所规定的功能和性能。

（2）无效等价类和有效等价类相反，即不满足程序输入要求或者无效的输入数据构成的集合。使用无效等价类，可以测试程序/系统的容错性——对异常输入情况的处理。

**（5）不同情形的处理**

|                                                              |                           |                                               |
| ------------------------------------------------------------ | ------------------------- | --------------------------------------------- |
| 输入条件                                                     | 有效等价类                | 无效等价类                                    |
| 规定了取值范围或个数的条条件(输入条件满足小于100大于10的整数x) | 1个10<x<100               | 2个x<10和x>100                                |
| 规定了输入值的集合或者规定了“必须如何”的条件下(输入条件为x=10) | 1个x=10                   | 1个x≠10                                       |
| 规定了输入条件是一个布尔量（输入条件bool x = ture）          | 1个x = true               | 1个x = false                                  |
| 规定了一组输入数据（包括n个输入值），对每一个输入值分别处理（输入条件为x取值于一个固定枚举类型｛1,3,5,7,9｝） | n个x∈｛1,3,5,7,9｝        | 1个x不属于｛1,3,5,7,9｝的集合                 |
| 规定了输入数据必须遵守规则的情况下（输入是页面用户输入有效的Email地址的规则，必须满足几个条件，含有@，@后面格式为x，x,Email地址不带有特殊符号） | 1个满足所有条件的输入集合 | n个不满足其中任何一个条件或所有条件的输入集合 |
| 在已知的等价类中各元素在程序处理中的方式不同的情况下，则应再将等价类进一步划分为更小的等价类。 |                           |                                               |

### 4.2边界值分析法

**（1）概念**

边界值分析法就是在某个输入输入变量范围的边界上，验证系统功能是否正常运行的测试方法。

**（2）与等价划分类的区别**

a.边界值分析不是从等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。

b.边界值分析不仅考虑输入条件，还有考虑输出空间产生的测试情况。

**（3）边界值分析的处理技巧**

a.如果输入条件规定了值的范围，则取刚刚到达这个范围的边界值。

b.如果输入条件规定了值的个数，则用最大个数、最小个数、比最大个数多一个，比最小个数少一个的数等作为测试数据。

c.根据规格说明的每一个输出条件，分别使用以上两个规则。

d.如果程序的规格说明给出的输入域或输出域是有序集合（如有序表、顺序文件等），则应选取集合的第一个和最后一个元素测试数据。

**（4）边界值附近的数据确定的几种方法**

| 项   | 边界值                            | 测试用例的设计思路                                           |
| ---- | --------------------------------- | ------------------------------------------------------------ |
| 字符 | 起始-1个字符/结束+1个字符         | 假设一个文本输入区域要求允许输入1-255个字符，输入1个和255个作为有效等价类，输入0个和256个作为无效等价类，这几个数值都属于边界条件值。 |
| 数值 | 开始位-1/结束位-1                 | 例如，数据的输入域为1-999，其值最小为1，最大值为999,1000刚好在边界值附近。 |
| 方向 | 刚刚超过/刚刚低于                 |                                                              |
| 空间 | 小于空余空间一点/大于空余空间一点 | 例如，测试数据存储时，使用比最小剩余空间大一点（几KB）的文件作为最大值检验的边界条件。 |

### 4.3错误推测法

**（1）概念**

错误推测法是基于经验和直觉推测程序中所有可能存在的各种情况，从而有针对性的设计，列出测试用例的方法。

错误推测法基于这样一个思想，在某处发现了缺陷，则可能隐藏更多的缺陷。在实际操作中列出所有可能出现的错误和容易发现错误的地方，然后语句测试者经验做出选择。

**（2）优点与缺点**

优点：充分发挥人的直觉与经验，在一个测试小组中集思广益，方便实用，特别是在软件测试基础较差的情况下，很好地组织测试小组进行错误推测，是一种有效的测试方法。

使测试者能够快速且容易地切入，并且能够体会到程序的易用与否。

缺点：错误推测法不是一个系统的测试方法，所以只能用着辅助手段，即先用上述方法设计测试用例，在没有其他方法可用的情况下，再采用错误推测法，补充一些例子进行额外的测试。

难以知道测试的覆盖率，可能丢失大量未知的区域，并且这种测试行为带有主观性且难以复制。

### 4.4因果图法

**（1）概念**

因果图法借助图形，着重分析输入条件的各种组合，每种组合条件就是“因”，它必然有一个输出结果，这就是“果“。

因果图是一种形式化的图形语言，由自然写成的规范转换而成，这种形式化的语言实际上一种简化记号表示数组逻辑图，不仅能发现输入输出中的错误，还能指出程序规范中的不完成性和二义性。

因果图方法最终生成的就是判断表，它适合于检查程序输入条件的各种组合情况。

**（2）因果图介绍**

1）因果图中使用了简单的逻辑符号，以直线联接左右结点。左结点表示输入状态（原因），右结点表示状输出态（结果）。ci表示原因，通常位于图的左边;ei表示结果，通常位于图的右边。ci和ei均可取值0或1,0表示某状态不出现，1表示某状态出现。如下图：





4种符号分别表示了规格说明书中4中因果关系。如上如所示

a.恒等:若ci是1，则ei也是1；否则ei为0.

b.非：若ci是1，则ei是0；否则ei为1。

c.或：若c1或c2或c3是1，则ei是1；否则ei为0.“或可以有任意个输入”。

d.与：若c1和c2都是1，则ei为1;否则ei为0.“与可以有任意个输入”。

2）因果图概念——约束

A.输入条件的约束：

a:**E约束（异）**：a和b中至多有一个可能为1,即a和b不能同时为1.

b.**I约束（或）**：a、b和 中至少有一个必须是1，即a、b和c不能同时为0.

c.**O约束（唯一）**：a和b必须有一个，且仅有一个为1.

d. **R约束（要求）**：a是1时，b必须是1，即不可能a是1是b是0.





B.输出条件的约束：

输出条件的约束只有**M约束（强制）**，若结果a是1，则结果b强制为0.

**（3）利用因果图生成参数用例的步骤**

a.分析软件规格说明描述中，那些是原因（即输入条件或输入条件等价类），那些是结果（即输出条件），并给每个原因和结果赋予一个标识符。

b.分析软件规格说明书描述中的语义。找出原因与结果之间，原因与原因之间对应关系。根据这些关系，画出因果图。

c.由于语法和环境限制，有些原因与原因之间，原因与结果之间的组合情况不可能出现。为表明这些特殊情况，在因果图上用一些记号表明约束或限制条件。

d.把因果图转换为判定表。

**（4）因果图案例**

例：某软件规格说明书包含这样的要求：第一列字符必须是A或B，第二列字符必须是一个数字，在此情况下进行文件的修改，但如果第一列字符不正确，则给出信息L；如果第二列字符不是数字，则给出信息M。

解：

A:根据题意：原因和结果如下

原因：1——第一列字符是A; 2——第一列字符是B; 3——第二列字符是数字。

结果：21——修改文件； 22——给出信息L； 3——给出信息M。

B.对应的因果图

11为中间节点；不考虑原因1和原因2，不可能同时为1，因此在因果图上施加E约束。 





### 4.5功能图法

**（1）概念**

功能图法是用功能图FD形式化地表示程序的功能说明，并机械地生成功能图的测试用例。

功能图模型由状态迁移图和逻辑功能模型构成。状态迁移用于表示输入数据序列以及相应的输出数据，在状态迁移图中，由输入数据和当前状态绝对输出数据和后续状态。

**（2）功能图**

功能图由状态迁移图和布尔函数组成。状态迁移图用状态和迁移来描述，一个状态指出数据输入的位置（或时间），而迁移则指明状态的改变，同时要依靠判定表或因果图表示的逻辑功能。

**（3）测试用例的生成方法**

从功能图生成测试用例，得到的测试用例数是可接受的。问题的关键是如何从状态迁移图中选取测试用例，若用节点代替状态，用弧线代替迁移，则状态迁移图可转化成一个程序的控制流程图形式。问题就转化称为程序的路径测试了。

**（4）测试用例生成规则**

为了将状态迁移（测试路径）的测试用例与逻辑模型（局部测试用例）的测试用例组合起来，从功能图生成实用的测试用例，须定义以下规则：在一个结构化的状态迁移中，定义三种形式的循环结构：顺序、选择和重复。但分辨一个状态迁移中所有循环是有困难的。

（5）从功能图中生成测试用例的过程

a.生成局部测试用例：在每个状态中，从因果图生成局部测试用例，局部测试用例由原因值（输入数据）组合与对应结果值（生输出数据或状态）组成。

b.测试路径生成：利用上面的规则（三种）生成从初始状态到最后状态的测试路径。

c.测试用例合成：合成测试路径与功能图中每个状态局部测试用例，结果是初始状态到最后状态的一个状态序列，以及每个状态中输入数据与对应的输出数据的组合。

## 5.流程

### （1）测试计划

首先，根据用户需求报告中关于功能要求和性能指标的规格说明书，定义相应的测试需求报告，即制订黑盒测试的最高标准，以后所有的测试工作都将围绕着测试需求来进行，符合测试需求的[应用程序](https://baike.baidu.com/item/应用程序)即是合格的，反之即是不合格的；同时，还要适当选择测试内容，合理安排测试人员、测试时间及测试资源等。

### 

### （2）测试设计

将[测试计划](https://baike.baidu.com/item/测试计划)阶段制订的测试需求分解、细化为若干个可执行的[测试过程](https://baike.baidu.com/item/测试过程)，并为每个测试过程选择适当的[测试用例](https://baike.baidu.com/item/测试用例)（测试用例选择的好坏将直接影响到测试结果的有效性）。



### （3）测试开发

建立可重复使用的自动[测试过程](https://baike.baidu.com/item/测试过程)。



### （4）测试执行

执行测试开发阶段建立的自动[测试过程](https://baike.baidu.com/item/测试过程)，并对所发现的[缺陷](https://baike.baidu.com/item/缺陷)进行[跟踪管理](https://baike.baidu.com/item/跟踪管理)。测试执行一般由[单元测试](https://baike.baidu.com/item/单元测试)、组合测试、[集成测试](https://baike.baidu.com/item/集成测试)、系统联调及[回归测试](https://baike.baidu.com/item/回归测试)等步骤组成，测试人员应本着科学负责的态度，[一步一个脚印](https://baike.baidu.com/item/一步一个脚印)地进行测试。



### （5）测试评估

结合量化的[测试覆盖](https://baike.baidu.com/item/测试覆盖)域及[缺陷](https://baike.baidu.com/item/缺陷)跟踪报告，对于[应用软件](https://baike.baidu.com/item/应用软件)的质量和开发团队的工作进度及工作效率进行综合评价。





1、按阶段划分
①单元测试：针对程序源代码进行测试
②集成测试：针对程序接口进行测试
③系统测试：针对程序功能、非功能进行测试
©验收测试：使用不周用户(内测、公测)进行测试
2、按代码可见度划分
①黑盒测试：不关注源代码，针对程序U川功能进行测试。
②灰盒测试：针对程序部分代码进行测试（接口）
③白盒测试：针对程序源代码进行测试

## 白盒测试

### 1 白盒测试的概念

白盒测试也称结构测试或逻辑驱动测试，是一种测试用例设计方法，它从程序的控制结构导出测试用例。（测试用例由测试输入数据以及与之对应的输出结果组成。）

白盒测试使用被测单元内部如何工作的信息，允许测试人员对程序内部逻辑结构及有关信息来设计和选择测试用例，对程序的逻辑路径进行测试。基于一个应用代码的内部逻辑知识，测试是基于覆盖全部代码、分支、路径、条件。

## 2 白盒测试的主要目的

------



- 保证一个模块中的所有独立路径至少被执行一次；
- 对所有的逻辑值均需要测试真、假两个分支；
- 在上下边界及可操作范围内运行所有循环；
- 检查内部数据结构以确保其有效性。

## 3 测试覆盖标准

白盒法特点：以程序的内部逻辑为基础设计测试用例，所以又称为逻辑覆盖法。应用白盒法时，手头必须有程序的规格说明以及程序清单。

白盒法考虑的是测试用例对程序内部逻辑的覆盖程度。最彻底的白盒法是覆盖程序中的每一条路径，但是由于程序中一般含有循环，所以路径的数目极大，要执行每一条路径是不可能的，只能希望覆盖的程度尽可能高些。



程序流程图

1包括了一个执行达20次的循环。那么它所包含的不同执行路径数高达520（＝1013）条，若要对它进行穷举测试，覆盖所有的路径。假使测试程序对每一条路径进行测试需要1毫秒，同
样假定一天工作24小时，一年工作365天， 那么要想把如图所示的小程序的所有路径测试完，则需要3170年。

为了衡量测试的覆盖程度，需要建立一些标准，目前常用的一些覆盖标准从低到高分别是：

- 语句覆盖：是一个比较弱的测试标准，它的含义是：选择足够的测试用例，使得程序中每个语句至少都能被执行一次。它是最弱的逻辑覆盖，效果有限，必须与其它方法交互使用。
- 判定覆盖（也称为分支覆盖）：执行足够的测试用例，使得程序中的每一个分支至少都通过一次。判定覆盖只比语句覆盖稍强一些，但实际效果表明，只是判定覆盖，还不能保证一定能查出在判断的条件中存在的错误。因此，还需要更强的逻辑覆盖准则去检验判断内部条件。
- 条件覆盖：执行足够的测试用例，使程序中每个判断的每个条件的每个可能取值至少执行一次；条件覆盖深入到判定中的每个条件，但可能不能满足判定覆盖的要求。
- 判定/条件覆盖：执行足够的测试用例，使得判定中每个条件取到各种可能的值，并使每个判定取到各种可能的结果。判定/条件覆盖有缺陷。从表面上来看，它测试了所有条件的取值。但是事实并非如此。往往某些条件掩盖了另一些条件。会遗漏某些条件取值错误的情况。为彻底地检查所有条件的取值，需要将判定语句中给出的复合条件表达式进行分解，形成由多个基本判定嵌套的流程图。这样就可以有效地检查所有的条件是否正确了。
- 条件组合覆盖：执行足够的例子，使得每个判定中条件的各种可能组合都至少出现一次。这是一种相当强的覆盖准则，可以有效地检查各种可能的条件取值的组合是否正确。它不但可覆盖所有条件的可能取值的组合，还可覆盖所有判断的可取分支，但可能有的路径会遗漏掉。测试还不完全。

## 4 白盒测试的主要方法

1. 逻辑驱动测试

2. - 语句覆盖
   - 判定覆盖（分支覆盖）
   - 条件覆盖
   - 判定/条件覆盖
   - 条件组合覆盖

3. 基本路径测试

4. - 设计足够多的测试用例，运行所测程序，要覆盖程序中所有可能的路径。这是最强的覆盖准则。但在路径数目很大时，真正做到完全覆盖是很困难的，必须把覆盖路径数目压缩到一定限度。

### 4.1 逻辑驱动测试

#### 4.1.1 语句覆盖

程序1如下：



**什么是黑盒测试**

　　**黑盒测试**又称功能测试，是在不了解程序内部结构和内部特性的情况下进行的测试方法，黑盒测试只验证程序是否能按照需求规格说明书的规定正常使用，是否能适当的接收数据并给出适当的输出结果，如错误提示，或正确的界面等。

　　**常用黑盒测试方法**有等价类划分法、边界值分析法、正交实验法、流程分析法（场景法）、因图法、判定表法、输入域覆盖法、输出域覆盖法、猜错法（异常分析法）。

 **一、 等价类划分法**

**1.1简介**

　　等价类划分法是指将程序的输入值的集合划分为若干等价类，等价类又分为有效等价类和无效等价类，从每一类中选取少量数据进行测试。

 

**1.2构造测试用例方法**

① 根据需求文档明确需求

② 分析需求中的每一个功能数

③ 确定每一个功能有多少个输入

④ 确定每个输入有多少规则

⑤ 针对输入规则划分输入的等价类

⑥ 根据等价类设计测试用例

 

**1.3举例**

**1.在输入条件中确立一个范围时****，****可分为一个有效等价类和两个无效等价类****。**如成绩的输入，要求分数在[0,100]之间，划分等价类如下：

有效等价类：分数在[0,100]之间

无效等价类：分数小于0

分数大于100

**2.确定输入取值为n个** **值中的一个的时候，可划分为n个有效等价类和1个无效等价类，**如学历的输入，要求只能输入专科、本科、硕士、博士四种，划分等价类如下：

有效等价类：输入专科、本科、硕士、博士其中的一个

无效等价类：输入除四种学历之外的数据

**3.在输入条件是真假值时****，****可确立为一个有效等价类****（真）和一个无效等价类（假），**如一个判断题的对错，划分等价类如下：

有效等价类：对

无效等价类：错

**4.在输入数据确定了只有一种符合条件的情况下****，****可确立为一个无效等价类和多个有效等价类****，**如填空题1+1=？，划分等价类如下：

有效等价类：2

无效等价类：除2之外的数字

空

空格

汉字

字母

特殊字符

**5.在输入数据确定了个数的时候****，可分为一个有效等价类和两个无效等价类，**如一天必须上2-10节课，等价类划分如下;

有效等价类：一天上2-10节课

无效等价类：一天上课的节数小于2

一天上课的节数大于10

**6.在输入数据确定了格式的时候****，****可分为一个有效等价类和多个无效等价类****，**如设置密码时要求为字符、数字、特殊字符的组合，可划分等价类如下:

有效等价类：字符、数字、特殊字符的组合

无效等价类：纯字符

纯数字

三者两两组合

……

**7.在输入值是一个路径的时候****，****可分为一个有效等价类和多个无效等价类****，**如输入图片的路径，可划分等价类如下：

有效等价类：存在的图片路径

无效等价类：除图片之外的其他文件的路径

超出深度要求的路径

格式错误的路径（区分/和\，区分大小写的时候）

不存在的图片路径

不存在的其他文件路径

路径中存在空格或其他特殊字符

……

 

 

## **二、 边界值分析法**

**2.1简介**

　　边界值分析法是针对输入数据的边界值的测试，一般情况下与等价类划分法结合使用，根据各个等价类的边界值设计测试用例。

 

**2.2构造测试用例方法**

　　① 根据每个输入的等价类设计边界值测试用例，包括等价类的上点和离点（上点：边界值上的点；离点距离边界最近的点）

 

**2.3举例**

**1.成绩的输入****，****分为三个等价类****：**

有效等价类：输入分数在[0,100]

无效等价类：分数小于0

分数大于100

可根据这三个等价类的边界值设计测试用例如下

测试方法选择的综合策略:

1. 首先进行等价类划分，包括输入条件和输出条件的等价划分，将无限测试变成有限测试，这是减少工作量和提高测试效率最有效的方法
2. 在任何情况下，都必须使用边界值分析法，经验表明，用这种方法设计出的用例，发现程序错误的能力最强
3. 可以用错误推测法追加一些用例，这需要依靠测试工程师的经验
4. 对照程序逻辑，检查出已设计出的测试用例的逻辑覆盖程度，如果没有足够覆盖，应当再补充足够的测试用例
5. 如果程序说明中有输入条件的组合情况，则一开始就可以选用因果图或判定表驱动法设计测试用例
6. 对于参数配置类型的软件，要用正交试验法选择较少的组合方式，达到最佳效果
7. 对于业务流清晰的系统，可利用场景法贯穿整个测试案例过程，在案例中综合使用各种设计方法

#### V模型

V模型是一种软件测试过程模型，它强调了在软件开发周期中测试的重要性。这个模型将软件开发和测试分支作为翼形图放置，并在各自的侧面显示不同的阶段，如下：

```
复制代码    ┌────────────────┐                                 
    │需求分析阶段      │                                
    ├────────────────┤                               
    │确定需求        │    需求验收测试         
    ├────────────────┤                              
    │                 ├───────▶  （验证需求是否正确）   
    │设计阶段         │                                
    │                 │                             
    │    设计        │     系统验收测试                
    │                 ├───────▶（验证系统是否符合要求）   
    ├────────────────┤                               
    │编码阶段         │                                
    │                 │                                
    │   编写代码      │    集成测试                  
    │                 ├───────▶（验证集成后整体功能正确性）    
    ├────────────────┤                               
    │测试阶段         │                                
    │                 │                                
    │   测试          │     验证测试                   
    │                 └───────▶（验证最终产品是否满足用户期望）  
    └────────────────┘  
```

#### W模型

W模型是V模型的改进版本，更加注重预防性测试，通过提前测试来让错误能在较早的阶段被检测出来。该模型的测试过程也是V模型的双边镜像式，但将V字两侧展开成为W字，如下：

```
复制代码    ┌────────────────┬───────────────────┐                             
    │需求分析阶段      │   架构设计实现阶段     │                        
    ├────────────────┼───────────────────┤                       
    │确定需求        │建立软件架构和组件         │ 需求验收测试
```

软件测试过程模型是软件测试过程中的框架，为测试人员提供了一个管理软件测试活动的结构。在不同的项目和团队中，可以选择适合其需求和指定的软件测试过程模型。下面简单介绍一些常见的模型。

### V模型

V模型是一种类似瀑布模型的开发模型，将软件测试与软件开发过程联系起来。该模型包括四个阶段：需求分析、设计、编码和测试。这些阶段被列成V字形图表，测试过程始于开发过程顶部的需求分析阶段，沿着每个开发阶段向下，并在底部的集成测试结束。

V模型强调了高质量的软件设计和测试。该模型的缺点是它不能适应变化，如果需求或范围发生更改，则可能需要重新开始整个过程。

### W模型

W模型是V模型的变体，将软件测试过程细化为两个级别：系统测试和集成测试。这两个级别各自有其对应的前置阶段，如可行性研究、需求定义、系统设计和详细设计等，在两侧形成W形图表。

W模型注重系统测试之前必须进行充分的准备工作，使测试更加有效。与V模型相比，W模型更加适应需求的变化。

### H模型

H模型是一个具有双向流程的软件测试过程模型。在该模型中，软件测试过程与软件开发过程并行进行，其中软件开发过程和软件测试过程分别从软件需求阶段和测试计划阶段开始，直到实施和维护。

#### 软件测试的定义

软件测试的经典定义是在规定条件下对程序进行操作，以发现错误，对软件质量进行评估。因为软件是由文档、数据以及程序组成的，所以软件测试的对象也就不仅仅是程序本身，而是包括软件形成过程的文档、数据以及程序。
 随着软件工程化越来越被重视以及软件规模的不断扩大，软件分析、设计的作用越来越突出，而在实践中，越来越多的错误是在刚开始的分析与设计阶段就已经存在，所以对于软件需求和设计阶段的测试就显得非常重要，这就是测试概念的扩大化以及软件全生命周期测试的理念。

#### 软件质量

软件质量有下面几个定义：

1. 1991年，ISO 9126中定义软件质量是软件满足规定的或潜在用户需求特性的总和
2. 1999年，ISO 14598定义软件质量是软件特性的总和，软件满足规定或潜在用户需求的能力。

一般对质量的理解是一个实体的“属性”，“属性”好就是质量好，但是这不够全面，因为“属性”是内部特性，而内部特性好不代表一定能够完成好用户的任务，所以软件质量也是关于软件特性具备“能力”的体现。
 软件质量包括“内部质量”、“外部质量”、“使用质量”三个部分，也就是说，软件满足规定的或潜在的用户需求的能力要这三个方面去衡量。

#### 软件测试与质量保证的区别

质量保证： 质量保证的工作是通过预防、检查和改进来保证软件质量。QA使用“全面质量管理”和“过程改进”的原理开展质量保证工作。所关注的是软件质量的管理与测量。虽然QA活动也有些测试活动，但所关注的主要是软件质量的检查与测量。
 软件测试：  测试和质量保证同样都是与软件的开发过程紧密相关，但不同的是其并不关心软件开发过程的活动，而是对过程的产物以及开发出的软件进行剖析。测试活动必须假设软件中存在潜在问题，测试中所有的操作都是为了找出更多的问题，而不仅仅是为了验证每一件事是正确的。对测试中发现的问题的分析、追踪与回归测试也是软件测试中的重要工作，所以说软件测试是保证其质量的重要一环。

#### 软件测试的目的

在早期，软件定义指出软件测试的目的是寻找错误，并且尽可能找出更多的错误。后面，有人提出了以下几个目的：

1. 测试是程序的执行过程，目的在于发现错误
2. 一个好的测试用例在于能够发现至今为止未发现的错误
3. 一个成功的测试是发现了至今未发现的错误的测试

也有人提出软件测试不仅仅是为了发现缺陷，更重要的是要通过对软件质量的度量以提高软件的质量。
 综上所述，软件测试的目的可以概括如下：软件测试是想以最少的人力、物力和时间找出软件中潜在的各种错误和缺陷，通过修正各种错误和缺陷提高软件质量，回避软件发布后由于潜在的软件缺陷和错误造成的隐患所带来的商业风险。 同时，测试是以评价一个程序或者系统属性为目标的活动，测试是对软件质量的度量与评估，以验证软件的质量满足用户的需求的程度，为用户选择和接收软件提供有力依据。
 备注： 测试是为了证明软件是否可以使用，即是符合用户的需求的。

#### 软件测试的原则

原则一： 所有的测试都应追溯到用户需求
 由于软件设计和开发的目的就是使用户完成预定的任务，并满足用户的需求，而软件测试所揭示的缺陷和错误使软件达不到用户的目标，满足不了用户的需求。
 原则二： 应该尽早地和不断地进行软件测试
 因为软件生命周期的各个阶段都有可能产生错误，所以不能把软件测试仅仅看作为软件开发活动中的一个独立阶段的工作，而应该将其贯穿于开发的各个阶段中。同时还应尽可能早的开始测试，只要测试在生命周期中进行得足够早，就能够提高被测软件的质量，这就是预防性测试的基本原则。
 原则三： 完全测试是不可能的，测试需要终止
 在有限的时间和资源条件下，找出所有的软件缺陷是不可能的，主要有三个方面的原因：

1. 输入量太大
2. 输出结果太多
3. 路径组合太多

原则四： 测试不能显示软件潜在的缺陷
 也就是说测试只能证明软件中存在缺陷而不能证明软件中没有缺陷。
 原则五： 充分注意测试中的集群现象
 经验表明，测试后程序中残存的错误数目与该程序中已发现的错误数目或检错率成正比。根据这个规律，应对错误集群的程序段进行重点测试，以提高测试效益。
 原则六： 程序员应避免检查自己写的程序
 这有两个原因，一个是心理原因，一个是思维定式原因，一个使人不大愿意承认自己的错误以及思维定式导致难以发现自己的错误，因此为达到测试目的，应该避免这种情况出现。
 原则七： 尽量避免测试的随意性
 应该从工程的角度去理解软件测试，他是有组织、有计划、有步骤的活动

#### 按照开发阶段划分

按照开发阶段，软件测试可以划分为如下几个阶段：
 单元测试： 单元测试又称模块测试，是针对软件设计的最小单位——程序模块进行正确性检验的测试工作，其目的在于检查每个程序单元是否能够正确的实现详细设计说明书中的模块功能、性能、接口和设计约束等要求，发现模块内部可能存在的各种错误。
 集成测试：  集成测试也可以称为组装测试，通常在单元测试得基础上，将所有的程序模块进行有序的、递增的测试模式。集成测试是检验程序单元或部件的接口关系，逐步集成为符合概要设计要求的程序或软件，总共有两种集成方式，一种是自低向上的，一种是自顶向下的。软件集成也是一个持续的过程，在不断的集成过程中，功能的稳定性非常重要，在每个版本提交时都需要进行冒烟测试。
 确认测试： 确认测试是通过检验和提供客观证据，证实软件是否满足特定预期用途的需求。确认测试是检测与证实软件是否满足软件需求说明书中规定的要求，其一般在系统测试前面进行，时间非常短，只是看系统的功能方面是否满足要求。
 系统测试： 系统测试是为了验证和确认系统是否达到其原始目标，而对集成的硬件和软件系统进行的全面的测试，以保证软件在真实的环境中能够按照要求运行，满足用户在实际工作中的需求。
 验收测试： 按照项目任务书或者双方约定的合同等具有法律效率的文件，对整个系统进行评审，以确认是否接收该系统。

#### 按照测试实施组织划分

开发方测试： 通常也叫“验证测试”或“α测试”；开发方通过检测和提供客观证据，证实软件的实现是否满足规定需求。验证测试是在软件开发环境下，由开发者检测与证实软件的实现是否满足指定要求。这个可以和软件的系统测试同时进行。
 用户测试：  在用户的应用环境下，用户通过运行和使用软件，检测与核实软件实现是否符合自己预期的要求。通常情况用户测试不是指用户的“验收测试”，而是指用户的使用性测试，由用户提交在使用过程中发现的缺陷与bug，然后再由开发人员进行修改。与其相关的有一种测试叫“β测试”，其指的是把软件产品有计划的免费发放到市场，让用户大量使用，并评价、检查软件，以搜集软件潜在的缺陷，然后让开发人员进行修改即可。
 第三方测试： 介于开发方与用户方之间的测试组织组织的测试，其在一定程度上独立于双方，第三方测试也叫独立测试。也就是说第三方测试是由在技术、管理和财务上与开发方和用户方相对独立的组织进行的软件测试。一般情况下是在模拟用户真实环境下，进行软件确认测试。

#### 按照测试技术划分

白盒测试： 白盒测试又称结构测试。是通过对程序内部结构的分析、检测来寻找问题。白盒测试可以把程序看成装在一个透明的白盒子里，也就是清除了解程序结构和处理过程，检查是否所有的结构及路径都是正确的，检查软件内部动作是否按照设计说明的规定正常进行。
 黑盒测试： 通过软件的外部表现发现其缺陷和错误。黑盒测试法把测试对象看成一个黑盒子，完全不考虑程序内部结构和处理过程。黑盒测试是在程序的界面处进行测试，其只为验证软件程序的各项功能是否按照相关文档的要求实现。
 灰盒测试：  介于白盒和黑盒测试之间，灰盒测试关注输出对于输入的正确性；同时也关注内部表现，但这种关注不如白盒测试细致，只是通过一些表征性的现象、事件、标志来判断内部的运行状态。灰盒测试结合了以上两种测试方法的要素，考虑到了用户端、特定的系统知识和操作环境。其在系统组件的协同性环境中评价应用软件设计。
 各个阶段使用的测试方法：单元测试用白盒测试方法、集成测试用近似灰盒测试的测试方法、而系统测试和确认测试应用黑盒测试方法。

### 等价类划分

## 1. 定义（What）

等价类划分法是一种典型的，并且是最基础的黑盒测试用例设计方法。**采用等价类划分法时，完全不用考虑程序内部结构，设计测试用例的唯一依据是软件需求规格说明书。**

所谓等价类，是输入条件的一个子集合，该输入集合中的数据对于揭示程序中的错误是等价的。从每一个子集中选取少数具有代表性的数据，从而生成测试用例。

等价类又分为**有效等价类**和**无效等价类**。有效等价类代表对程序有效的输入，而无效等价类则是其他任何可能的输入（即不正确的输入值）。有效等价类和无效等价类都是使用等价类划分法设计用例时所必须的，因为**被测程序若是正确的，就应该既能接受有效的输入，也能接受无效输入的考验。**

## **2.** **为什么使用该方法？（Why）**

理想的测试，是从所有可能的输入中找出某个小的子集，并且是可能发现错误最多的子集。即：**使用最少的测试数据，达到最好的测试质量（最高性价比）。**

这个子集如何确定？可以借助测试用例的两个特性：测试用例数量达到最少；某个测试用例要能覆盖大部分其他测试用例。第二个特性就暗示我们，应该尽量将程序输入范围进行划分，将其划分为有限数量的等价类，这样就可以合理地假设测试每个等价类的代表性数据等同于测试该类的其他任何数据。这两种特性形成了称为等价类划分的黑盒测试方法。

因此，**等价类划分是黑盒测试最基本的方法**。

## **3.** **如何划分等价类？（How）**

在给定了输入或外部条件之后，等价类的划分原则如下：

- 如果输入条件规定了一个取值范围（例如，“数量可以是1到999”），那么就应确定出一个有效等价类（1<数量<999）,以及两个无效等价类（数量<1，数量>999）。
- 如果输入条件规定了取值的个数（例如，“汽车可登记一至六名车主”），那么就应确定出一个有效等价类和两个无效等价类（没有车主，或车主多于六个）。
- 如果输入条件规定了一个输入值的集合，而且有理由认为程序会对每个值进行不同处理（例如，“交通工具的类型必须是公共汽车、卡车、出租车、火车或摩托车”），那么就应为每个输入值确定一个有效等价类和一个无效等价类（例如，“拖车”）。
- 如果存在输入条件规定了“必须是”的情况，例如“标识符的第一个字符必须是字母”，那么就应确定一个有效等价类（首字符是字母）和一个无效等价类（首字符不是字母）。
- 以上是基于字面上的需求划分的等价类，而细化等价类依据的是数据在内存或数据库中存储的类型。（举例，测试加法器，两个文本框，要求输入-99~99之间的整数。整数的存储在计算机底层中会使用不同的算法，正整数和负整数算法不同。所以测试时正整数和负整数应该分开来测（一般对有效等价类数据应用，无效等价类数据一般不需要正、负分别测）。所以将有效等价类细分为：-99--（-1）负整数、0—99 正整数。

Tips：如果有任何理由可以认为程序并未等同地处理等价类中的元素，那么应该将这个等价类再划分为小一些的等价类。

> 划分等价类的标准：

- 完备测试、避免冗余;
- 划分等价类重要的是：集合的划分，划分为互不相交的一组子集，而子集的并是整个集合;
- 并是整个集合：完备性;
- 子集互不相交：保证一种形式的无冗余性;
- 同一类中标识（选择）一个测试用例，同一等价类中，往往处理相同，相同处理映射到"相同的执行路径"。

## **4.** **设计测试用例**

**Step1.确定等价类**

确定等价类是选取每一个输入条件（通常是规格说明中的一个句子或短语）并将其划分为两个或更多的组。注意，我们确定了两类等价类：**有效等价类**代表对程序的有效输入，而**无效等价类**代表的则是其他任何可能的输入条件（即不正确的输入值）。这样，我们就遵循了测试原则，即要注意无效和未预料到的输入情况。

**Step2.建立等价类表**

划分等价类后，应建立等价类表，

**Step3.生成测试用例**

现在利用等价类表来生成测试用例，其过程如下：

- 编写新的测试用例，尽可能多地覆盖那些尚未被涵盖的有效等价类，直到所有的有效等价类都被测试用例所覆盖（包含进去）。
- 编写新的用例，每次覆盖一个（**仅一个**）尚未被涵盖的无效等价类，直到所有的无效等价类都被测试用例所覆盖（包含进去）。

Tips：用测试用例每次只覆盖1个无效等价类，是因为**某些特定的输入错误检查可能会屏蔽或取代其他输入错误检查**。举例，如果规格说明规定了“请输入书籍类型（硬皮、软皮或活页）及数量（1~999）”，代表两个错误输入（书籍类型错误，数量错误）的测试用例“（XYZ，0）”，很可能不会执行对数量的检查，因为程序也许会提示“XYZ是未知的书籍类型”，就不检查输入的其余部分了。

## **5.** **使用场景**

有**数据输入（编辑框）**的地方，可以使用等价类划分法。例如用户登录、注册、新建、查询

# 3、软件质量的特性

软件的质量特性主要有六个大的特性，其中每个特性中又有一些子特性，分别如下所述。

#### 1. 功能性

定义：软件在指定条件下使用时，满足用户明确或隐含需求的能力。
 子特性：

1. 适合性：软件为指定的任务和用户目标提供一组合适功能的能力
2. 互操作性：软件与一个或更多的规定系统进行交互的能力。
3. 安全性：软件保护信息和数据的能力，以使未授权的人员或系统不能阅读或修改这些信息和数据，而不拒绝受权
4. 依从性：软件遵循与各种特性相关的标准、约定或法规以及类似规定的能力。这些标准要考虑国际标准。
5. 准确性

#### 2. 可靠性

定义：软件在指定条件下使用时，维护规定的性能级别的能力。
 子特性：

1. 成熟性：软件为避免由软件中错误而导致失效的能力。
2. 容错性：在软件出现故障或者违反指定接口的情况下，软件维持规定的性能级别的能力。
3. 易恢复性：在失效发生的情况下，软件重建规定的性能级别并恢复受直接影响的数据的能力。

#### 3. 易用性

子特性：

1. 易理解性：软件使用户能理解软件是否合适，以及如何能将软件用于特定的任务和使用环境的能力。
2. 易学性：软件使用户能操作和控制它的能力。
3. 易操作性：软件使用户能操作和控制它的能力。

#### 4. 效率

定义：在规定条件下，相对于所用资源的数量，软件可提供适当性能的能力。
 子特性：

1. 时间特性：在规定条件下，软件执行其功能时，提供适当的响应和处理时间以及吞吐率的能力，即完成用户
2. 资源利用性：在规定条件下，软件执行其功能时，使用合适的资源数量和类别的能力。

#### 5. 可维护性

1. 易分析性
2. 易更改性
3. 稳定性
4. 易测试性

#### 6. 可移植性

1. 适应性
2. 易安装性
3. 一致性
4. 易替换性

## 1.软件测试定义

- 软件测试就是在产品上线前，对软件需求、设计方案和编码实现的核查。
- 软件测试的定义

1. 1. 软件测试是为了发现错误而执行程序的过程
   2. 使用人工或自动方式来运行并测试某个系统，以此来检验系统是否满足规定的需求并确定预期结果与实际结果的差异

## 2.软件测试目的

- 软件测试的目的

1. 1. 测试是完善程序的过程，目的在于使系统更加符合用户的使用习惯，让系统在上线后带给客户极高的用户体验；
   2. 测试应致力于发现至今为止未发现的错误。

- 不同的立场催生了两种截然不同的测试目的

1. 1. 从用户的角度出发，希望通过软件测试暴露软件中隐藏的错误和缺陷并减少软件上线后的问题，使得产品更容易被接受；
   2. 从软件开发者出发，希望测试成为证明产品中不存在错误、已正确的实现用户需求的过程。

- 软件测试目的总结

1. 1. 以最少的时间和人力，系统地找出软件中潜在的各种错误和缺陷；
   2. 证明软件的功能和性能与需求说明项符合；
   3. 通过测试的结果数据为软件的可靠性分析提供分析；
   4. 重点：测试不能表明软件中不存在问题，它只能说明软件中存在问题需要改善。

## 3.软件测试规律

- 木桶原理

1. 1. 产品质量的关键因素是分析、设计和实现，测试应该是融于其中的补充检查手段，其他管理、支持等也会影响最终产品的质量；
   2. 测试是提高产品质量的必要条件，也是提高产品质量最直接、最快捷的手段，但绝不是一种根本手段；
   3. 如果将提高产品质量的砝码全部压在测试上，那将是一个恐怖而漫长的灾难；
   4. 软件开发质量越低会导致测试完成后产品残留的缺陷越多。

- 八二原则

1. 1. 在分析、设计、实现阶段的复查和测试工作能够发现和避免80%的BUG，而系统测试又能找出其余BUG的80%，最后5%的BUG可能只有在用户的大范围、长时间使用后才会暴露出来。因此测试只能保证尽可能的发现错误，无法保证能够发现所有的错误；
   2. 80%的程序缺陷常常出现在软件20%的程序控件里。

## 4.软件测试原则

- 软件测试原则

1. 1. 所有软件测试都应追溯到用户需求；
   2. 应当把“尽早地和不断地进行软件测试”作为软件测试人员的座右铭；
   3. 完全测试是不可能的，测试需要终止；

a.输入量太大；

b.输出结果太多；

c.路径组合太多

　　　　　　4. 程序员应避免检查自己的程序；

　　　　　　5. 测试无法显示软件潜在的缺陷，进行测试可以查找缺陷，但不能保证所有的缺陷都被找到，进一步测试可能会找到一些，

　　　　　　　但是只能证明软件存在错误而不能证明软件没有错误；

　　　　　　6. 充分注意测试中的群集现象；

　　　　　　　　 a.在所测程序中，若发现错误数目多，则残存错误数目也比较多，这种就是错误群集现象；

　　　　　　　　 b.经验表明，测试后程序中残存的错误数目与该程序中已发现的错误数目成正比，根据这个规律，

　　　　　　　　　 应当对错误群集的程序段进行重点测试；

　　　　　　7. 软件测试是有计划的，严格执行测试计划，排除测试的随意性；

　　　　　　8. 应当对每一个测试结果做全面检查；

　　　　　　9.妥善保存测试计划，测试用例，缺陷统计和最终测试分析报告，为维护提供方便。

**单元测试**的粒度最小，一般由开发小组采用白盒方式来测试，主要测试单元是否符合“设计”。
 集成测试界于单元测试和系统测试之间，起到“桥梁作用”，一般由开发小组采用白盒加黑盒的方式来测试，既验证“设计”，又验证“需求”。
     **系统测试**的粒度最大，一般由独立测试小组采用黑盒方式来测试，主要测试系统是否符合“需求规格说明书”。
 验收测试与系统测试相似，主要区别是测试人员不同，验收测试由用户执行。
     **黑盒测试**不考虑程序内部结构和逻辑结构，主要是用来测试系统的功能是否满足需求规格说明书。一般会有一个输入值，一个输入值，和期望值做比较。
     **白盒测试**主要应用在单元测试阶段，主要是对代码级的测试，针对程序内部逻辑结构，测试手段有：语句覆盖、判定覆盖、条件覆盖、路径覆盖、条件组合覆盖
     **集成测试**主要用来测试模块与模块之间的接口，同时还要测试一些主要业务功能。
     **系统测试**是在经过以上各阶段测试确认之后，把系统完整地模拟客户环境来进行的测试

根据需求描述用等价类划分法设计测试用例

常见的用例设计方法包括：等价类、边界值、因果图、判定表、状态迁移、场景分析法、正交实验法。下面是等价类用例设计方法。

------

### **1**为什么需要使用等价类方法 

如果我们输入的数据是一个很大范围数据时，我们测试时会出现以下问题： 

1.测试不可能全面覆盖到所有的测试数据 

2.即时有可能覆盖所有的测试数据，也可能需要花费很高的测试成本 

所以测试行业还有个问题叫测试经济学，即如何在测试与成本之间找到一个平衡点。 

为了解决上面这种当我们要输入大量数据进行测试覆盖的问题，我们研究了一种新的测试方法：**等价类** 

### **2**等价类设计用例的步骤 

等价类测试用例设计方法的步骤如下： 

***第一步***：分析需求，提取测试条件 

***第二步\***：划分等价类 

等价类可以划分为：**有效等价类**和**无效等价类** 

**有效等价类**：是指对于系统的规格说明书是合理的、有意义的输入数据构成的信息集合。利用有效等价类可以检验程序是否实现了规格说明书中所规定的功能和性能。 

**无效等价类**：是指对于系统的规格说明书是不合理的或无意义的输入数据构成的信息集合。 

 

等价类划分的原则通常包含以下几种： 

1.在输入条件规定了取值范围或值的个数时，则可以确定一个有效等价类和两个无效等价类（例如：6~16个字符，小于6和大于16就是两个无效等价类）； 

2.在输入条件规定了输入值的集合或者规定了必须在什么条件的情况下，可以确定一个有效等价类和一个无效等价类；

3.在输入条件是一个布尔值的情况下，可以确定一个有效等价类和一个无效等价类； 

4.在规定了输入数据的一组值假定N个，并且程序要对输入值分别处理的情况下，可以确定N个有效等价类和一个无效等价类； 

5.在规定了输入数据必须遵守的规则的情况下，可以确定一个有效等价类和若干个无效等价类；

6.在确定已划分的等价类中各元素在程序处理中的方式不同的情况下，应该再将该等价类进一步划分，划分为 更小的等价类。 

 

在划分等价时需要注意以下问题： 

1.所有的等价类划分完成后，不管是有效的还是无效，一定是一个全集。 

2.**不能出现交集** 

 

***第三步\***：设计测试数据来覆盖等价类 

 

设计测试数据来覆盖等价类需要注意的事项： 

1.尽量测试一个测试数据覆盖多个有效等价类 

2.一个无效测试数据只能覆盖一个无效等价类 

 

***第四步\***：设计测试用例 

1.设计测试用例时，每个测试用例尽可能多地覆盖还没有覆盖的有效值； 

2.设计测试用例时，每个测试用例只覆盖一个无效值。 

### **3.**等价类用例设计需求注意的事项 

使用等价类用例设计方法需要注意以下事项： 

1.在分析需求，提取测试条件时，需要注意是否存在隐性需求 

2.划分等价类时，一定需要注意的是全集和不存在交集 

3.有效等价类和无效等类的粒度应该根据被测试功能的优先级而定，因为在设置有效和无效等价类时，有时候可以只要一个子集就可以解决 ，但有时候可能将子集再次细分，到处细分到什么程度，这个叫我们的**测试粒度**。 

4.设计用例时为了节约测试成本，我们尽可能让一个有效测试用例去覆盖多个有效等价类 

### **4.**等价类用例设计使用的场景 

对于单个条件的，条件与条件之间没关联度的情况下，这种单个条件或者说单个文本框，我们通常会使用等价类的用例设计方法来设计用例。 

### **5.** 等价用例设计方法存在的缺点 

等价类只适合条件没有关联度的情况，所以如果一个功能有多个条件来决定，并且条件与条件之间还有相互约 束或关联时，等价类方法是无法使用的。即等价类用例设计方法是无法解决多条件且条件有联度的时的测试。