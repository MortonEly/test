# linux

## 概述

### 产生

### 特点、组成和区别

## 安装

## Xwindow图形界面和应用软件

### 桌面环境



## 命令

学习Linux终端命令的原因 Linux刚面世时并没有图形界面，所有的操作全靠命令完成，如磁盘操作、文件存取、目录操作、进程管理、文件权限设定等在职场中，大量的服务器维护工作都是在远程通过SSH客户端来完成的，并没有图形界面，所有的维护工作都需要通过命令来完成

快捷键

发大ctrl+shift+=

减小ctrl+-

| 序列 | 命令          | 对应                 | 作用                     |
|------|---------------|----------------------|--------------------------|
|      | ls            | list                 | 查看当前文件夹下的内容   |
|      | pwd           | print wrok directory | 查看当前所在文件夹       |
|      | cs[目录名]    | change directory     | 切换文件夹               |
|      | touch[文件名] | touch                | 如果文件不存在，新建文件 |
|      | mkdir[目录名] | make directory       | 创建目录                 |
|      | rm[文件名]    | remove               | 别除指定的文件名         |
|      | clear         | clear                | 清屏                     |
|      |               |                      |                          |

### 创建目录mkdir

​	-m

​	-p一次性创建多级目录

​	 -v 创建文件夹时显示信息

### 删除目录rmdir

#### 	**命令参数**

​	**-p：** 递归删除，删除目录之前是否删除父目录，如果父目录为空的话就删除

​	**-v：** 删除目录时，显示删除信息

  **--help：**  显示此帮助信息并退出

  **--version：** 输出版本信息并退出

操作

自动补全 在敲出文件/目量/命令的前几个字母之后，按下tab键

-   如果输入的没有棱义，系统会自动补全
-    如果还存在其他文件/目最/命令，再按一下tab健，系统会提示可能存在的命今

曾经使用过的命令

-   按上/下光标键可以在曾经使用过的命令之司来回切换快
-   如果想要退出选择，并且不想执行当前选中的命令，可以按ct1+c

## 文件和用户管理

## Shell的基本应用

1、首先Shell的英文含义是壳：它是相对于内核来说的，因为它是建立在内核的基础上，面向于用户的一种表现形 式，比如我们看到一个球，见到的是它的壳，而非核。Linux中的Shell,是指一个面向用户的命令接口，表现形式 就是一个可以由用户录入的界面，这个界面也可以反馈运行信息： 2、Shell在Linux中的存在形式 由于Linux不同于Windows,Linux:是内核与界面分离的，它可以脱离图形界面而单独运行，同样也可以在内核的 基础上运行图形化的桌面。。这样，在Linux系统中，就出现了两种Shell表现形式，一种是在无图形界面下的终端运行环境下的Shell,另一种是桌面上运行的光似以Window的WMS-DOS运行窗口，前者我们一般习惯性地简称为终 端，后者一般直接称为Shell

3、Shell如何执行用户的指令 1、Shell有种执行指令的方式， · 第一种方法是用户事先编写一个sb功脚本文件，内含Shell脚本，而后使用Shell程序执行该脚本，这种方式，我们习惯称为Shell编程， · 第二种形式，则是用户直接在Shel界面上执行Shel命令，由于Shells界面的关系，大家都习惯一行行的书写，很少写出成套的程序来一起执行，所以也称命令行， 总结 ·Shell只是为用户与机器之间搭建成的一个桥梁，让我们能够通过Shell来对计算机进行操作和交互，从而达到让计算机为我们服务的目的。

shell Linux系统自带的语言

分类

Linux中默认的Shell是/bin/bash,流行的shell有ash、bash、ksh、csh、sh等，不同的Shell都有自己的特点以及用途。

bash

·大多数Linux系统默认使用的Shell,bash Shell是Bourne Shell的一个免费版本，它是最早的Unix Shell,bash还有一个特点，可以通过help命令来查看帮助。包含的功能几乎可以通道help所具有的功能，所以一的shell脚本都会指定它为执行路径，

csh

C Shell使用的是类C语法，csh是具有C语言风格的一种Shel,其内部命令有52个，较为庞大。目前使用的并不多，已经被bin/tcsh所取代

ksh

Korn Shell的语法与Bourne Shel相同，同时具备了C Shell的易用特点。许多安装脚本都使用ksh,ksh有42条内部命令，与bash相比有一定的限制性。

tsch

tcsh是csh的增强版，与CShe完全兼容。

sh

nologin

zsh

### -bash的初始化

#### 1、bash环境变量文件的加载

1.  Ietc/profile
-   全局（公有）配置，不管是哪个用户，登录时都会读取该文件，

2./ect/bashrc

### 语言

机器

优点是最层，速度最快，缺点是最复杂，开发效率最低

汇编

优点是比校底层，速度最快，缺点是复杂，开发效率最低

高级编译型语言执行速度快，不依赖语言环境运行，跨平台差

解释型跨平台好，一份代码，到处使用，缺点是执行速度慢，依粮解释器运行

### shell命令提示符



## Linux下文件和目录

-   Linux文件或者目录名称最长可以有256个字符
-   ·以.开头的文件为隐照文件，需要用-a参致才能显示
-   ·代表当前目录
-   ..代表上一级目录

ls常用选项

| 参数 | 含义                                         |
|------|----------------------------------------------|
| -a   | 显示指定目录下所有子目录与文件，包括隐藏文件 |
| -l   | 以列表方式显示文件的详帽信息                 |
| -h   | 配合-l以人性化的方式显示文件大小             |

ls通配符

| 通配符 | 含义             |
|--------|------------------|
| \*     | 代表任意个数字符 |
| ？     |                  |
| []     |                  |
| [abc]  |                  |
| [a-f]  |                  |

## 用户和组

### 超级用户

-   Linux系统中的root账号通常用于系统的维护和管理，对操作系统的所有资源具有所有访问权限
-   在大多数版本的Linux中，都不推荐直接使用root账号登录系统
-   在Linux安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为标准用户·

### sudo

-   su是substitute user的缩写，表示使用另一个用户的身份
-   sudo命令用来以其他身份来执行命令，预设的身份为root
-   用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码

**若其末经授权的用户企图使用suo,则会发出警告邮件给管理员**

### 组管理命令

 提示：创建组/删除组的终端命令都需要通过sudo执行

| 序号 | 命令                 | 作用                  |
|------|----------------------|-----------------------|
|      | groupadd组名         | 添加                  |
|      | groupdel组名         | 删除                  |
|      | cat /etc/group       | 确认                  |
|      | charp组名文件/目录名 | 修改文件/目录的所属组 |
|      |                      |                       |

提示

组信息保存在/etc/group文件中 /etc目录是专门用来保存系统配置信息的目录

## vim编译器

### 简介

vim是一个全屏幕纯文本编辑器，是vi编辑器的增强版，我们主要讲解的是vim编辑器。可以利用别名计输大vi命令的时候，实际上执行vim编辑器，例如：

定义别名

alias vi='vim'

只是对当前会话有效，关掉虚拟终端再打开就无效

-   **正确的方法是修改当前用户的“用户文件夹”里面的配置文件\*.bashrc**\*
-   **在命令行中输入**vi \~/.bashrc

键盘输入 **i** （进入编辑模式）来输入添加

```linux
alias vi='vim'
1
```

-   按 **ESC** 键退出编辑模式，并输入 :wq 保存退出。

**最后在在命令行中输入**

```linux
source ~/.bashrc
```

### 使用模式

![img](https://img-blog.csdnimg.cn/20201211161814180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hcmtfbWQ=,size_16,color_FFFFFF,t_70\#pic_center)

命令

光标

#### 光标移动

上、下、左、右方向键移动光标 H左、j、k、1右移动光标

#### 文件光标

把光标移动到文件头或尾 gg 移动到文件头 G 移动到文件尾(shift+g)

#### 行光标

移动到行首或行尾 \^ 移动到行首 s 移动到行尾

:n移动到第几行 这里n是数字，准备移动到第几行，就用哪个数字

删除

#### 删除字母

x 险单个字母 nx 别除n个字母 n是数字，如果打算从光标位置刷除连续的10个字母，可以使用“10x”即可。删除字母并不符

#### 删除行

| dd  | 删除单行 |
|-----|----------|
| ndd | 删除多行 |

删除整行或多行，这是比较常用的刚除方法。这里的d快捷键既是别除，也是剪切。删除内容放入了剪切板如果不粘贴就是别除，如果粘贴就是剪切。粘贴方法如下：

编辑

输入

## Linux用户（user）和用户组（group）

### 用户/组基本概念与特性

Linux操作系统是多用户、多任务系统——即允许多个用户同时登录Linux系统并启动多个任务（有的用户是远程登陆）。用户账号和用户组是进行身份鉴定和权限控制的基础，身份鉴别的目的是规定哪些人可以进入系统，而权限控制的目的则是规定进入系统的用户能做哪些操作。

在Linux系统中，根据系统管理需要将用户分为三种类型：

1.超级用户：root是linux系统的超级用户，对系统拥有绝对权限。由于root用户权限太大，只有在进行系统管理、维护任务时使用root用户，建议日常事物处理用普通用户账号。

2.普通用户：普通用户由root用户创建，其权限受到一定限制，一般只对自己家目录拥有绝对权限。

3.虚拟用户：大多数由是在安装系统及部分应用程序时自动添加，维护系统或相应程序正常运行，其最大特点是不能登录系统。

Linux系统中可以： ·配置多个用户 配置多个用户组 ·用户可以加入多个用户组中

系统上的每个进程（正在运行的程序）都以特定用户的身份运行。 每个文件都由特定的用户拥有。 对文件和目录的访问受用户限制。 与正在运行的进程关联的用户确定该进程可访问的文件和目录。

#### 用户账户文件\*\*/etc/passwd\*\*

Linux系统中，所有用户（包括系统管理员）的账号和密码都可以在/etc/passwd和/etc/shadow这两个文件中找到，用户和密码就放在文件中。

/etc/passwd文件中的每个用户都有一个对应的记录行，记录着这个用户的一下基本属性。/etc/passwd只有系统管理员才可以修改的，该文件对所有用户可读。而/etc/shadow文件正如他的名字一样，他是passwd文件的一个影子，/etc/shadow文件中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生。但是/etc/shadow其他用户看不了，/etc/shadow文件只有系统管理员才能够进行修改和查看。

```shell
raoyi@Linux:~$ ls -al /etc/passwd /etc/shadow
-rw-r--r-- 1 root root  2469 5月  17 07:12 /etc/passwd
-rw-r----- 1 root shadow 1303 5月  17 07:12 /etc/shadow
```

上面分别列出了passwd和shadow文件的访问权限信息，其中passwd保存的是账号，shadow保存的是账号的密码等信息，下面就具体看看这两个文件的内容：

```shell
raoyi@Linux:~$ vim /etc/passwd

root:x:0:0:root:/root:/bin/bash		//第一列为账户名称
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin		//第二列为密码占位符（x表示该账户需要密码才能登录，为空时，账户无须密码即可登录）
bin:x:2:2:bin:/bin:/usr/sbin/nologin		//第三列为账户UID
sys:x:3:3:sys:/dev:/usr/sbin/nologin		//第四列为GID
sync:x:4:65534:sync:/bin:/bin/sync		//第五列为账户附加基本信息，一般存储账户名全称，联系方式等信息
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin

......
```



“用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell”

（1）用户名

用户名，就是一串代表用户身份的字符串。
前面讲过，用户名仅是为了方便用户记忆，Linux系统是通过UID来识别用户身份，分配用户权限的。/etc/passwd文件中就定义了用户名和UID之间的对应关系。
（2）密码

“x"表示此用户设有密码，但不是真正的密码，真正的密码保存在/etc/shadow文件中。为了防止密码的泄露，现Linu系统把真正的加密密码串放置在/etc/shadow文件中，此文件只有root用户可以浏览和操作，这样就最大限度地保证了密码的安全。需要注意的是，虽然"x"并不表示真正的密码，但也不能删除，如果删除了"x”，那么系统会认为这个用户没有密码，从而导致只输入用户名而不用输入密码就可以登陆。
（3）UID

UID，也就是用户ID。每个用户都有唯一的一个UID，Linux系统通过UID来识别不同的用户。实际上，UID就是一个0~2^32之间的数，不同范围的数字表示不同的用户身份。
在CentOS7的Linux系统中UID：“0”为超管的uid；
“1~999”为系统自行创建的uid，保留给系统使用；
“1000~2^32”为普通用户的uid。
（4）GID

全称“Group ID”，简称“组ID”，表示用户初始组的组ID号。
初始组，指用户登陆时就拥有这个用户组的相关权限。每个用户的初始组只能有一个，通常就是将和此用户的用户名相同的组名作为该用户的初始组。比如说，我们手工添加用户user001，在建立用户user001的同时，就会建立user001组作为user001用户的初始组。
附加组，指用户可以加入多个其他的用户组，并拥有这些组的权限。每个用户只能有一个初始组，除初始组外，用户再加入其他的用户组，这些用户组就是这个用户的附加组。附加组可以有多个，而且用户可以有这些附加组的权限。
描述性信息
这个字段没有重要的意义，只用来添加解释。
（5）主目录

用户登录后有操作权限的访问目录，称为用户的主目录。
（6）Shell

Shell就是Linux的命令解释器，是用户和Linux内核之间沟通的桥梁。Linu系统默认使用的命令解释器bash（/bin/bash），如果我把lamp用户的Shell命令解释器修改为/sbin/nologin，那么，这个用户就不能登录了。

用户名：加密的密码：UID：GID：用户名全名或描述信息：用户主目录：登录shell

如果要禁用某个用户账户，可以修改/etc/passwd文件，在该用户对应的行首添加“#”符号(linux中行首第一个字符为#，代表这一行为注释)，或者用户的shell设置为/sbin/nologin

#### 用户影子文件etc/shadow

Linux使用不可逆的加密算法（如MD5，SHA1等）来加密口令。和/etc/passwd类似，/etc/shadow文件中每条记录用冒号“:”分隔，形成9个域，格式如下所示：

　　　　　　username:password:lastchg:min:max:warn:inactive:expire:flag

其中，各个域的含义如表所示：

/etc/shadow文件中域的含义

| 域       | 含    义                                              |
| -------- | ----------------------------------------------------- |
| Username | 用户登录名                                            |
| Password | 加密的用户口令                                        |
| Lastchg  | 表示从1970年1月1日起到上次修改口令所经过的天数        |
| min表示  | 两次修改口令之间至少经过的天数                        |
| max      | 表示口令还会有效的最大天数，如果是99999则表示永不过期 |
| warn     | 表示口令失效前多少天内系统向用户发出警告              |
| inactive | 表示禁止登录前用户名还有效的天数                      |
| expire   | 表示用户被禁止登录的时间                              |
| flag     | 保留域，暂未使用                                      |

### 用户分类

> root用户（根用户、管理员账户、超级用户）  （root用户的id为0）
> 系统用户  UID:1-999(centos7版本)
> 普通用户  UID:1000+

使用id命令都可以显示当前用户的信息
使用passwd命令可以修改当前用户密码

#### **#和用户相关联的四个文件**

> /ect/passwd   #保存用户信息
> /ect/shadow   #保存用户密码
> /ect/group      #保存组信息
> /etc/gshadow    #保存组的密码信息

##### **#/etc/passwd字段的作用**

> 如：root:x:0:0:root:/root:/bin/bash
> 1.root:用户名
> 2.x:密码占位符
> 3.0:UID
> 4.0:GID
> 5.root:用户描述
> 6./root:用户主目录
> 7./bin/bash：登陆后使用的shell

##### **##/etc/shadow字段作用**

> 如：root:I.m1XoRd0W8Pc7C........Phodj8ZM1: :0:99999:7: : :
> 1 root: 用户名
> 2 I.m..M1: 被加密后的密码
> 3 最近修改密码的日期
> 4 0：密码不能更改的天数，0表示随时可以修改
> 5 99999：密码过期时间
> 6 7：密码需要更改期限到来前7天发出警告
> 7 宽限天数，密码过期几天后还能改密码
> 8 账号过期时间
> 9 保留



### 创建用户

命令：useradd
语法：useradd 用户名字
\#例子:useradd zhangsan

\#创建用户的另外一个命令
adduser 用户

#### 操作

**#创建用户执行的操作**

> 1.在/etc/passwd中添加用户信息
> 2.如果使用passwd命令创建密码，则将密码加密保存在/etc/shadow中
> 3.为用户建立一个新的家目录/home/zhangsan
> 4.将/ect/skel中的文件复制到用户的家目录中
> 5.建立一个与用户名相同的组，新建用户默认属于这个同名组

#### **#常用参数**

-c:注释
-d:指定家目录
-M:不创建用户的主目录
-s:指定shell
-u:指定用户id
-g:指定属于的组
-G:指定属于多个组
-m:创建家目录
-D:附属组
man useradd #查看更多帮助



### 查看用户

```
格式：[root@localhost~]#id 用户名
```

id











### 用户的密码文件



/etc/shadow文件，用于存储Linux系统中用户的密码信息

shadow



“用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段”
（1）用户名

同/etc/passwd文件的用户名有相同的含义。
（2）加密密码

这里保存的是由加密算法加密过的密码。（不能在文件中修改，否则系统会无法识别，使得密码失效）
（3）最后一次修改时间

此字段表示最后一次修改密码的时间，可是，为什么用户显示的是18467呢？这是因为Linux计算日期的时间是以1970年1月1日作为1不断累加得到的时间，到1971年1月1日，则为366天。这里显示18467天，也就是说，此账号在1970年1月1日之后的第18267天修改的用户密码。
（4）最小修改时间间隔

最小修改间隔时间，也就是说，该字段规定了从第3字段（最后一次修改密码的日期）起，多长时间之内不能修改密码。如果是0，则密码可以随时修改；如果是7，则代表密码修改后7天之内不能再次修改密码。
（5）密码有效期

为了强制要求用户变更密码，这个字段可以指定（最后一次更改密码）多长时间内需要再次变更密码，否则该账户密码进行过期阶段，该字段的默认值为99999。
密码需要变更前的警告天数
当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户"再过n天你的密码就要过期了，请尽快重新设置你的密码！"。
（6）账号失效时间

使用自1970年1月1日以来的总天数作为账户的失效时间。该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用！
保留
这个字段目前没有使用。

### 切换用户

su命令

语法：su \~ (用户名） \~符号是可选的，表示是否在切换用户后加载环境变量（后续讲解），建议带上 参数：用户名，表示要切换的用户，用户名也可以省略，省略表示切换到root 切换用户后，可以通过xit命令退回上一个用户，也可以使用快捷键：ctrl+d 使用普通用户，切换到其它用户需要输入密码，如切换到root用户 使用root用户切换到其它用户，无需密码，可以直接切换

sudo命令

语法：sudo 其它命令 在其它命令之前，带上Sudo,即可为这一条命令临时赋予root授权 但是并不是所有的用户，都有权利使用Sudo,我们需要为普通用户配置Sudo认证

为普通用户配置sudo认证

### 用户组管理

一.每个组有一个组ID
二.组信息保存在/etc/group中
三.每个用户拥有一个主组，同时还可以拥有多个附属组

#### 创建用户组

groupadd 用户组名

#### 删除用户组名

groupdel用户组名

### 用户管理

#### 创建

useradd [-g -d] 用户名

 选项：一g指定用户的组，不指定-g,会创建同名组并自动加入，指定g需要组已经存在，如已存在同名组，必须使用-g ​ 选项：-d指定用户HOME路径，不指定，OWE目录默认在：/home/用户名

#### 删除

userdel [-r] 用户名

 选项：-r,删除用户的HOME目录，不使用-r,删除用户时，HOME目录保留

#### 查看

id [用户名]

 参数：用户名，被查看的用户，如果不提供则查看自身

#### 修改用户所属组

usermod -aG 用户组 用户名 将指定用户加入

### linux getent

linux getent password

用户名：密码(X:用户ID:组ID:描述信息（无用）：HOME目录：执行终端(默认bash)

getent group

包含3份信息，组名称：组认证(显示为X):组ID

## Linux磁盘与文件系统管理

简介

硬盘是计算机主要存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成，碟片外覆盖有铁磁性材料，硬盘内部由磁道、柱面、扇区、磁头等部件组成

Linux系统中硬件设备相关配置文件存放在/dev/下，常见硬盘命名：/dev/hda、/dev/sda、/dev/sdb、/dev/sdc、/dev/vda。不同硬盘接口，在系统中识别的设备名称不一样。

IDE硬盘接口在Linux中设备名为/dev/hda，SAS、SCSI、SATA硬盘接口在Linux中设备名为sda，高效云盘硬盘接口会识别为/dev/vda等。

文件储存在硬盘上，硬盘的最小存储单位叫做Sector（扇区），每个Sector储存512字节。操作系统在读取硬盘的时候，不会逐个Sector的去读取，这样效率非常低，为了提升读取效率，操作系统会一次性连续读取多个Sector，即一次性读取多个Sector称为一个Block（块。

由多个Sector组成的Block是文件存取的最小单位。Block的大小常见的有1KB、2KB、4KB，Block在Linux中常设置为4KB，即连续八个Sector组成一个Block。

/boot分区Block一般为1KB，而/data/分区或者/分区的Block为4K

### 磁盘结构

#### 磁盘的物理结构

盘头：硬盘有多个盘片，每盘片2面 磁头：每面一个磁头

#### 磁盘的数据结构

扇区：磁盘上的每个磁道被分为若干个弧段，这些弧段便是硬盘的扇区，每个扇区存放512字节的数据。硬盘的第一个扇区，叫做引导扇区。 磁道：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。 柱面：在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面。

存储容量 磁盘存储容量=磁头数X磁道（柱面）数X每道扇区数X每扇区字节数

#### 磁盘接口类型

```
IDE、SATA、SCSI、SAS、光纤通道
```

IDE——并口数据线连接主板与硬盘，抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。

SATA——抗干扰性强，支持热插拔等功能，速度快，纠错能力强。

SCSI——小型机系统接口，SCSI硬盘广为工作站级个人电脑以及服务器所使用，资料传输时CPU占用率较低，转速快，支持热插拔等。

SAS——是新一代的SCSI技术，和SATA硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。

### 磁盘分区表示

#### MBR

```
MBR是主引导记录（MBR：Master Boot Record），位于硬盘的第一个物理扇区处，MBR中包含硬盘的主引导程序和硬盘分区表，分区表有4个分区记录区，每个分区记录区占16字节。
主启动记录（MBR）磁盘分区支持最大卷为2.2TB，每个磁盘最多有4个主分区，或3个主分区、1个扩展分区和在扩展分区里面分多个逻辑分区。
```

#### 磁盘分区表示

```shell
/dev/sdb5
# dev表示硬件设备文件所在目录
# sd 表示SCSI设备       hd 表示IDE设备
# 硬盘的顺序号，以字母a、b、c……表示
# 分区的顺序号，以数字1、2、3……表示。主分区从1-4，第一个逻辑分区始终从5开始。
```

### 磁盘分区结构

-   硬盘中的主分区数目只有4个
-   主分区和扩展分区的序号限制在1\~4
-   扩展分区再分为逻辑分区
-   逻辑分区的序号将始终从5开始

## LVM逻辑卷

### 概念

逻辑卷管理器（Logical Volume Manager，简称LVM）是将多个物理卷抽象成一个卷组，并在卷组的基础上进一步划分逻辑卷的一种磁盘管理方法。

LVM(Logical volume Manager)逻辑卷管理通过将底层物理硬盘抽象封装起来，以逻辑卷的形式表现给上层系统，逻辑卷的大小可以动态调整，而且不会丢失现有数据。新加入的硬盘也不会改变现有上层的逻辑卷。 作为一种动态磁盘管理机制，逻辑卷技术大大提高了磁盘管理的灵活性

LVM是逻辑盘卷管理（Logical Volume Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制，LVM是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。 LVM的工作原理其实很简单，它就是通过将底层的物理硬盘抽象的封装起来，然后以逻辑卷的方式呈现给上层应用。在传统的磁盘管理机制中，我们的上层应用是直接访问文件系统，从而对底层的物理硬盘进行读取，而在LVM中，其通过对底层的硬盘进行封装，当我们对底层的物理硬盘进行操作时，其不再是针对于分区进行操作，而是通过一个叫做逻辑卷的东西来对其进行底层的磁盘管理操作。比如说我增加一个物理硬盘，这个时候上层的服务是感觉不到的，因为呈现给上层服务的是以逻辑卷的方式。 LVM最大的特点就是可以对磁盘进行动态管理。因为逻辑卷的大小是可以动态调整的，而且不会丢失现有的数据。如果我们新增加了硬盘，其也不会改变现有上层的逻辑卷。作为一个动态磁盘管理机制，逻辑卷技术大大提高了磁盘管理的灵活性。

### 术语

1.  **PV**（Physical Volume）- 物理卷 物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘。
2.  **VG**（Volumne Group）-卷组 卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。
3.  **LV**（Logical Volume）- 逻辑卷 逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷可以属于同一个卷组，也可以属于不同的多个卷组
4.  PE\*\*（Physical Extent）：每一个物理卷被划分为称为PE(Physical Extents)的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是可配置的，默认为4MB。\*\*
5.  **LE**（Logical Extent）：逻辑卷也被划分为被称为LE(Logical Extents) 的可被寻址的基本单位。在同一个卷组中，LE的大小和PE是相同的，并且一一对应。
6.  （1）、物理存储设备（The physical media）：指系统的存储设备文件，如：/dev/hda1、/dev/sda等等。
7.  （2）、物理卷（physical volume）：简称PV，物理卷可以是整个硬盘、硬盘分区或从逻辑上与磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有与LVM相关的管理参数。
8.  （3）、卷组（Volume Group）：简称VG，可以看成单独的逻辑磁盘，建立在PV之上，一个卷组中至少 要包括一个PV，在卷组建立之后可以动态的添加PV到卷组中。卷组的名称可以自定义。
9.  （4）、PE（physical extent）物理区域：物理区域是物理卷中可用于分配的最小存储单元，物理区域的大小默认为4MB。物理区域大小一旦确定将不能更改，同一卷组中的所有物理卷的物理区域大小需要一致。

    （5） 、逻辑卷（logical volume）：简称LV，相当于物理分区。逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态的扩展或缩小空间。系统中的多个逻辑卷，可以属于同一个卷组，也可以属于不同的多个卷组。

    （6）、LE（logical extent）逻辑区域：逻辑区域是逻辑卷中可用于分配的最小存储单元，逻辑区域的大小取决于逻辑卷所在卷组中的物理区域大小。LE的大小和PE的大小一样。

    （7）、VGDA（Volume Group Descriptor Area）卷组描述符区域：和非LVM系统将包含分区信息的元数据保存在位于分区的起始位置的分区表中一样，逻辑卷以及卷组相关的元数据也是保存在位于物理卷起始处的卷组描述符区域中。VGDA包括以下内容：PV描述符、VG描述符、LV描述符和一些PE描述符。

10. 

### 建立LVM

检查分区

```
[root@localhost ~]# rpm -qa | grep lvm
```

**[root@localhost \~]\# rpm -qa \| grep lvm**

1.  建立分区

将物理磁盘设备初始化为物理卷

1.  创建物理卷

    创建卷组，并将PV加入卷组中

2.  创建卷组

    基于卷组创建逻辑卷

3.  创建逻辑卷

    为创建好的逻辑卷创建文件系统

4.  创建文件系统

    将格式化好的逻辑卷挂载使用

5.  挂载文件系统

命令

| 任务         | PV        | VG        | LV        |
|--------------|-----------|-----------|-----------|
| 创建         | pvcreate  | vgcreate  | lvcreate  |
| 删除         | pvremove  | vgremove  | lvremove  |
| 扫描列表     | pvscan    | vgscan    | lvscan    |
| 显示属性     | pvdisplay | vgdisplay | lvdisplay |
| 显示相关信息 | pvs       | vgs       | lvs       |
| 扩展         | 无        | vgextend· | Lvextend  |
| 缩减         | 无        | vgreduce  | ·Lvreduce |

物理磁盘或者磁盘分区转换为物理卷，一个或多个物理卷聚集形成一个或多个卷组，而逻辑卷就是从某个卷组里面抽象出来的一块磁盘空间。

[![z1kkin.jpg](https://s1.ax1x.com/2022/11/22/z1kkin.jpg)](https://imgse.com/i/z1kkin)

\*\*主分区：\*\*可以格式化、挂载、最多可以有四个全为主分区

\*\*扩展分区：\*\*不能格式化，只能有一个，但在扩展分区的基础上可以分为多个逻辑分区，感觉就像多个逻辑分区的总称为扩展分区。

\*\*逻辑分区：\*\*由扩展分区分来的，可以格式化、挂载等操作。

### 管理LVM

#### 查看磁盘情况

```
[root@localhost ~]# fdisk -l /dev/sda                   //查看/dev/sda磁盘的情况
```

1.  

#### 划分磁道

```
[root@localhost ~]# fdisk /dev/sda                                                 //下面是一些常用的命令
```

2

#### 创建一个扩展分区；为后面的增加逻辑分区做准备

3

#### 创建逻辑分区：

4

```
[root@localhost ~]# partprobe                                 //更新磁盘信息文件，这样我们就可以在/dev下找到磁盘文件
```

5

格式化分区

```
[root@localhost ~]# mkfs.ext4 /dev/sda5                 //格式化sda5分区，这里需要注意一下扩展分区不能格式化
```

6

挂载

```
 最后挂载在/test下：
```

### 逻辑卷的创建过程：

#### 用以上方法先创建物理分区：

6

#### 创建物理卷 （PV）

7

```shell
[root@localhost ~]# lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   20G  0 disk 
├─sda1            8:1    0  500M  0 part /boot
└─sda2            8:2    0 19.5G  0 part 
  ├─centos-root 253:0    0 17.5G  0 lvm  /
  └─centos-swap 253:1    0    2G  0 lvm  [SWAP]
sdb               8:16   0   20G  0 disk 
sr0              11:0    1    4G  0 rom 
```

#### 查看卷信息

#### 调整LVM

#### 卸载LVM

### LVM高级应用

## 管理磁盘

磁盘

类型

尺寸

接口

转速

厂商

术语

命名

分区方式

### 添加磁盘

查看信息

```shell
lsdlk
NAME(设备名)   MAJ:MIN 	rm   	SIZE RO 	type 	mountpoint
sda     	 8:0    		0 		232.9G  	0 disk 
├─sda1  	 8:1    		0  		46.6G  		0 part /
├─sda2  	 8:2    		0     		1K  	0 part 
├─sda5   	 8:5    		0   	190M  		0 	part /boot
├─sda6   	 8:6    		0   	3.7G  		0 part [SWAP]
├─sda7   	 8:7    		0  		93.1G  		0 part /data
└─sda8   	 8:8    		0  		89.2G  		0 part /personal
sr0     	 11:0    		1  		1024M  		0 rom
```

格式化

```
fdisk /.../...

m帮助
n分区
p主分区
 
```

敲击分区

格式化磁盘

```
mkdir 
```

挂载

手动

挂载使用情况

```
df -hT

mount
```

分区格式化

### 管理磁盘

#### 分区

#### 格式化

#### 挂载

### 创建分区

## 进程管理

### 简介

#### 1.1. 程序

这里的程序主要指应用程序，编写好的一段代码，这里介绍程序，主要是为了后面和进程做区分。

#### 1.2.进程

操作系统最核心的概念就是进程。其实进程简单来说就是在操作系统中运行的程序，它是操作系统资源管理的最小单位。但是进程是一个动态的实体，它是程序的一次执行过程。

进程和程序的区别在于：

```
进程是动态的，程序是静态的，进程是运行中的程序；
而程序是一些保存在硬盘上的可执行代码。
```

#### 1.3.服务

Linux中的服务一般都是常见的，一直在运行的命令，其独立于控制终端，不受前台和终端的控制，在后台周期性地执行某种任务或等待处理某些发生的事件。运行服务的进程通常被成为后台进程（守护进程）。服务由service启动，并配置。使用上通常由systemctl命令进行控制。

### PID,PPID

**1.进程标示符: 描述本进程的唯一标示符，用来区别其他进程。**

也就是进程的PID，PID是操作系统中唯一标识的进程号。

进程控制块（PCB）

前面说了一个抽象的概念需要一个具体的结构体来进行描述的。进程中的信息就被放在了一个叫做进程控制块(PCB)的结构体中。

在不同的操作系统下进程控制块的名称不同（就好像不同地方的人称呼某一个东西会有不同的叫法一样），在Linux操作系统中PCB的具体名称是：task_struct。

当一个程序被加载到内存中要开始执行的时候，操作系统同时会给该进程分配一个PCB，在Linux中就是task_struct这里面包含了所有关于进程的数据信息。所以CPU对task_struct进行管理就相当于对进程进行管理。

**3.优先级**

因为CPU资源有限，而进程却有很多个，所以需要优先级这个属性去决定了进程拿到资源的顺序。

### 4.查看进程

查看进程有三种方式：

#### 4.1.通过系统目录

第一种方式：在`/proc`这个目录下保存着所有进程的信息

proc

#### 4.2.通过ps命令

第二种方式：可以使用命令

```shell
ps aux # 查看系统中所有的进程信息
ps axj # 可以查看进程的父进程号
```

ps aux

ps axj

ps le \\ps ef(l表示显示详细信息，e表示显示所有进程)

USER：该进程是由那个用户产生的

PID：进程的ID编号

%CPU：该进程的CPU资源占用百分比

%MEM：该进程的内存资源占用百分比

VSZ：该进程的虚拟内存的大小，单位KB（将磁盘的一部分空间转为虚拟内存使用，在物理内存使用占满后才会用到）

RSS：该进程占用实际物理内存的大小，单位KB

TTY：该进程是在哪个终端上运行的（TTY1\~TTY6代表本地控制台终端。TTY1是图形终端，TTY2\~6是本地的字符界面终端。PTS/0-255代表虚拟终端。）

STAT：进程状态。R:运行、S:睡眠、T:停止、s:包含子进程、+:位于后台

1.  D: 无法中断的休眠状态 (通常 IO 的进程)
2.  R: 正在执行中
3.  S: 静止状态
4.  T: 暂停执行
5.  Z: 不存在但暂时无法消除（僵尸状态）
6.  W: 没有足够的记忆体分页可分配
7.  \<: 高优先序的行程
8.  N: 低优先序的行程
9.  L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)

START：该进程启动时间

TIME：该进程占用系统得到运算时间（注意不是系统时间）

COMMAND：产生此进程的命令名

语法

```powershell
ps [options] [--help]
```

-   ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义
-   \-A 列出所有的进程
-   \-w 显示加宽可以显示较多的资讯
-   \-au 显示较详细的资讯
-   \-aux 显示所有包含其他使用者的行程

5.创建进程-fork()

创建进程有两种创建方式：

1.使用./运行某一个可执行程序，这种是最常见的方式

2.使用系统调用接口创建进程，即使用fork()

当时用fork()函数之后，就在原来的进程中创建了一个子进程，在fork()之前的代码只被父进程执行，在fork()之后的代码有父子进程一起执行。

创建的子进程和父进程几乎一模一样，子进程和父进程的共享地址空间，子进程可以或者父进程中所有的文件，只有PID是父子进程最大的不同。

### top

**top （表示进入监听模式，输入h显示帮助，输入P以cpu进行排序，M以内存排序，N以PID排序，输入q可以退出，该命令可以动态显示进程的信息变化）**

语法

```css
top [-] [d] [p] [q] [c] [C] [S] [s] [n]
```

参数说明：

- d：指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。
- p:通过指定监控进程ID来仅仅监控某个进程的状态。
- q:该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。
- S：指定累计模式。
- s：使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。
- i：使top不显示任何闲置或者僵死进程。
- c:显示整个命令行而不只是显示命令名。

交互指令：
 交互指令是在在通过top指令进入后，输入的操作指令：

- p 以CPU使用率排序（默认）
- M 以内存使用率排序
- N 以PID排序
- q 退出

top

```
    第一行是系统信息：    
```

16:34:25 是系统时间；Up1day,14:17是系统运行时间；1 user是系统当前登录用户数量；

```
  load average:0.00,0.00,0.00是系统1分钟5分钟15分钟内的平均负载。大于1表示超负载

    第二行是进程信息：
```

Tasks:290total表示系统进程总数；running表示正在运行的进行；sleeping表示睡眠的进程

stopped便是已停止的进程；zombie表示僵尸进程（如果不是0，需要手动检查）

```
    第三行是cpu信息：
```

us表示用户占用cpu百分比；sy表示系统占用cpu百分比；ni表示改变过优先级的用户占用百分比

id表示空闲cpu占用百分比；wa表示等待输入/输出的进程占用百分比；hi表示硬件中断请求服务占用百分比；si表示软件中断请求服务占用百分比；st表示steal time虚拟时间百分比，就是当有虚拟机时虚拟cpu等待实体cpu的时间百分比

```
    第四行是物理内存信息：
```

Mem表示物理内存总量；used表示以使用的物理内存；free表示闲置物理内存；buffers表示缓冲数量

```
    第五行是交换分区（swap）信息：
```

swap表示交换分区（虚拟内存）的在大小；used表示已经使用的交互分区的大小；free表示空闲交换分区的大小；cached表示作为缓存的交换分区大小

### pstree(查看进程树，可以直观的看出父进程与子进程的关系)

pstree -p(将进程树全部展开,查看到对应的PID)

### 三、进程状态

#### 1. 查看进程的状态

可以使用`ps aux`或者`ps axj`命令查看进程的状态。

ps aux ps axj

### 四、进程优先级

#### 1.进程优先级的概念

##### 1.1.进程优先级的定义

进程优先级为进程获取cpu资源分配的先后顺序，即进程的优先权，优先级高的进程可以有优先执行的权力。

##### 1.2.进程优先级的意义

之所以会存在进程优先级，是因为cpu本身的资源分配是有限的，一个cpu一次只能run一个进程，但是一个操作系统中可能会有成千上百的进程，所以需要存在进程优先级来确定每一个进程获得cpu资源分配的顺序。

##### 2.1.查看进程优先级

在linux或者unix系统中，用ps –al或者ps -l命令则会类似输出以下几个内容：

>   UID：执行者的身份，**用户标识符**

>   PID：进程的编号

>   PPID：进程的父进程的编号

>   PRI：**进程可被执行的优先级，PRI越小代表优先级越高**

>   NI：**进程的nice值，代表进程优先级的修改数值**

ps -l

### 终止进程

1， SIGHUP， 该信号让进程⽴即关闭，然后重新读取配置⽂件之后重启

2 ，SIGINT ，程序终⽌信号，⽤户终⽌前台进程。相当去输出ctrl+c快捷键

9， SIGKILL， ⽤来⽴即结束程序的运⾏，本信号不能被阻塞、忽略。⼀般 ⽤于强制终⽌进程

使用 kill命令终止进程

18， SIGCONT， 信号可以让暂停的进程恢复执⾏，本信号不能被阻断

19， SIGSTOP ，该信号可以暂停前台进程，相当于输⼊crtl+z快捷键。本信号 不能被阻断

kill -1 32411 （重启PID为32411的进程）

kill -9 32425（强制终⽌PID为32425的进程）

kill -15 32452（相当于kill 32452，正常结束PID为32452的进程）

### .kill，killall ：终止进程

- kill [选项] 进程号（功能描述：通过进程号杀死进程 -9 强制终止）
- killall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）

## Linux文件管理

内容概述

- 文件系统目录结构

- 创建和查看文件

- 复制、转移和删除文件

- 软和硬链接

### 文件系统目录结构

  - 文件系统的目录结构
  - 文件和目录被组织成一个单根到置树结构
  - 交件系统从根目录下开始，用“/”表示
  - 根文件系统（rootfs）：root filesystem
  - 标准Unx文件系统（如ext4），文件名称大小写敏题，例如：MAll Mail
  - 以开头的文件为隐藏文件
  - 路径分隔的/
  - 文件名最长255个字节
  - 包括路径在内文件名称最长4095个字节
  - 蓝色->目录、 绿色->可执行文件 、红色->压缩文件、 浅题色->链接文件、灰色->其他文件
  - 除了斜杠和MUL所有字符都有效但使用特殊字符的目录名和文件不推荐使用，有些字符需要用引号来引用
  - 每个文件都有两类相关数据：
    元数据：metadata
    数据：data



### 1）根目录 (/) 的意义与内容：

根目录是整个文件系统中最重要的一个目录，位于Linux文件系统目录结构的顶层。因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与操作系统的开机、还原、系统修复等行为有关。

> 系统开机所需要的特定文件数据有：核心文件、开机程序、 函数库等等。如果系统出现错误，根目录也必须要包含有能够修复文件系统的程序才行。
> 因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。  如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。说白了，就是根目录和Windows的C盘一个样。因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。

因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分区则是在开机完成之后才会持续的进行挂载行为。因此根目录下与开机过程有关的目录， 就应该与根目录放在同一个分区里。这些目录分别是：/etc，/bin，/dev，/lib，/sbin。



/：根目录，位于Linux文件系统目录结构的顶层。通常根目录下只存放目录，不存放文件，/etc，/bin，/dev，/lib，/sbin应该和根目录放置在一个分区中。
/bin，/usr/bin：该目录为命令文件目录，也称为二进制目录。包含了供系统管理员及普通用户使用的重要的linux命令和二进制（可执行）文件，包含shell解释器等。
/boot： 该目录中存放系统的内核文件和引导装载程序文件，/boot/vmlinuz为linux的内核文件，以及/boot/gurb。建议单独分区，分区大小100M即可。
/dev： 设备（device）文件目录，存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备（终端、磁盘驱动器、光驱及网卡等，包括字符设备和块设备）等，常用的是挂载光驱mount /dev/cdrom/mnt。 
/etc： 系统配置文件目录，该目录存放系统的大部分配置文件和子目录，不建议在此目录下存放可执行文件。该目录下的文件由系统管理员来使用，普通用户对大部分文件有只读权限。
/home： 系统默认的用户宿主目录，新增用户账号时，用户的宿主目录都存放在此目录下，~表示当前用户的宿主目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据。
/lib，/usr/lib，/usr/local/lib：系统最基本的动态连接资源库，内核模块文件目录。几乎所有的应用程序都用到此资源库。/lib目录存放了所有重要的库文件，其他的库文件则大部分存放在/usr/lib目录下。
/lost+fount： 在EXT2或EXT3文件系统中，系统意外崩溃或意外关机时，产生的一些文件碎片放在这里。当系统重新启动时，fsck工具会检查这里，并修复已经损坏的文件系统。
/mnt，/media： mnt目录主要用来临时挂载文件系统，为某些设备提供默认挂载点。
/opt： 给主机额外安装软件所摆放的目录。
/proc： 此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间。
/root：系统管理员root的宿主目录，系统第一个启动的分区为/，所以最好将/root和/放置在一个分区下。
/sbin，/usr/sbin，/usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。与/bin不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能"查看"而不能设置和使用。
/tmp： 存放系统产生的临时文件，因此重要文件不要放在此目录下。
/srv： 服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在/srv/www内。
/usr： 应用程序存放目录，/usr/bin 存放应用程序， /usr/share 存放共享数据，/usr/lib  存放不能直接运行的，却是许多程序运行所必需的一些函数库文件，/usr/local 存放软件升级包，/usr/share/doc  系统说明文件存放目录。
/usr/share/man:  程序说明文件存放目录，使用 man ls时会查询/usr/share/man/man1/ls.1.gz的内容。建议单独分区，设置较大的磁盘空间。
/var： 放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log。
/sys：这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。



## Linux安全策略

资源分派：
Authentication：认证，验证用户身份
Authorizaion：授权，不同的用户设置不同权限
AccoutinglAudition：审计
当用户登录成功时，系统会自动分配令牌token，包括：用户标识和组成员等信息

### 用户

Unux中每个用户是通过User Id（Uib）来唯一标识的

- 管理员：root，0
- 普通用户：1-60000自动分配
  - 系统用户：1499（Centos6以前），1-999 （CentOS7以后）对守护进程获取资源进行权限分配
  - 登录用户：500+（Centos6以前），1000+（CentOs7以后）给用户进行交互式登录使用
- 

### 用户组

Linux中可以将一个或多个用户加入用户组中，用户组是通过Group I0(G10)来难一标识的。

- 管理员组：root,0

- 普通组：
  - 系统组：1-499(Cento56l以前)，1-999(Cent0S7以后)，对守护进程获取资源进行权限分配
  - 普通组：500+(CentoS6以前)，1000+(Ccnt0S7八以后)，给用户使用

### 用户和组的关系

用户的主要组（primary group)：用户必须属于一个目只有一个主姐，默认创建用户时会自动创建和用户名通名的组，做为用户的主要组，由于此组中只有一个用户，又称为私有组
用户的附加组（supplementary group:一个用户可以属于零个或多个铺助相，附属组

（1）每个账户有一个唯一的UID
（2）每个组也有一个唯一的GID
（3）多个账户可以属于同一个组

### 用户和组的配置文件

用户和组的主要配置文件

1. /etcpassword:用户及其属性信息(名称、UID、主组ID等)
2. /etc/shadow:用户密码及其相关属性
3. /etc/group:组及其属性信息
4. /etc/gshadow:组密码及其相关属性

####  group文件格式

群组名称：就是群组名称
群姐密码：通常不需要设定，密码是被记录在/etc/gshadow
GlD:就是群组的D
以当前组为附加组的用户列表（分隔符为逗号）

#### gshdow.文件格式

群组名称：就是群的名称
群组密码：
组管理员列表：组管理员的万列表，更改组密码和成员
以当前姐为附加姐的用户列表：多个用户阀用过号分隔

### 用户和组管理命令

#### 用户管理命令

- useradd
- usermod
- userdel

#### 组帐号维护命令

- groupadd
- groupmod
- groupdel



创建用户

格式

```sh
useradd [OPTIONS] USERNAME
useradd [－d home] [－s shell] [－c comment] [－m [－k template]] [－f inactive] [－e expire ] [－p passwd] [－r] name
```



常见选项

| -c            | 指定备注文件                       |
| ------------- | ---------------------------------- |
| -d            | 指定家目录                         |
| -D            | 变更默认值                         |
| -e            | 设定此帐号的使用期限               |
| -f <缓冲天数> | 指定在密码过期后多少天即关闭该帐号 |
| -g <群组>     | 指定用户所属的群组                 |
| -G <群组>     | 指定用户所属的附加群组             |
| -m            | 自动建立用户的登入目录             |
| -M            | 不要自动建立用户的登入目录         |
| -n            | 取消建立以用户名称为名的群组       |
| -r            | 建立系统帐号                       |
| -s <shell>    | 指定用户登入后所使用的shell        |
| -u <uid>      | 指定用户ID                         |

调用useradd命令时，将会使用命令行中指定的选项以及`/etc/default/useradd`文件中指定的默认值创建新用户帐户。

此文件中定义的变量会根据Linux不同的发行版可能会有差别。如果在没有任何选项的情况下使用useradd命令，则可能会在不同的Linux发行版上生成不同的结果。

useradd命令还读取[`/etc/login.defs`](http://man7.org/linux/man-pages/man5/login.defs.5.html)文件的内容。此文件包含影子密码套件的配置，例如密码过期策略，创建系统和常规用户时使用的用户ID范围等。



在没有任何选项的情况下使用最简单的形式时，useradd将使用`/etc/default/useradd`文件中指定的默认设置创建一个新的用户帐户。

该命令在`/etc/passwd`，`/etc/shadow,` `/etc/group`和`/etc/gshadow`文件加入刚创建用户配置信息。

如想要能够以新创建的用户身份登录，您需要设置用户密码。为此，请运行`passwd`命令后跟用户名：

命令创建新用户时，并没有设定用户密码，因此还无法用来登陆系统。
 passwd命令的基本格式如下：
 [root@localhost~]#passwd [选项] 用户名

```
[root@rumenz ~]# passwd rumenz
Changing password for user rumenz.
New UNIX password:
Retype new UNIX password:
passwd: all authentication tokens updated successfully.

```

> 在 Linux 中创建用户
>
> 创建新用户后，其条目将自动添加到 `/etc/passwd` 文件。该文件用于存储用户的信息。

```javascript
rumenz:x:1000:1000:rumenz:/home/rumenz:/bin/bash
```

在大多数Linux发行版中，使用`useradd`命令创建新用户帐户时，不会创建用户主目录。

> 在 Linux 中查看用户信息
>
> 上面的条目包含一组七个以冒号分隔的字段，每个字段都有自己的含义。让我们看看这些字段是什么：

- `Username`：用于登录系统的用户登录名。它的长度应该在 1 到 32 个字符之间。
- `Password`: 用户密码（或 x 字符）存储在`/etc/shadow`加密格式的文件。
- `User ID (UID)`: 每个用户必须有一个用户`ID`(`UID`) 用户识别号。默认情况下，`UID 0`为 root 用户和 UID 保留，范围从`1-99`保留用于其他预定义帐户。进一步的 UID 范围从`100-999`为系统帐户和组保留。
- `Group ID (GID)`: 主要组 ID (`GID`) 组标识号存储在`/etc/group`文件。
- `User Info`：此字段是可选的，允许您定义有关用户的额外信息。例如，用户全名。该字段由 “finger” 命令填充。
- `Home Directory`: 用户家目录的绝对位置。
- `Shell`：用户`shell`的绝对位置即`/bin/bash`



### **2. 创建不同家目录的用户**

> 默认情况下 `useradd` 命令在下面创建用户的家目录`/home`带有用户名的目录。因此，例如，我们已经在上面看到了用户的默认家目录 `rumenz`是`/home/rumenz`。
>
> 但是，此操作可以通过使用 `-d` 选项以及新家目录的位置（即`/data/projects`）。例如，以下命令将创建一个用户 `rumenz`带有家目录`/data/projects`。

```javascript
[root@rumenz ~]# useradd -d /data/projects rumenz
[root@rumenz ~]# passwd rumenz
```

> 您可以查看用户家目录和[其他与用户相关的信息]( "检查 Linux 用户信息")例如用户 ID、组 ID、shell 和注释。

```javascript
[root@rumenz ~]# cat /etc/passwd | grep rumenz

rumenz:x:1001:1001::/data/projects:/bin/bash
```







使用`-m`（`--create-home`）选项创建用户主目录`/home/username`：

```shell
seradd -m username
1
```

上面的命令创建新用户的主目录，并将文件从`/etc/skel`目录复制到用户的主目录。如果您列出文件的`/home/username`目录，你会看到初始化文件：

```shell
ls -la /home/username/
```

```shell
drwxr-xr-x 2 username username 4096 Dec 11 11:23 .
drwxr-xr-x 4 root     root     4096 Dec 11 11:23 ..
-rw-r--r-- 1 username username  220 Apr  4  2018 .bash_logout
-rw-r--r-- 1 username username 3771 Apr  4  2018 .bashrc
-rw-r--r-- 1 username username  807 Apr  4  2018 .profile
```

在主目录中，用户可以编写，编辑和删除文件和目录。

## **使用特定主目录创建用户**

如果要在其他位置创建用户的主目录，默认是 `/home` 目录，使用`d`（`--home`）选项改变这个默认值。

例如，要创建一个以`username`主目录命名的新用户，`/opt/username`您需要运行以下命令：

```shell
useradd -m -d /opt/username username
1
```

## **如何添加新用户和创建主目录**

在大多数Linux发行版中，使用`useradd`命令创建新用户帐户时，不会创建用户主目录。

使用`-m`（`--create-home`）选项创建用户主目录`/home/username`：

```
useradd -m username

```

上面的命令创建新用户的主目录，并将文件从`/etc/skel`目录复制到用户的主目录。如果您列出文件的`/home/username`目录，你会看到初始化文件：

```shell
ls -la /home/username/
```

```output
drwxr-xr-x 2 username username 4096 Dec 11 11:23 .
drwxr-xr-x 4 root     root     4096 Dec 11 11:23 ..
-rw-r--r-- 1 username username  220 Apr  4  2018 .bash_logout
-rw-r--r-- 1 username username 3771 Apr  4  2018 .bashrc
-rw-r--r-- 1 username username  807 Apr  4  2018 .profile
```

## **创建具有特定用户ID的用户**

在类Unix操作系统中，用户由唯一的UID和用户名标识。

用户标识符（UID）是Linux系统为每个用户分配的唯一正整数。UID以及其他访问控制策略用于确定用户可以对系统资源执行的操作类型。

默认情况下，在创建新用户时，系统会从`login.defs`文件中指定的用户ID范围中分配下一个可用的UID 。

使用`-u`（`--uid`）选项创建具有特定UID的用户。例如，要创建一个名为`username`UID为`1500`的新用户，请输入：

```shell
useradd -u 1500 username
```

您可以使用以下`id`命令验证用户的UID ：

```shell
id -u username
```

```output
1500
```

### id 查看用户的uid、gid、组

```sh
id 用户名
```

### 查看创建了哪些用户

```sh
cat  /etc/passwd
```

创建的用户都会存在/etc/passwd文件当中

### 删除用户

删除用户使用的为userdel命令，此命令只有root用户才能使用。
userdel命令的语法很简单，基本格式如下：
[root@localhost~]#userdel -r 用户名
-r选项表示在删除用户的同时删除用户的家目录。如果不删除用户的家文件，将会影响下一次同名用户的创建。

```sh
# 删除用户但保存用户主目录
userdel  用户名

# 用户和用户主目录，都删除
userdel -r 用户名
```

| 选项 | 功能                                       |
| ---- | ------------------------------------------ |
| -r   | 删除用户的同时，删除与用户相关的所有文件。 |
| -f   | 强制删除，即使用户当前已登录;              |

### who 查看当前用户的信息

```sh
# 显示登录用户的用户名
who am i
```

### groupadd 新增组

**1）基本语法：**

```sh
groupadd 选项 用户组名
```

组管理

当我们为用户授权的时候，如果多个用户拥有相同的权限，如果我们给用户一个一个的授权，那样很浪费时间，我们可以将这些拥有相同权限的用户加入到一个组，从而简化授权。

和用户一样，每个组都有一个 ID Group ID（GID） 来作为组的唯一标识；

root 组： 0

普通用户组：

    系统用户组 1 ~ 999 （ CentOS 6 以及之前是 1~499 ）
    登录用户组 1000+ （ CentOS 6 以及之前是 500+ ）

用户组的分类

    主要组（主组）： 一个账号必须并且只能属于一个主组，在创建用户账户时，会自动创建一个同名的组，并且这个组就是该账户的主组；
    
    附加组（附属组）： 额外的组，一个用户可以属于多个附加组；

组 user1 是用户 user1 的主组，g1 是 user1 的附加组



```bash
root@testsvra:~# id user1
uid=1001(user1) gid=1001(user1) groups=1001(user1),1002(g1)
```

组配置文件：

- /etc/group：组及其属性信息，如，组名，GID，以及组成员（组成员，只显示附加组成员，不显示主组的成员）等
- /etc/gshadow：组密码及其属性信息

group 文件格式：

```bash
root@testsvra:~# cat /etc/group | grep user1
user1:x:1001:
g1:x:1002:user1,it
```

在 **group** 文件中，每一行表示一个组，其被划分为 4 列：

- 第一列：表示组的名称；
- 第二列：表示组的密码，现在组的密码已经被保存到 /etc/gshadow 文件中了；
- 第三列：表示组的 ID；
- 第四列：表示组的成员（不包含主组成员）

gshadow 文件格式：



```bash
root@testsvra:~# cat /etc/gshadow | grep user1
user1:!::
g1:!::user1,it
```



在 **gshadow** 文件中，每一行表示一个组，其被划分为 4 列：

- 第一列：表示组的名称
- 第二列：表示组的密码（一般很少使用，所以这里的状态为 ！，如果你想为该组指定管理，那么你就需要配置组的密码.)；
- 第三列：表示组的管理员列表
- 第四列：表示组的成员（不包含主组成员）

### 创建组

我们可以通过 **groupadd** 命令来创建组

格式：

```bash
groupadd [options] GROUP
```

groupadd 的常用选项：

```bash
-g   指定 GID
-r   创建系统组
```

创建一个名为 g2 的组：

```bash
root@testsvra:~# groupadd g2
root@testsvra:~# cat /etc/group | grep g2
g2:x:1004:
```

通过 **-g** 选项，指定组的 GID

```bash
root@testsvra:~# groupadd -g 2001 g3
root@testsvra:~# cat /etc/group | grep g3
g3:x:2001:
```

通过 **-r** 选项，创建一个系统组



```bash
root@testsvra:~# groupadd -r apache
root@testsvra:~# cat /etc/group | grep apache
apache:x:998:
```



















## 权限命令

Linux文件 / 目录高级管理
Linux文件权限修改

Linux系统中的每个文件都有访问许可权限，文件的访问权限分为只读，只写和可执行三种。

只读权限表示只允许读其内容，而禁止对其做任何的更改操作。

只写权限表示允许修改文件的内容。

可执行权限表示允许将该文件作为一个程序执行。

每一文件的访问权限都有三组，每组用三位表示，分别为文件所属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。

当用ls -l或ll命令显示文件的详细信息时，最左边的一列为文件的访问权限。例如显示test文件详细信息：

图1



### Linux修改文件权限命令

`Linux`中使用`chmod`命令来修改文件权限。

文字设定法具体命令如下：

```
chmod ［who］ ［+ | - | =］ ［mode] 文件名
```

who参数如下：

    u 表示“用户（user）”，即文件或目录的所有者；
    g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户；
    o 表示“其他（others）用户”；
    a 表示“所有（all）用户”，它是系统默认值。

操作符如下：

    +：添加某个权限；
    -：取消某个权限；
    =：赋予给定权限并取消其他所有权限。

mode参数如下：

    r 可读；
    w 可写；
    x 可执行。

数字设定法具体命令如下：

```
chmod ［mode］ 文件名
```

mode为具体的数字。

首先了解用数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是u、g和o。

实例一:

将文件testFile的所有权限设置为仅读权限，可以使用如下命令：

```
chmod a=r testFile
```

图2



实例二:

将文件`testFile`的所有权限设置为可读可写，同组用户权限设置为只读，可以使用如下命令：

```
chmod u=rw,g=r testFile
```



图3



实例三:

将文件`testFile`的权限设置为所有者可读可写可执行，同组用户设置为可读可执行，其他用户设置为可读，可以使用如下命令：

```
chmod 754 testFile
```







### Linux修改所有者权限

linux使用`chmod u+/-/=`命令来设置文件所有者的权限。

具体命令如下：

```
chmod u ［+ | - | =］ ［mode] 文件名
```

操作符如下：

- +：添加某个权限；
- -：取消某个权限；
- =：赋予给定权限并取消其他所有权限。

`mode`参数如下：

- r 可读；
- w 可写；
- x 可执行。

实例一:

将文件`testFile`的所有者权限设置为仅读权限，可以使用如下命令：

```
chmod u=r testFile
```



实例二:

将目录`testDir`的所有者权限添加可执行权限，同时递归的将该目录下的所有文件或目录都添加可执行权限，可以使用如下命令：

```
chmod -R u+x testDir
```



Linux修改同组用户权限

Linux修改同组用户权限的方法与修改所有者的权限大致一样，唯一不同的点是修改同组用户权限采用chmod g而不是采用chmod u。

实例一:

将目录testDir的同组其他用户权限设置为可读可写可执行，可以使用如下命令：

chmod g=rwx testDir







实例二:

将目录`testDir`的同组其他用户权限添加可执行权限，同时递归的将该目录下的所有文件或目录都添加可执行权限，可以使用如下命令：

```
chmod -R g+x testDir
```





Linux修改其他用户权限

Linux修改其他组用户权限的方法与修改所有者的权限大致一样，唯一不同的点是修改其他组用户权限采用chmod o而不是采用chmod u。

实例一:

将目录testDir的其他组用户权限设置为可读可写可执行，可以使用如下命令：

chmod o=rwx testDir









实例二:

将目录`testDir`的其他组用户权限添加可执行权限，同时递归的将该目录下的所有文件或目录都添加可执行权限，可以使用如下命令：

```
chmod -R o+x testDir
```











Linux修改文件 / 目录所有者

Linux系统中的每个文件/目录皆有其拥有者（Owner）。我们知道只有用户登录到系统后才可以在系统上创建文件或目录，而文件/目录的所有者即是创建该文件/目录的用户。

当用ls -l或ll命令显示文件的详细信息时，第三列数据表示该文件的所有者。例如显示test文件所有者信息：

img

可以看到test文件的所有者是fzm，因为test文件是由fzm用户所创建。
Linux修改文件所有者命令

Linux中使用chown命令来修改文件所有者。

具体命令如下：

chown 用户名/用户ID 文件名

    1

执行权限：

chown必须以root权限才能执行，如果是普通用户想执行chown时，需要在命令前加sudo命令来提升权限为root权限。

实例一：

首先创建一个新用户newUser，然后将系统中已存在的文件testFile的所有者设置为newUser，可以使用如下命令:

sudo useradd newUser` `sudo chown newUser testFile



实例二：

首先查看用户`fzm`的ID是多少，然后将系统中已存在的文件`testFile`的所有者设置为`fzm`，可以使用如下命令:

```
id fzm` `sudo chown 1000 testFile
1
```



Linux修改目录所有者命令

Linux中使用chown命令来修改目录所有者。

具体命令如下：

chown 参数 用户名/用户ID 目录名

    1

常见命令参数：

    -R或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；
    --help：在线帮助；

执行权限

chown必须以root权限才能执行，如果是普通用户想执行chown时，需要在命令前加sudo命令来提升权限为root权限。

实例一：

将系统中已存在的目录testDir的所有者设置为newUser，可以使用如下命令:

sudo chown newUser testDir







可以使用`ls -l`或`ll`命令查看目录所有者是否修改成功。



实例二：

将系统中已存在的目录`Dir`以及其所有子目录和子文件的所有者设置为`newUser`，可以使用如下命令:

```
sudo chown -R newUser Dir
```





可以看到`Dir`目录下的所有子目录和子文件的所有者都已经修改成了`newUser`。

## 文件操作命令

### 文件夹

#### mkdir命令：

创建文件夹 make directories缩写 

-p 根据需要制作父目录 创建多级目录时需要用到该参数

eg：

mkdir  abc   意思是在当前文件夹下面创建 abc文件夹。

mkdir -p ./x/y/z 在当前文件夹下创建一个 "x/y/z" 多级目录

mkdir ./x/{a,b,c}dir  在当前文件夹下创建三个 x/adir x/bdir x/cdir 目录



#### rmdir命令：

删除文件夹的命令   remove empity directories缩写

 

#### rm命令：

 删除文件  remove缩写

参数：

    -r 递归 recursive的缩写
    
    -f 强制删除 force的缩写
    命令格式：rm [-rf] 目录名或文件名
    
    选项：     -f：不提示，强制删除文件或目录；
    
                    -i：删除已有文件或目录之前先询问用户；
    
                    -r,-R：递归删除，将指定目录下的所有文件与子目录一并删除；
    
                    -v：显示指令的详细执行过程。
    
        示例：
             rm -rf data/    #删除当前目录下data这个目录
             rm -rf *   #删除当前目录下所有文件和目录，慎用~
             rm -rf /*  #【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除
    
    注意：rm默认删除文件，使用-r选项可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包。

rm -rf  abc 意思是在删除当前文件夹下abc文件夹极其子文件夹和文件。 
删除文件：rm -rf  abc.txt

 命令格式：rmdir 目录名 （只能删除空目录）

```XML
示例：

    rmdir bigdata   #删除bigdata这个目录（bigdata为空的目录
```

#### du命令：

du -lh --max-depth=1 : 查看当前目录下一级子文件和子目录占用的磁盘容量。

#### mv命令

**剪切（移动）目录**

> 命令：mv 目录名称 目录的新位置
>
> ```XML
> 示例：
> 
> mv  data  Data/     # 将data这个目录移动到Data这个目录下
> ```

注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作

#### cp命令

拷贝（复制）目录或文件**

> 命令格式：cp [-选项] 目录名称 目录拷贝的目标位置
>
> 选项： -r：表示递归复制
>
> ```XML
> 示例：
> 
> 
> 
> 	cp  -r  apps/  Data/ 	#将apps目录复制到Data目录下
> 
> 注意：cp命令在复制目录是一定加上选项参数“-r”，cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不用写-r递归。
> ```

#### find命令

命令格式：find 目录 参数 文件名称或者目录名

```XML
示例：

	find  /tmp  -name  'a*'  查找/tmp目录下的所有以a开头的目录或文件
```

#### **cd命令：**  

切换路径 change directory缩写

    绝对路径：绝对路径一定是由根目录 / 开始写起。例如，使用绝对路径的表示方式指明 bin 文件所在的位置，该路径应写为 /usr/bin
    
    相对路径：和绝对路径不同，相对路径不是从根目录 / 开始写起，而是从当前所在的工作目录开始写起。例如cd .. (.表示当前目录、..表示上一级目录)

eg：

```bash
cd /    #切换到根目录      
cd ~    #切换到主目录      
cd -    #切换到上次访问的目录 
cd ..   #返回上一级目录
```

pwd命令：  

```
pwd 查看当前工作路径（绝对路径）
```

#### ls命令

 查看当前目录下的目录和文件

命令格式：ls [-选项] 目录名

选项：     -a：列出当前目录所有文件和目录（包括隐藏文件，以 .开头的为隐藏文件）

                -l：以列表的形式显示文件和目录
    
    示例：
        ls -a   查看该目录下所有文件或目录
        ls -l(简写ll) 以列表形式查看文件或目录

### 文件

新建文件【增】touch

    命令格式：touch 文件名
    
        示例：
        	 touch a.txt	            #在当前目录创建一个名为aa.txt的文件
             touch b.txt c.txt d.txt		#在当前目录下创建多个文件b.txt、c.txt、d.txt
    
    注意：使用vi 命令也可以创建新文件

删除文件 【删】 rm

> 命令格式：rm -rf 文件名
>
> ```XML
> 示例：
> 
> 
> 
> 	rm -rf  /tmp/a.txt       删除/tmp目录下的a.txt文件
> ```

修改文件内容【改】 vi或vim

> 命令格式：vi 文件名
>
> ```XML
> 示例：
> 
> 
> 
> 	vi a.txt 进入a.txt进行编辑
> ```
>
> 具体vi编辑器的使用查看前面发过的文章

文件移动或重命名：mv

> 命令格式：mv 文件名 新文件名
>
> ```XML
> 示例：
> 
> 
> 
> 	mv  hello.txt  hi.txt	#将当前目录下的hello.txt重命名为hi.txt
> 
> 
> 
> 	mv  /tmp/a.txt  /tmp/b.txt	#将/tmp目录下的a.txt重命名为b.txt
> ```

文件的复制：cp

    命令格式：cp 原文件名 指定目录
    
        示例： 
        	cp a.txt  hadoop/  	#将当前目录下的a.txt复制到hadoop目录下
        	cp a.txt  hadoop/b.txt	#将当前目录下的a.txt复制到hadoop目录下重命名为b.txt
    
    注意：可以复制的时候重命名

查看文件内容【查】

> 文件的查看命令：cat、more、less、head、tail

cat：查看文件内容，看最后一屏

命令格式：cat [选项] 文件名

选项： -n ：显示行号

```XML
示例：



	cat /etc/sudo.conf  #使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容
```

more：百分比显示

```XML
示例：



	more /etc/sudo.conf  #使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看
```

less：翻页查看

```XML
示例：



	less /etc/sudo.conf   #使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上和向下翻页，q结束查看
```

head：默认查看文件前十行内容

```XML
示例：



	head -5 /etc/sudo.conf    #使用head -5 查看/etc/sudo.conf文件的前5行内容
```

tail：默认查看文件后十行内容

```XML
示例：



	tail -5 /etc/sudo.conf 		#使用tail -5 查看/etc/sudo.conf文件的后5行内容 
```

### 创建链接文件：ln

> 命令格式：ln [-选项] 源文件 目标文件
>
> 选项： -s ：创建软连接（相当于快捷键）
>
> ```XML
> 示例：
> 
> 
> 
> 	ln data.txt d   #创建data.txt文件的硬链接d
> 
> ```

```XML
示例：



	ln -s data.txt da   #创建data.txt的软连接文件da
```

注意：加-s创建软链接，不加-s则创建硬链接，软链接前面是 l 开头的（link）,而硬链接是 - 开头，表示文件；软链接类似与 windows 的快捷方式，有一个明显的箭头指向，而指向的是源文件；硬链接文件除了文件名与源文件不一样，其余所有信息都是一样的。类似于 cp 复制操作。但是又和复制不一样，硬链接可以同步更新。

## 文本编辑

### 一、vi、vim编辑器简介

由加州大学伯克利分校，Bill Joy 研究开发。 文本编辑器有很多，比如图形模式的gedit、kwrite、OpenOffice，文本模式下的编辑器有vi、vim（vi的增强版本）。vi和vim是我们在Linux中最常用的编辑器。vi或vim是Linux最基本的文本编辑工具，vi或vim虽然没有图形界面编辑器那样点鼠标的简单操作，但vi编辑器在系统管理、[服务器](https://cloud.tencent.com/product/cvm?from=10680)管理字符界面中，永远不是图形界面的编辑器能比的。来源于百度百科

VI是Unix操作系统和类Unix操作系统中最通用的文本编辑器。 VIM编辑器是从VI发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM与VI编辑器完全兼容。

一、vim的三种模式

     正常模式——按Esc进入， 左下角显示文件名或为空 ，输入vim命令前都需要先按Esc！该模式下又分为命令模式操作和末行模式操作。
     
     插入模式——按i进入， 左下角显示–INSERT–，这个是insert单词的第一个字母，这样好记，编辑文件时很常用。
     
     可视模式—— 按v或V进入，左下角显示–VISUAL–阅读模式，暂时我是这么理解的…

### 二、vim的进入及命令语法

在Linux系统Shell提示符下输入vim和文件名称后，就进入vim编辑界面。若文件不存在则会新建一个文件，若存在则默认编辑该文件。



## 二、三种切换模式

### 文本处理工具

文本内容

cat

cat命令用于连接文件并打印到标准输出设备上，查询大文件时，比view更好用，很快加载出来，同时也可以不进入编辑文件页面，下面介绍下cat的命令，主要是查找文件内容关键词

格式命令

```
[root@localhost ~]# cat [选项] 文件名
选项：
　　-A：相当于-vET选项的整合，用于列出所有隐藏符号
　　-E：列出每行结尾的回车符$
　　-n：显示行号
　　-T：把Tab键用^I显示出来
　　-v：列出特殊字符
```

```javascript
[jock@localhost ~]$ vim  #通过vim命令进入vim编辑器，此时为命令模式，里面可以查看vim的版本、以及如何求助等信息
```

命令语法： vim [选项] [文件] vim [选项] 用vi替代vim也可以。命令中常见的各选项如下（具体用法还没有实际操作过，先列出几个）：

```javascript
+        # 在文件末尾开始
-R        # 只读模式
-b        # 二进制模式
-e        # Ex模式
+<行数>        # 从指定行开始
```

### 三、帮助命令

最先学会求助的方法

```javascript
:help  xxx       # 显示xxx命令的帮助，一般有这个够用了
:help       # 显示帮助文档，大致浏览即可
[jock@localhost ~]$ vimtutor       # 查看官文教程，不过版本较老，不建议细看
```

### 四、插入模式、光标移动、文件命令

#### 1. 进入插入模式

在shell中输入vim文件名默认进入的是命令模式，在命令模式无法输入数据，需要在命令模式下使用以下命令进入插入模式，从而实现在文件中输入数据。

```javascript
i        # 在当前位置插入
a        # 在当前位置后插入
A        # 在当前行尾插入
o        # 在当前行之后插入一行
O        # 在当前行之前插入一行
s        # 删除光标位置的一个字符，然后进入插入模式
S        # 删除光标所在的行，然后进入插入模式
```

#### 2. 光标移动

使用上下左右箭头即可移动光标。其他命令如下

```javascript
h       # 左移一个字符
l       # 移一个字符，通常用w向右移动到下一个单词的第一个字母
j       # 上移一个字符
k       # 下移一个字符
#注意hljk前都可以在前面加上数字n，从而实现跨越的移动。比如5h，表示向左移动5个字符。
H        # 使光标移动到屏幕的顶部，head
M        # 使光标移动到屏幕的中间，middle
L        # 使光标移动到屏幕的底部
# 还可以使用[PU] [PD]实现上下翻页
```

### 五、命令模式与末行模式操作

进入末行模式需要先按[Esc]键进入命令模式，再按冒号[:]则可以进入末行模式。

#### 1. 保存和退出

```javascript
:q!       # 不保存文件，强制退出vim，若退出报错，直接用这个命令即可。
:q       # 不保存文件，退出vim。
:wq       # 保存文件，退出vim，w(write), q(quit)。
:wq!       # 保存文件，并强制退出vim。
:w        # 保存文件，但不退出vim。
:w filename       # 将文件另存为filename。
:wq! filename       # 将文件另存为filename，并强制退出vim。
:r filename       # 打开另外一个已经存在的文件filename。
:e filename       # 新建名为filename的文件。
:f filename       # 把当前文件改名为filename文件。
:nw filename       # 将第n行内容保存到文件filename中，n代表数字。
:n1,n2w filename       # 将第n1行开始到n2行结束的内容保存到文件filename中，n1，n2代表数字。
:1,.w filename       # 将第一行开始到光标当前位置的所有内容保存到文件filename中。
:.,$w filename       # 将从光标开始位置到文件末尾的所有内容保存到文件filename中。
:/str/w filename       # 将包含有str的行写到文件filename中，str代表字符。
:/str1/,/str2/w filename       # 将包含有str1开始到str2结束的内容写入文件filename中，str1和str2代表字符。
:e!       # 放弃所有修改，从上次保存文件开始再编辑命令历史
ZZ:       # 保存退出
ZQ       # 不保存退出
```

| :q!                      | 不保存文件，强制退出vim，若退出报错，直接用这个命令即可。    |
| ------------------------ | ------------------------------------------------------------ |
| :q                       | 不保存文件，退出vim。                                        |
| :wq                      | 保存文件，退出vim，w(write), q(quit)。                       |
| :wq!                     | 保存文件，并强制退出vim。                                    |
| :w                       | 保存文件，但不退出vim。                                      |
| :w filename              | 将文件另存为filename。                                       |
| :wq! filename            | 将文件另存为filename，并强制退出vim。                        |
| :r filename              | 打开另外一个已经存在的文件filename。                         |
| :e filename              | 新建名为filename的文件。                                     |
| :f filename              | 把当前文件改名为filename文件。                               |
| :nw filename             | 将第n行内容保存到文件filename中，n代表数字。                 |
| :n1,n2w filename         | 将第n1行开始到n2行结束的内容保存到文件filename中，n1，n2代表数字。 |
| :1,.w filename           | 将第一行开始到光标当前位置的所有内容保存到文件filename中。   |
| :.,$w filename           | 将从光标开始位置到文件末尾的所有内容保存到文件filename中。   |
| :/str/w filename         | 将包含有str的行写到文件filename中，str代表字符。             |
| :/str1/,/str2/w filename | 将包含有str1开始到str2结束的内容写入文件filename中，str1和str2代表字符。 |
| :e!                      | 放弃所有修改，从上次保存文件开始再编辑命令历史               |
| ZZ:                      | 保存退出                                                     |
| ZQ                       | 不保存退出                                                   |

#### 2. 删除命令

简单的删除跟word操作一样

```javascript
:d        # 删除当前行。
:nd        # 删除从当前行开始的n行，n代表数字
:n1,n2 d        # 删除n1行开始到n2行结束的所有内容
dG       # 删除从当前行开始到文件末尾的所有内容
:.,$d        # 删除从当前行开始到文件末尾的所有内容
:/str1/,/str2/d        # 删除从str1到str2之间的所有内容，str1、str2代表字符。
```

#### 3. 复制、移动、跳转

```javascript
:n1,n2 co n3        # 将n1和n2行之间的所有内容复制到n3行后面
:n1,n2 m n3        # 将n1和n2行之间的所有内容移动到n3行后面
:n        # 跳转到第n行
```

#### 4. 替换、查找字符

```javascript
#替换
:s/str1/str2/        # 将光标所在行第一个字符str1替换为str2
:s/str1/str2/g        # 将光标所在行所有的字符str1替换为str2
:n1,n2s/str1/str2/g        # 将n1行到n2行中所有的字符str1替换为str2
:%/str1/str2/g        # 将文件中所有的字符str1替换为str2
:.,$s/str1/str2/g        # 将光标当前位置开始到文件结束的所有字符str1替换为str2
#查找
/关键字       # 先按[/]键，在输入想查找的字符，如果第一次查找的不是想要的，可以一直按[n]键会往后查找下一个关键字，按[N]反向查找。
?关键字       # 同/关键字
```

#### 3. 文件命令

```javascript
vim filename       # 打开打个文件，若不存在则新建一个文件
vim file1 file2 file3...       # 同时打开多个文件
:open file       # 在vim窗口打开一个新文件
:split file       # 在新窗口中打开文件
:bn       # 切换到下一个文件
:bp       # 切换到上一个文件
```

#### 5. 撤销和重复

```javascript
u        # 撤销上一个操作，按多次[n]可以多次执行撤销
U        # 取消所有操作
.        # 再执行一次刚刚完成的操作，相当于恢复
```

#### 6. 其他命令

```javascript
:!command        # 运行shell命令，command代表命令
:set number        # 在文件中的每一行前面列出行号
:set nonumber        # 取消在文件中的每一行前面列出行号
Ctrl +g       # 列出光标所在行行号
:set readonly        # 设置文件为只读模式
```



## 磁盘与文件系统

### 磁盘结构

1.硬盘的物理结构
盘片：硬盘有多个盘片，每盘片有两面

磁头：每面一个磁头

2.硬盘的数据结构
扇区：盘片被分为多个扇形区域，每个扇形区存放512字节的数据，硬盘最小的存储单位

磁道：同一盘片不同半径的同心圆，是由磁头在盘片表面划出的圆形轨迹

柱面：不同盘片相同半径构成的圆柱面，由同一半径圆的多个磁道组成

硬盘存储容量=磁头数✖磁道（柱面）数✖每道扇区数✖每扇区字节数 （512字节）

可以用柱面/磁头/扇区来唯一定位磁盘上每一个区域

磁盘接口类型：IDE、SATA、SCSI、SAS、光纤通道

| 硬件接口类型 | 功能                                                         |
| ------------ | ------------------------------------------------------------ |
| IDE          | 并口数据线连接主板和硬盘，抗干扰性太差，且排线占用空间大，不利于电脑内部散热，已逐渐被SATA所取代 |
| SATA         | 抗干扰性强，支持热插拔等功能，速度快，纠错能力强             |
| SCSI         | 小型机系统接口，SCSI硬盘广为工作站级个人电脑以及服务器所使用，资料传输时CPU占用率较低，转速快，支持热插拔 |
| SAS          | 是新一代的SCSI技术，和SATA硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到6Gb/s |

### 磁盘分区

#### 创建分区

```
fdisk -l
```





其中第一个框和第二个框，是已经分好区的不同磁盘。

开始分区

```javascript
#输入要进行分区的磁盘名称
fdisk /dev/sdb
```







输入m，可以查看有哪些操作





输入p 查看当前硬盘分区，目前有一个分区。



输入n新建一个分区，输入p 建立分区，输入分区编号2代表建立第二个分区



然后会让你设置开始扇区，直接进行回车代表不输入直接从空置的磁盘开始部分开始划分    

然后结束扇区设置自定义划分它300G,可以按照自己需要进行划分。注意在300G前面一定要加“+”设置才有效。

如果要继续建立第三个分区，则继续输入n,p,再定义分区大小





最后保存分区 输入w

最后，检查分区是否已经建立好！如果出现红色区域，则表示已经建立好了。





实这个时候，建立好的分区还不能用，还需要挂载才可以用。但是挂载之前，必须要格式化，才行。



#### 2.格式化分区

1) fdisk  -l |grep sd        查看分区情况

    或者fdisk -l





2)   创建[数据存储](https://cloud.tencent.com/product/cdcs?from=10680)目录，存储路径自定义

    mkdir -p /openstack/glance    
    
    mkdir -p /openstack/mysql
    
    mkdir -p /openstack/data





3) 格式化刚刚分区的磁盘

mkfs.xfs  /dev/sdb1        格式化sdb1磁盘

mkfs.xfs  /dev/sdb2        格式化sdb2磁盘

mkfs.xfs  /dev/sdb3







4) vim  /etc/fstab      

　　/dev/sdb1 /openstack/glance/ xfs defaults 0 0 　/dev/sdb2                                 /openstack/mysql/  xfs     defaults        0 0  　/dev/sdb3                                 /openstack/data/    xfs     defaults        0 0 









| /etc/fstab文件负责配置Linux开机时自动挂载的分区 第一列可以是实际分区名，也可以是实际分区的卷标（Lable） 第二列是挂载点,挂载点必须为当前已经存在的目录 第三列为此分区的文件系统类型 第四列是挂载的选项，用于设置挂载的参数                                                            auto: 系统自动挂载，fstab默认就是这个选项defaults: rw, suid, dev, exec, auto, nouser, and async.noauto 开机不自动挂载nouser 只有超级用户可以挂载ro 按只读权限挂载rw 按可读可写权限挂载user 任何用户都可以挂载请注意光驱和软驱只有在装有介质时才可以进行挂载，因此它是noauto                                                                第五列是dump备份设置,当其值设置为1时，将允许dump备份程序备份；设置为0时，忽略备份操作； 第六列是fsck磁盘检查设置,其值是一个顺序。当其值为0时，永远不检查；而 / 根目录分区永远都为1。其它分区从2开始，数字越小越先检查，如果两个分区的数字相同，则同时检查。 | auto: 系统自动挂载，fstab默认就是这个选项defaults: rw, suid, dev, exec, auto, nouser, and async.noauto 开机不自动挂载nouser 只有超级用户可以挂载ro 按只读权限挂载rw 按可读可写权限挂载user 任何用户都可以挂载请注意光驱和软驱只有在装有介质时才可以进行挂载，因此它是noauto |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| auto: 系统自动挂载，fstab默认就是这个选项defaults: rw, suid, dev, exec, auto, nouser, and async.noauto 开机不自动挂载nouser 只有超级用户可以挂载ro 按只读权限挂载rw 按可读可写权限挂载user 任何用户都可以挂载请注意光驱和软驱只有在装有介质时才可以进行挂载，因此它是noauto |                                                              |

5) mount  -a     进行磁盘挂载

6) df -a          查看挂载情况







### 查询文件全部内容

```powershell
cat text.txt
[root@localhost ~]# cat anaconda-ks.cfg
#version=DEVEL
# System authorization information
auth --enableshadow --passalgo=sha512
# Use CDROM installation media
省略部分内容……
```

### 查询文件时，显示行数

```powershell
cat -n text.txt   由 1 开始对所有输出的行数编号
cat -b text.txt    和 -n 相似，只不过对于空白行不编号
```

使用“-n”选项，则会显示行号：

```
[root@localhost ~]# cat -n anaconda-ks.cfg
     1   #version=DEVEL
     2   # System authorization information
     3   auth --enableshadow --passalgo=sha512
     4   # Use CDROM installation media
     省略部分内容……
```

使用“-A”选项，则相当于使用了“-vET”选项，可以查看文本中的所有隐藏符号，包括回车符（$）、Tab键（^I）等：

```
[root@localhost ~]# cat -A anaconda-ks.cfg
#version=DEVEL$
# System authorization information$
auth --enableshadow --passalgo=sha512$
# Use CDROM installation media$
省略部分内容……
```

## 1编程基础

Linus:Talk is cheap.show me the code

### 1.1程序组成

程序：算法+数据结构
数据：是程序的核心
算法：处理数据的方式
数据结构：数据在计算机中的类型和组织方式

### 程序编程风格

- 面向过程语言

  - 做一件事情，排出个步，第一步干什么，第二步干什么，如果出现情况A，做什么处理，如果出现了情况B，做什么处理

  - 问题规模小，可以步化，按部就班处理

  - 以指令为中心，数据服务于指令

  - C,shell

- 面向对象语言
  - 一种认识世界、分析世界的方法论，将万事万物挂象为各种对象
  - 类是独象的概念，是万事万物的挂象，是一类事物的共同特征的集合
  - 对象是类的具象，是一个实体
  - 问题规模大，复杂系统
  - 以数据为中心，指令服务于数据
  - java，C#，python.golan等

### 编程语言

计算机：运行二进制指令
编程语言：人与计算机之间交互的语言，分为两种：低级语言和高级语言

- 低级编程语言：
  机器：二进制的0和1的序列，称为机器指令，与自然语言差异太大，难懂、难写
  汇编：用一些动记符号替代机器指令，称为汇编活言
  - 如：ADDAB将毒存器A的数与寄存器B的数相加得到的数放到高存器A中
  - 汇编语言写好的程序需要汇编程序转换成机器指令
  - 汇编语言稍微好理解，即机器指令对应的助记符，助记符更接近自然语言
- 高级程语言：
  - 编泽：高级语言-->编译器->机器代码文件->执行，如：C，C++
  - 解释：高级语言->执行解释器->机器代码，如：shell，Pthon，php，Javascript，perl

## shell脚本语言的基本结构

###  shell脚本的用途

- 自动化常用命令
- 执行系统管理和故物排除
- 创建简单的应用程序
- 处理文本或文件

### shell脚本基本结构

she脚本编程：是基于过程式。解样执行的语言
偏程语宫的基本结构：

- 各种系统命令的组合
- 数据存储：变量、数姐
- 表达式：a+b
- 控语句：if

shll弹本：包含一命令或声明。并符合一定格式的文本文件
格式要求：首行shebang机制

创建shell脚本过程

第一步：使用文本编辑器来创建文本文件
第一行老须包括shell声明序列：#
示例：

添加注注解以#开头
第二步：执行权限
给予执行权限，在命令行上指定脚本的绝对或相对路径
第三步：运行脚本
直接运行解释器，将脚本作为解程器程序的参数运行

### 脚本注释规范

1、第一行一般为调用使用的语言
2、程序名，避免更改文件名为无法找到正确的文件
3、板本号
4、更改后的时间
5、作者相关信息
6、该程序的作用，及注意事项
7、是后是各板本的更新简要说明









1.链接的概念

简单的理解链接就是快捷方式，在Windows系统中，快捷方式就是指向原文件的一个链接文件，可以让用户从不同的位置来访问原始的文件；原文件一旦被删除或剪切到其他地方后，会导致链接文件失效。但是在Linux系统中这个看似简单的东西和Windows里的可能不大一样。

2.链接的分类

在Linux系统中有软、硬两种链接文件之分。

硬链接（hard link）

我们可以将它理解为一个“指向原始文件inode的指针”，系统不为它分配独立的inode和文件。所以，硬链接文件与原始文件其实是同一个文件，只不过是不同的名字而已。我们每添加一个硬链接，该文件的inode链接数就会增加1；而且只有当该文件的inode连接数为0时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件的inode的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。



硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode  Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。

总结起来有以下几点：

1.硬链接，以文件副本的形式存在。但不占用实际空间。

2.不允许给目录创建硬链接

3.硬链接只有在同一个文件系统中才能创建

 

软连接（也称为符号链接[symbolic link]）

软链接仅仅包含所链接文件的路径名，因此能链接目录文件，也可以跨越文件系统进行链接。但是，当原始文件被删除后，链接文件也将失效，从这一点上来说与Windows系统中的“快捷方式”具有一样的性质。

另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。

总结起来有以下几点：

1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式

2.软链接可以跨文件系统 ，硬链接不可以

3.软链接可以对一个不存在的文件名进行链接

4.软链接可以对目录进行链接

3.ln命令

ln 命令用于创建链接文件，格式为“ln [选项] 目标”，其可用的参数以及作用如下：

-b 删除，覆盖以前建立的链接

-d 允许超级用户制作目录的硬链接

-f 强制执行

-i 交互模式，文件存在则提示用户是否覆盖

-n 把符号链接视为一般目录

-s 软链接(符号链接)

-v 显示详细的处理过程

4.使用实例演示硬链接和软链接之间的区别

创建一个软链接

```bash
[root@Linux]$ touch f1 #创建一个测试文件f1
[root@Linux]$ ln f1 f2 #创建f1的一个硬连接文件f2
[root@Linux]$ ln -s f1 f3 #创建f1的一个符号连接文件f3
[root@Linux]$ ls -li # -i参数显示文件的inode节点信息
total 0
9797648 -rw-r--r-- 2 root root 0 Apr 21 08:11 f1
9797648 -rw-r--r-- 2 root root 0 Apr 21 08:11 f2
9797649 lrwxrwxrwx 1 root root 2 Apr 21 08:11 f3 -> f1
```

上面的结果中可以看出，硬连接文件f2与原文件f1的inode节点相同，均为9797648，然而符号连接文件的inode节点不同。

```bash
[root@Linux]$ echo "I am f1 file" >>f1
[root@Linux]$ cat f1
I am f1 file
[root@Linux]$ cat f2
I am f1 file
[root@Linux]$ cat f3
I am f1 file
[root@Linux]$ rm -f f1
[root@Linux]$ cat f2
I am f1 file
[root@Linux]$ cat f3
cat: f3: No such file or directory
```

通过上面的测试可以看出：当删除原始文件f1后，硬连接f2不受影响，但是符号连接f1文件无效。

**3.总结**

依此您可以做一些相关的测试，可以得到以下全部结论：

1).删除符号连接f3,对f1,f2无影响；

2).删除硬连接f2，对f1,f3也无影响；

3).删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；

4).同时删除原文件f1,硬连接f2，整个文件会真正的被删除。

ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。

ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。**1．命令格式：**

```
ln [参数][源文件或目录][目标文件或目录]
```

**软链接：**软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式

软链接可以 跨文件系统 ，硬链接不可以软链接可以对一个不存在的文件名进行链接

软链接可以对目录进行链接

**硬链接:**硬链接，以文件副本的形式存在。但不占用实际空间。

不允许给目录创建硬链接

硬链接只有在同一个文件系统中才能创建



第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；

第二，ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s，  它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。

**．命令参数：**

必要参数:

-b 删除，覆盖以前建立的链接

-d 允许超级用户制作目录的硬链接

-f 强制执行

-i 交互模式，文件存在则提示用户是否覆盖

-n 把符号链接视为一般目录

-s 软链接(符号链接)

-v 显示详细的处理过程选择参数:

-S “-S<字尾备份字符串> ”或 “--suffix=<字尾备份字符串>”

-V “-V<备份方式>”或“--version-control=<备份方式>”

--help 显示帮助信息

--version 显示版本信息

## shell的基本应用

### 含义

```txt
首先shell的英文含义是“壳”；

    它是相对于内核来说的，因为它是建立在内核的基础上，面向于用户的一种表现形式，比如我们看到一个球，见到的是它的壳，而非核。

    Linux中的shell，是指一个面向用户的命令接口，表现形式就是一个可以由用户录入的界面，这个界面也可以反馈运行信息；
```

   **shell脚本是 由一些按照一定格式组合起来的shell命令 组成。shell脚本不需要编译就可以直接执行，它是边解释边执行的。**

### 存在形式

```shell
首先shell的英文含义是“壳”；

    它是相对于内核来说的，因为它是建立在内核的基础上，面向于用户的一种表现形式，比如我们看到一个球，见到的是它的壳，而非核。

    Linux中的shell，是指一个面向用户的命令接口，表现形式就是一个可以由用户录入的界面，这个界面也可以反馈运行信息；
```

### 执行

```shell
首先shell的英文含义是“壳”；

    它是相对于内核来说的，因为它是建立在内核的基础上，面向于用户的一种表现形式，比如我们看到一个球，见到的是它的壳，而非核。

    Linux中的shell，是指一个面向用户的命令接口，表现形式就是一个可以由用户录入的界面，这个界面也可以反馈运行信息；
```

### 命令解释器

 Linux系统提供多种不同的Shell以供选择。常用的有Bourne Shell（简称sh）、C-Shelll（简称csh）、Korn Shell（简称ksh）和Bourne Again Shell (简称bash)。

    查看当前系统使用的shell默认解释器:echo $SHELL

### 格式

```shell
[etk@localhost ~]$ command [-options] parameter parameter2 ...

                                       命令            选项         参数1             参数2
```

一条命令的三要素用空格隔开如sudo apt-get install rxvt

若将多个命令在一行书写，用分号（;）将各个命令隔开如sudo apt-get upgrade;sudo apt-get update

如果一条命令不能在一行写完，在行尾使用反斜杠（\）标明该条命令还未结束

使用TAB键可以补全命令，按两下TAB键可以查看同名命令或者文件；使用上下键，查看历史命令记录

1.一行命令中第一个输入的部分绝对是“命令（command）”或可执行文件。

2.command 为命令的名称，例如变换路径的命令为cd等。

3.中括号[] 并不存在于实际的命令中，而加入参数设置时，通常参数前会带 - 号，例如 -h ,有时候会使用参数的完整全名，则参数前带有 -- 符号，例如 --help.

4.parameter1 parameter2.. 为依附在 option 后面的参数，或者是 command 的参数。

5.命令， -options ,参数等这几个命令中间以空格来区分，不论空几格 shell 都视为一格。 

6.按下 [Enter] 按键后，该命令就立即执行。[Enter] 按键代表着一行命令的开始启动。

7.命令太长的时候，可以使用反斜杠（\）来转义[Enter]符号，使命令连续到下一行。

   注意：反斜杠后立刻接特殊字符，才能转义。

其它：

a.在 Linux 系统中，英文大小写字母是不一样的。举例来说，cd 与 CD 并不同。

- shell提示符号中"$“表示为其他用户,”#"为超级用户
- command命令需要**严格区分大小写**
- options参数由"-"引导

### 流程

- 用户在命令行提示符下键入命令文本，开始与shell进行交互
- 之后。shell将用户的命令或者按键转化为内核所能理解的指令
- 控制操作系统做出响应，将命令传递到控制相关硬件设备
- 然后，shell将输出结构通过shell提交给用户

特殊字符

通配符

hell中的通配符：用于处理查找一组名称类型相同的文件，提高效率

| 通配符          | 含义                             | 实例                                                         |
| --------------- | -------------------------------- | ------------------------------------------------------------ |
| 星号（*）       | 匹配任意长度的字符串             | 用file_*.txt，匹配file_zhang.txt，file_le.txt，file_wang.txt等同类型文件 |
| 问号（?）       | 匹配一个长度的字符               | 用file_?.txt，匹配file_1.txt，file_2.txt，file_3.txt文件     |
| 方括号（[…]）   | 匹配其中指定的一个字符           | 用file_[otr].txt，匹配file_o.txt，file_t.txt，file_r.txt特定字符 |
| 方括号（[ - ]） | 匹配指定的一个字符范围           | 用file_[a-z].txt，匹配file_a.txt，file_b.txt，file_c.txt，… ，file_z.txt范围内的字符 |
| 方括号（[^ …）  | 除了其中指定的单个字符，均可匹配 | 用file_[ ^ otr ].txt，匹配除了file_o.txt，file_t.txt，file_r.txt特定字符以外的其他字符 |

管道

shell中的管道可以将一些列命令连接起来，表示为第一个命令的输出将作为第二个命令的输入，通过管道传递给第二个命令，第二个命令的输出又作为第三个命令的输入，以此类推，通常使用"|"符号连接命令管道

```shell
如下所示可以借助管道命令，将ls命令作为wc命令的输入，得到该目录下的文件数目
ls /usr/bin | wc -w
```

Linux 的命令按照来源方式分为两种：**Shell 内置命令** 和 **外部命令**。所谓Shell内置命令，就是Shell自带的命令，这些命令是**没有执行文件**的；而外部命令就是由程序员单独开发的，是外来命令，所以会有命令的执行文件。Linux中的绝大多数命令是外部命令。

> **如何理解内置命令？**
>
> **内置命令在Linux系统启动时就调入内存，是常驻内存的，所以执行效率高。而外部命令是系统的软件功能，用户需要时才从硬盘读入内存。**

### 分类



在大部份的 UNIX 系统，三种著名且广被支持的 **[shell](https://haicoder.net/shell/shell-tutorial.html)** 是 Bourne shell（AT&T shell，在 Linux 下是 BASH）、C shell（Berkeley shell，在 Linux 下是 TCSH）和 Korn shell（Bourne shell 的超集）。

这三种 shell 在交谈（interactive）模式下的表现相当类似，但作为命令文件语言时，在语法和执行效率上就有些不同了。

#### bash

Bourne shell 是标准的 UNIX shell，以前常被用来做为管理系统之用。大部份的系统管理命令文件，例如 rc  start、stop 与 shutdown 都是 Bourne shell 的命令档，且在单一使用者模式（single user mode）下以 root 签入时它常被系统管理者使用。

Bourne shell 是由 AT&T 发展的，以简洁、快速著名。 Bourne shell 提示符号的默认值是 $。

#### csh

C shell 是柏克莱大学（Berkeley）所开发的，且加入了一些新特性，如命令列历程（history）、别名（alias）、内建算术、档名完成（filename completion）、和工作控制（job control）。

对于常在交谈模式下执行 shell 的使用者而言，他们较喜爱使用 C shell；但对于系统管理者而言，则较偏好以 Bourne  shell 来做命令档，因为 Bourne shell 命令档比 C shell 命令档来的简单及快速。C shell 提示符号的默认值是 %。

#### ksh

Korn shell 是 Bourne shell 的超集（superset），由 AT&T 的 David Korn  所开发。它增加了一些特色，比 C shell 更为先进。Korn shell  的特色包括了可编辑的历程、别名、函式、正规表达式万用字符（regular expression wildcard）、内建算术、工作控制（job  control）、共作处理（coprocessing）、和特殊的除错功能。Bourne shell 几乎和 Korn shell  完全向上兼容（upward compatible），所以在 Bourne shell 下开发的程序仍能在 Korn shell 上执行。Korn shell 提示符号的默认值也是 $。

在 Linux 系统使用的 Korn shell 叫做 pdksh，它是指 Public Domain Korn  Shell。除了执行效率稍差外，Korn shell 在许多方面都比 Bourne shell 为佳；但是，若将 Korn shell 与 C  shell 相比就很困难，因为二者在许多方面都各有所长，就效率和容易使用上看，Korn shell 是优于 C shell，相信许多使用者对于 C Shell 的执行效率都有负面的印象。

在 shell 的语法方面，Korn shell 是比较接近一般程序语言，而且它具有子程序的功能及提供较多的资料型态。至于 Bourne  shell，它所拥有的资料型态是三种 shell 中最少的，仅提供字符串变量和布尔型态。在整体考量下 Korn shell  是三者中表现最佳者，其次为 C shell，最后才是 Bourne  shell，但是在实际使用中仍有其它应列入考虑的因素，如速度是最重要的选择时，很可能应该采用 Bourne shell，因它是最基本的  shell，执行的速度最快。

#### tcsh

tcsh 是近几年崛起的一个免费软件（Linux 下的 C shell 其实就是使用 tcsh）执行，它虽然不是 UNIX  的标准配备，但是从许多地方您都可以下载到它。如果您是 C shell 的拥护者，笔者建议不妨试试 tcsh，因为您至少可以将它当作是 C  shell 来使用。如果您愿意花点时间学习，您还可以享受许多它新增的优越功能，例如：

1. tcsh 提供了一个命令列（command line）编辑程序。
2. 提供了命令列补全功能。
3. 提供了拼字更正功能。它能够自动检测并且更正在命令列拼错的命令或是单字。
4. 危险命令侦测并提醒的功能，避免您一个不小心执行了rm* 这种杀伤力极大的命令。
5. 提供常用命令的快捷方式（shortcut）。

#### ash

一个简单的轻量级的 Shell，占用资源少，适合运行于低内存环境，但是与下面讲到的 bash shell 完全兼容。

#### Shell分类总结

在大部份的 UNIX 系统，三种著名且广被支持的 shell 是 Bourne shell（AT&T shell，在 Linux  下是 BASH）、C shell（Berkeley shell，在 Linux 下是 TCSH）和 Korn shell（Bourne  shell 的超集）。

这三种 shell 在交谈（interactive）模式下的表现相当类似，但作为命令文件语言时，在语法和执行效率上就有些不同了。

### shell脚本

#### 格式

shell 命令由三部分组成：命令，选项和参数。它们的格式为：

```
command [option] [argument]

```

其中，选项用于调整命令的行为，通常以 “-” 或 “–” 开头，也有直接以字母开头的选项，不过这种选项不多见；参数用于指定命令要处理的目标。选项和命令都属于可选的，有些情况下，我们可以单独执行命令。

```
it@workstation:~$ ls -l /home/
total 4
drwxr-xr-x 17 it it 4096 1月  28 13:49 it

```

其中，ls 就是命令，-l 为选项，/home/ 则是参数；

在 Linux 中，存在三种选项风格：

短选项风格： 来自 Unix，如前面的示例中的 -l 这就是一个短选项；

长选项风格： GNU 风格选项，如 --human；

很多命令都同时支持长选项和短选项，并且，每个短选项，都有一个与之对应的长选项：

```
it@workstation:~$ free -h
              total        used        free      shared  buff/cache   available
Mem:          1.9Gi       746Mi       134Mi        12Mi       1.1Gi       1.0Gi
Swap:         2.0Gi       0.0Ki       2.0Gi
it@workstation:~$ free --human
              total        used        free      shared  buff/cache   available
Mem:          1.9Gi       746Mi       134Mi        12Mi       1.1Gi       1.0Gi
Swap:         2.0Gi       0.0Ki       2.0Gi
```



#### shell命令简介

#### mkdir

##### mkdir命令的功能说明

> 																`mkdir`命令用于创建目录，默认情况下，要创建的目录已存在，会提示文件存在，不会继续创建目录。

选项

> - **-p：**递归创建目录，如果目录事先存在，也不会报错*
> - **-m：**设置新创建的目录的默认目录对应的权限
> - **-v：**显示创建的过程

```bash
mkdir -p /data  -->创建测试目录
cd /data/
tree -d  -->看是否有其他目录
mkdir test  -->创建一个test目录
tree -d  -->再次查看，发现已经创建好了
mkdir test  -->再创建一次，提醒已经存在
```

###### 使用 `-p` 参数递归创建目录

```x86asm
mkdir aaa/bbb  -->创建aaa下的bbb，因为没有aaa，所以报错
mkdir -p aaa/bbb  -->使用 -p 参数，就可以创建了
tree -d  -->查看结果（也可先创建aaa，再创建bbb，不推荐）
```

###### 加 `-v` 参数显示创建目录的过程(没什么实际用途）

```bash
mkdir -pv test1/test2
tree -d
```

###### 创建目录时可使用 `-m`参数设置目录的默认权

```bash
mkdir dir1  -->先创建一个默认目录    
ls -ld dir1        
mkdir -m 333 dir2  -->使用参数-m创建一个目录
ls -ld dir*  -->对比一下
ls
```

#### rmdir





ls:**显示目录下的内容**

1.	-a：显示目录下包括隐藏文件在内的所有文件名，即--all

注：在Linux中以 “.” 开头的文件是隐藏文件，只有通过 “-a” 选项才能查看。

2.	-l：显示文件的详细信息，即--long

注：显示的信息包括权限、引用计数、所有者、所属组、大小(字节)、文件修改时间、文件名

3.	-d：查看某个目录的详细信息，比如：ls -ld /root/
4.	-h：按照人们习惯的单位显示文件的大小，比如：ls -lh 显示的文件以千字节KB为单位
5.	-i：每个文件都有一个被称为inode的隐藏属性，可以看成系统搜索这个文件的ID，而 “-i” 选项就是用来查看文件的 i 节点号的。从理论上来说，每个文件的inode号都是不一样的。
6.	-t：依照文件最后的修改时间顺序列出文件